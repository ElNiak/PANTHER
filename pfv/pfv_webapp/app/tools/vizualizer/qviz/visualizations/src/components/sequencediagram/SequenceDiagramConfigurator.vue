<template>
    <div style="background-color: #cce5ff; padding: 0px 10px;" >
        <!--<div>{{(config ? config.manualRTT + " - " + config.scale : "UNKNOWN" )}}</div>-->
        <!--<b-button @click="adjustConfigTest()">Adjust config</b-button> -->

        <p style="padding-top: 10px;">Select one or more traces via the dropdown(s) below to visualize them in the sequence diagram</p>
        <b-container fluid>
                <b-row>
                    <!-- Note: adding connection.timeOffset to the :key is PARAMOUNT to getting reactivity working! -->
                    <ConnectionConfigurator v-for="(connection, index) of this.config.connections" 
                        :allGroups="store.groups" 
                        :connection="connection.connection" 
                        :key="index + connection.timeOffset" 
                        
                        :numericalInputValue="connection.timeOffset" 
                        :numericalInputName="( (allowCustomTimeOffset(connection, index)) ? 'Latency offset' : undefined)" 
                        
                        :canBeRemoved="(config.connections.length > 2 && index != 0)" 
                        
                        :onConnectionSelected="onConnectionSelected.bind(this, index)" 
                        :onRemoved="onConnectionRemoved.bind(this, index)" 
                        :onNumericalValueChanged="onTimeOffsetChange.bind(this, index)" />
                </b-row>
        </b-container>
    <!--
        <div v-for="(group, index) of store.groups" :key="index">
            {{group.description}}
            <div v-for="(connection,index) of group.GetConnections()" :key="index">
                - <b-button @click="addConnection(connection)">Add Connection</b-button>
            </div>
        </div>
    -->

        <b-container fluid> 
            <b-row>
                <b-col> 
                    <b-button @click="selectDefault()">Add trace</b-button><!-- &#43; PLUS + -->
                </b-col>
                <b-col cols="1" align-self="center"> <div class="text-right" v-b-tooltip.hover title="Increase if you have sub-millisecond latencies or want more space between events. 1 = ms level, 1000 = us level. Typically 10 or 100 is enough.">Time multiplier: </div></b-col>
                <b-col cols="1"> <b-input type="number" v-model="config.timeResolution"/></b-col>
            </b-row>
        </b-container>

        <b-alert v-if="connectionIsUnknownPerspective" show variant="danger">The selected trace has an unknown vantage point. We guessed it based on heuristics, but this could be wrong!</b-alert>

        <b-alert v-if="this.store.outstandingRequestCount === 0 && this.store.groups.length === 0" show variant="danger">Please load a trace file to visualize it</b-alert>
        <b-alert v-else-if="this.store.groups.length === 0" show variant="warning">Loading files...</b-alert>
    </div>
</template>

<script lang="ts">
    import { getModule } from "vuex-module-decorators";
    import { Component, Vue, Prop } from "vue-property-decorator";
    import SequenceDiagramConfig from "./data/SequenceDiagramConfig";
    import ConnectionConfigurator from "@/components/shared/ConnectionConfigurator.vue";
    import * as qlog from '@/data/QlogSchema';

    import ConnectionStore from "@/store/ConnectionStore";
    import ConnectionGroup from "@/data/ConnectionGroup";
    import Connection from "@/data/Connection";

    @Component({
        components: {
            ConnectionConfigurator,
        },
    })
    export default class SequenceDiagramConfigurator extends Vue {
        @Prop()
        protected config!: SequenceDiagramConfig;

        protected store:ConnectionStore = getModule(ConnectionStore, this.$store);

        public get connectionIsUnknownPerspective() {

            if ( this.config.connections.length === 0 ){
                return false;
            }

            let connection:Connection = this.config.connections[0].connection;
            if ( connection.wasAutoGenerated && this.config.connections.length > 1 ) {
                connection = this.config.connections[1].connection;
            }

            return  connection.getEvents().length > 0 &&
                    connection.vantagePoint && 
                    connection.vantagePoint.type === qlog.VantagePointType.unknown;
        }

        public allowCustomTimeOffset(conn:Connection, index:number):boolean {
            // only allow custom offsets for non-auto generated traces (they don't make sense for autogenerated ones)
            return index > 0 && this.config.connections.find( (c) => c.connection.wasAutoGenerated ) === undefined; 
        }

        public onConnectionSelected(connectionIndex:number, connection:Connection){
            console.log("SequenceDiagramConfigurator:onConnectionSelected : ", this.config, connectionIndex, connection);

            // Vue.set(this.config.connections, connectionIndex, connection);
            // if we selected a group with just 1, we probably want to auto-generate its counterpart, so de-select any others we might have had before
            // However, only if it's the leftmost selector. Otherwise, it might be we're manually selecting e.g., a server trace from another file 
            if ( connectionIndex === 0 && connection.parent.getConnections().filter( (conn) => !conn.wasAutoGenerated ).length === 1 ){
                const connections = connection.parent.getConnections();
                this.config.connections = [ SequenceDiagramConfig.createConnectionWithTimeoffset( connections[0] ) ];
            }
            // if there are two connections, we expect there to be 1 client and 1 server perspective
            else if ( connection.parent.getConnections().filter( (conn) => !conn.wasAutoGenerated ).length === 2 ) {
                const firstConnection  = connection.parent.getConnections()[0];
                const secondConnection = connection.parent.getConnections()[1];

                const firstPerspective  = firstConnection.getVantagePointPerspective();
                const secondPerspective = secondConnection.getVantagePointPerspective();

                if ( firstPerspective === secondPerspective ){
                    // They are the same, so no client + server. This is typically in a file that uses group_id
                    // We just take the one that was selected
                    this.config.connections = [ SequenceDiagramConfig.createConnectionWithTimeoffset(connection) ];
                }
                else if ( firstPerspective === qlog.VantagePointType.client ){
                    this.config.connections = [ SequenceDiagramConfig.createConnectionWithTimeoffset(firstConnection), SequenceDiagramConfig.createConnectionWithTimeoffset(secondConnection)];
                }
                else if ( secondPerspective === qlog.VantagePointType.client ){
                    this.config.connections = [ SequenceDiagramConfig.createConnectionWithTimeoffset(secondConnection), SequenceDiagramConfig.createConnectionWithTimeoffset(firstConnection)];
                }
            }
            // if we've selected one, keep going until we find the next one of that vantagePoint
            // e.g., we would expect 1 trace to contain client, network, network, network, server, so if client is selected, get everything after that as well
            // however, we also have use cases where you have a large group of the same vantage points (e.g., all tests for a single quic-tracker run)
            // in that case, we do NOT want to select all traces of course
            else if ( connection.parent.getConnections().length > 2 ) {
                const renderables = [ SequenceDiagramConfig.createConnectionWithTimeoffset(connection) ];

                const connections = connection.parent.getConnections();
                const connectionIndexInParent = connections.indexOf(connection);
                const firstPerspective = connection.getVantagePointPerspective();

                for ( let i = connectionIndexInParent + 1; i < connections.length; ++i ){
                    const perspective = connections[i].getVantagePointPerspective();
                    // we skip autogenerated traces: they are/should be selected by the renderer if needed
                    if ( perspective !== firstPerspective && !connections[i].wasAutoGenerated ){
                        renderables.push( SequenceDiagramConfig.createConnectionWithTimeoffset(connections[i]) );
                    }
                    else {
                        break;
                    }
                }

                this.config.connections = renderables;
            }
            else if ( connectionIndex > 0 ){
                // situation: user has changed the right connection to the same vantage point as the left one
                // for example, select server trace left, auto-generates client and puts it on the left, puts server on the right
                // if user then, for some weird reason, selects the original client on the right instead of the server, we get generated left + original right, which is nonsense
                
                // so: we go over the connections. If they all have the same vantage point, we prefer the first non-autogenerated one
                let allTheSame = true;
                let previousVantagePoint = qlog.VantagePointType.unknown;
                let firstNonAutogenerated = undefined;
                for ( let i = 0; i < this.config.connections.length; ++i ){
                    let vantagePoint = qlog.VantagePointType.unknown;

                    if (i === connectionIndex) {
                        vantagePoint = connection.vantagePoint.type;
                        if ( !connection.wasAutoGenerated ){
                            firstNonAutogenerated = connection;
                        }
                    }
                    else {
                        vantagePoint = this.config.connections[i].connection.vantagePoint.type;
                        if ( !this.config.connections[i].connection.wasAutoGenerated ){
                            firstNonAutogenerated = this.config.connections[i].connection;
                        }
                    }

                    if ( i !== 0 && vantagePoint !== previousVantagePoint ){
                        // not all of the same type, user can solve the situation themself
                        Vue.set(this.config.connections, connectionIndex, SequenceDiagramConfig.createConnectionWithTimeoffset(connection));
                        allTheSame = false;
                        break;
                    }

                    previousVantagePoint = vantagePoint;
                }

                if ( allTheSame && previousVantagePoint === qlog.VantagePointType.network ) {
                    // special allowance for network traces
                    // e.g., for pcap2qlog, all traces will have vantagepoint network, with flow type client, because we don't know any better
                    // without this, we wouldn't be able to select a client and server-side pcap separately, as they have the same vantagepoint from pcap2qlog
                    allTheSame = false; // causes us to skip the code below, keeping the last selected trace as expected
                    Vue.set(this.config.connections, connectionIndex, SequenceDiagramConfig.createConnectionWithTimeoffset(connection)); // replace existing conn with the newly selected one
                    // NOTE: this probably messes with the logic in some situations, but can't really solve those properly either way
                }

                if ( allTheSame ){
                    if ( firstNonAutogenerated !== undefined ){
                        console.warn("SequenceDiagramConfigurator: all selected traces had the same vantagePoint, auto-selecting the first non-autogenerated trace");
                        this.config.connections = [ SequenceDiagramConfig.createConnectionWithTimeoffset(firstNonAutogenerated) ];
                    }
                    else {
                        console.error("SequenceDiagramConfigurator: all selected traces had the same vantagePoint and were also auto-generated. Trying to find a proper trace.");
                        let found = false;
                        for ( const conn of connection.parent.getConnections() ){
                            if ( !conn.wasAutoGenerated ){
                                this.config.connections = [ SequenceDiagramConfig.createConnectionWithTimeoffset(conn) ];
                                found = true;
                                break;
                            }
                        }

                        if ( !found ){
                            console.error("SequenceDiagramConfigurator: Proper trace not found, keeping last selected connection. THIS SHOULD NOT HAPPEN!");
                            this.config.connections = [ SequenceDiagramConfig.createConnectionWithTimeoffset(connection) ];
                        }
                    }
                }
            }

            // TODO: try to be clever with (group_id? and) ODCID across trace files
            // e.g., if you have 1 file with a bunch of client traces, go looking for another file with a server trace with the same ODCID

            else {
                // Vue reactivity cannot detect direct index-based changes to an array, i.e.,
                // this.config.connections[connectionIndex] = connection;
                // will not work. We need to use Vue.set (or .slice) to gain reactivity
                Vue.set(this.config.connections, connectionIndex, SequenceDiagramConfig.createConnectionWithTimeoffset(connection));
            }

            // just select all other connections after this one from the same parent if there are more than 1 in a group
            // else if ( connectionIndex === 0 && connection.parent.getConnections().length > 1 ){
            //     const connections = connection.parent.getConnections();
            //     const connectionIndexInParent = connections.indexOf(connection);
            //     let rendererIndex = 1;
            //     for ( let i = connectionIndexInParent + 1; i < connections.length; ++i ){
            //         // Vue.set works like .push when the index isn't yet in the array
            //         Vue.set( this.config.connections, rendererIndex, connections[i] );
            //         ++rendererIndex;
            //     }

            //     this.config.connections.splice(rendererIndex); // remove everything starting at this index
            // }
        }

        public mounted(){
            if ( this.config.connections.length === 0 && this.store.groups.length > 0 ){
                this.selectDefault();
            }
        }

        public updated(){
            if ( this.config.connections.length === 0 && this.store.groups.length > 0 ){
                this.selectDefault();
            }
        }

        protected selectDefault(){
            console.log("selectDefault: adding new default connection configurator", this.store.groups);
            this.config.connections.push( SequenceDiagramConfig.createConnectionWithTimeoffset(this.store.groups[0].getConnections()[0]) );
        }

        protected onConnectionRemoved(connectionIndex:number){
            this.config.connections.splice(connectionIndex, 1);
        }

        protected onTimeOffsetChange(connectionIndex:number, offset:number){
            this.config.connections[connectionIndex].timeOffset = offset;
        }
    }

</script>
