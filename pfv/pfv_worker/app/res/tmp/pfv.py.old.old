import logging
import subprocess
import sys
import time
import progressbar
import tracemalloc  
from plantuml import PlantUML
import configparser
import os

from pfv_utils.pfv_constant import *

from pfv_runner.pfv_quic_runner import Runner as QuicRunner
from pfv_runner.pfv_bgp_runner import Runner as BGPRunner
from pfv_runner.pfv_minip_runner import Runner as MiniPRunner

from logger.CustomFormatter import CustomFormatter

from argument_parser.ArgumentParserRunner import ArgumentParserRunner

DEBUG = True

class PFV:
    def __init__(self):    
        # Setup cargo
        subprocess.Popen("source $HOME/.cargo/env",shell=True, executable="/bin/bash").wait() # TODO source

        # Setup logger
        ch = logging.StreamHandler()
        ch.setLevel(logging.INFO)
        ch.setFormatter(CustomFormatter())
        self.log = logging.getLogger("pfv")
        self.log.setLevel(logging.INFO)
        self.log.addHandler(ch)
        self.log.propagate = False 
        
        # Setup argument parser
        self.args =  ArgumentParserRunner().parse_arguments()
        
        # Setup environment variables
        for env_var in ENV_VAR:
            os.environ[env_var] = ENV_VAR[env_var]
            self.log.info("ENV_VAR="+ env_var)
            self.log.info("ENV_VAL="+ ENV_VAR[env_var])
        
        self.ivy_include_path = SOURCE_DIR + "/QUIC-Ivy-Attacker/ivy/include/1.7/"
                
        # Setup configuration
        self.log.info("START SETUP CONFIGURATION")
        self.current_protocol = ""
        self.config = self.setup_config()
        self.log.info("SELECTED PROTOCOL: " + self.current_protocol)
        self.protocol_conf = self.setup_protocol_parameters(self.current_protocol,SOURCE_DIR)
        self.log.info("END SETUP PROTOCOL PARAMETERS")
        
        self.total_exp_in_dir = len(os.listdir(self.config["global_parameters"]["dir"])) - 2
        self.current_exp_path = self.config["global_parameters"]["dir"] + str(self.total_exp_in_dir)
                
        self.current_count = 0
        self.current_implem = None
        self.available_modes = []
        
        self.included_files = list()

        if self.config["debug_parameters"].getboolean("memprof"):
            self.memory_snapshots = []
            
        self.executed_tests = []
        self.count_1 = None

    def setup_config(self, init=True, protocol=None):
        config = configparser.ConfigParser(allow_no_value=True)
        if init:
            config.read('configs/default_config.ini')
        else:
            config.read('configs/config.ini')
        self.key_path = SOURCE_DIR + "/tls-keys/"
        self.implems = {}
        self.current_protocol =  ""
        self.supported_protocols = config["verified_protocol"].keys()
        if init:
            for p in config["verified_protocol"].keys():
                if config["verified_protocol"].getboolean(p):
                    self.current_protocol = p
                    break
        else:
            self.current_protocol = protocol
        return config
    
    def setup_protocol_parameters(self,protocol, dir_path, init=False):
        self.tests = {}
        self.implems = {}
        protocol_conf = configparser.ConfigParser(allow_no_value=True)
        for envar in P_ENV_VAR[protocol]:
            os.environ[envar] = P_ENV_VAR[protocol][envar]
            self.log.info("ENV_VAR="+ envar)
            self.log.info("ENV_VAL="+  P_ENV_VAR[protocol][envar])
            # os.environ['INITIAL_VERSION'] = str(self.args.initial_version)
            # ENV_VAR["INITIAL_VERSION"] = str(self.args.initial_version)

        protocol_conf.read('configs/'+protocol+'/'+protocol+'_config.ini')
        # TODO change var name at the end
        self.ivy_model_path = dir_path + "/QUIC-Ivy-Attacker/protocol-testing/" + protocol
        self.config.set('global_parameters', "tests_dir", dir_path + "/QUIC-Ivy-Attacker/protocol-testing/"+ protocol +"/"+protocol +"_tests/")
        self.config.set('global_parameters', "dir"      , dir_path + "/QUIC-Ivy-Attacker/protocol-testing/"+ protocol +"/test/temp/")
        self.config.set('global_parameters', "build_dir", dir_path + "/QUIC-Ivy-Attacker/protocol-testing/"+ protocol +"/build/")
        for cate in protocol_conf.keys():
            if "tests" in cate:
                self.tests[cate] = []
                for test in protocol_conf[cate].keys():
                    self.tests[cate].append(test)
        implem_config_path = 'configs/'+protocol+'/implem-server'
        for file_path in os.listdir(implem_config_path):
            # check if current file_path is a file
            if os.path.isfile(os.path.join(implem_config_path, file_path)):
                implem_name = file_path.replace(".ini","") 
                implem_conf = configparser.ConfigParser(allow_no_value=True)
                implem_conf.read(os.path.join(implem_config_path, file_path))
                self.implems[implem_name] = implem_conf
        return protocol_conf
    
    def update_ivy(self):
        # Note we use subprocess in order to get sudo rights
        os.chdir(SOURCE_DIR + "/QUIC-Ivy-Attacker/")
        os.system("sudo python2.7 setup.py install")
        os.system("sudo cp lib/libz3.so submodules/z3/build/python/z3")
        # TODO extract variable for path -> put in module path
        self.log.info("Update \"include\" path of python with updated version of the TLS project from \n\t"+self.ivy_include_path)
        files = [os.path.join(self.ivy_include_path, f) for f in os.listdir(self.ivy_include_path) if os.path.isfile(os.path.join(self.ivy_include_path, f)) and f.endswith(".ivy")]
        self.log.info("Copying file to /usr/local/lib/python2.7/dist-packages/ms_ivy-1.8.24-py2.7.egg/ivy/include/1.7/")
        for file in files:
            self.log.info(" " + file)
            subprocess.Popen("sudo /bin/cp "+ file +" /usr/local/lib/python2.7/dist-packages/ms_ivy-1.8.24-py2.7.egg/ivy/include/1.7/", 
                                                    shell=True, executable="/bin/bash").wait()
        
        os.chdir('/usr/local/lib/python2.7/dist-packages/ms_ivy-1.8.24-py2.7.egg/ivy/')
        subprocess.Popen("sudo /bin/cp -f -a " + SOURCE_DIR + "/QUIC-Ivy-Attacker/lib/*.a /usr/local/lib/python2.7/dist-packages/ms_ivy-1.8.24-py2.7.egg/ivy/lib", 
                                                    shell=True, executable="/bin/bash").wait()

        
        if self.config["verified_protocol"].getboolean("quic"):
            self.log.info("Copying QUIC libraries")
            subprocess.Popen("sudo /bin/cp -f -a " + SOURCE_DIR + "/quic-implementation/picotls/*.a /usr/local/lib/python2.7/dist-packages/ms_ivy-1.8.24-py2.7.egg/ivy/lib", 
                                                        shell=True, executable="/bin/bash").wait()
            subprocess.Popen("sudo /bin/cp -f -a " + SOURCE_DIR + "/quic-implementation/picotls/*.a " + SOURCE_DIR + "/QUIC-Ivy-Attacker/ivy/lib", 
                                                        shell=True, executable="/bin/bash").wait()                                          

            subprocess.Popen("sudo /bin/cp -f " + SOURCE_DIR + "/quic-implementation/picotls/include/picotls.h /usr/local/lib/python2.7/dist-packages/ms_ivy-1.8.24-py2.7.egg/ivy/include", 
                                                        shell=True, executable="/bin/bash").wait()
            subprocess.Popen("sudo /bin/cp -f " + SOURCE_DIR + "/quic-implementation/picotls/include/picotls.h " + SOURCE_DIR + "/QUIC-Ivy-Attacker/ivy/include", 
                                                        shell=True, executable="/bin/bash").wait()
            subprocess.Popen("sudo /bin/cp -r -f " + SOURCE_DIR + "/quic-implementation/picotls/include/picotls/. /usr/local/lib/python2.7/dist-packages/ms_ivy-1.8.24-py2.7.egg/ivy/include/picotls", 
                                                        shell=True, executable="/bin/bash").wait()
    
        os.chdir(SOURCE_DIR)

    def setup_ivy_model(self):
        self.log.info("Update \"include\" path of python with updated version of the project from \n\t"+self.ivy_model_path)
        subfolder = [os.path.join(self.ivy_model_path, f) for f in os.listdir(self.ivy_model_path) if os.path.isdir(os.path.join(self.ivy_model_path, f))]
        for folder in subfolder:
            files = [os.path.join(folder, f) for f in os.listdir(folder) if os.path.isfile(os.path.join(folder, f)) and f.endswith(".ivy") and not "test" in f] # TODO find more elegant way to avoid copy test files
            for file in files:
                self.log.info(" " + file)
                self.included_files.append(file)
                subprocess.Popen("sudo /bin/cp "+ file +" /usr/local/lib/python2.7/dist-packages/ms_ivy-1.8.24-py2.7.egg/ivy/include/1.7/", 
                                                    shell=True, executable="/bin/bash").wait()
        if self.config["verified_protocol"].getboolean("quic"):
            subprocess.Popen("sudo /bin/cp "+ self.ivy_model_path + "/quic_utils/quic_ser_deser.h" +" /usr/local/lib/python2.7/dist-packages/ms_ivy-1.8.24-py2.7.egg/ivy/include/1.7/", 
                                                        shell=True, executable="/bin/bash").wait()
        
    def remove_includes(self):
        self.log.info("Reset \"include\" path of python")
        for file in self.included_files:
            self.log.info(" " + file)
            nameFileShort = file.split("/")[-1]
            subprocess.Popen("sudo /bin/rm /usr/local/lib/python2.7/dist-packages/ms_ivy-1.8.24-py2.7.egg/ivy/include/1.7/" + nameFileShort, 
                                                    shell=True, executable="/bin/bash").wait()
        self.included_files = list()   

    def build_tests(self,test_to_do=[]):
        self.log.info(" " + str(len(test_to_do)))
        self.log.info(test_to_do)
        self.available_modes = [cate.replace("_test","") for cate in self.tests.keys()]
        self.log.info(self.available_modes)
        for mode in self.available_modes:
            for file in test_to_do:
                if mode in file: # TODO more beautiful
                    os.chdir(self.config["global_parameters"]["tests_dir"])
                    file = os.path.join(self.config["global_parameters"]["tests_dir"], file) + ".ivy"
                    self.log.info(" " + file)
                    nameFileShort = file.split("/")[-1]
                    self.executed_tests.append(nameFileShort.replace(".ivy",""))
                    self.build_file(nameFileShort)

    def build_file(self,file):
        self.compile_file(file)
        if self.config["verified_protocol"].getboolean("quic"):
            if "quic_server_test_0rtt" in file:
                file = file.replace("quic_server_test_0rtt","quic_server_test_0rtt_stream")
                self.compile_file(file)
                file = file.replace("quic_server_test_0rtt_stream","quic_server_test_0rtt_stream_co_close")
                self.compile_file(file)
                file = file.replace("quic_server_test_0rtt_stream_co_close","quic_server_test_0rtt_stream_app_close")
                self.compile_file(file)
            elif "quic_client_test_0rtt_invalid" in file:
                file = file.replace("quic_client_test_0rtt_invalid","quic_client_test_0rtt_max")
                self.compile_file(file)
            elif "quic_client_test_0rtt_add_val" in file:
                file = file.replace("quic_client_test_0rtt_add_val","quic_client_test_0rtt_max_add_val")
                self.compile_file(file)
            elif "quic_client_test_0rtt_mim_replay" in file:
                file = file.replace("quic_client_test_0rtt_mim_replay","quic_client_test_0rtt_max")
                self.compile_file(file)
            elif "quic_client_test_0rtt" in file:
                file = file.replace("quic_client_test_0rtt","quic_client_test_0rtt_max")
                self.compile_file(file)
                file = file.replace("quic_client_test_0rtt_max","quic_client_test_0rtt_max_co_close")
                self.compile_file(file)
                file = file.replace("quic_client_test_0rtt_max_co_close","quic_client_test_0rtt_max_app_close")
                self.compile_file(file)
            elif "quic_server_test_retry_reuse_key" in file:
                file = file.replace("quic_server_test_retry_reuse_key","quic_server_test_retry")
                self.compile_file(file)

    def compile_file(self,file):
        if self.config["global_parameters"].getboolean("compile"):
            self.log.info("Building/Compiling file:")
            child= subprocess.Popen("ivyc trace=false show_compiled=false target=test test_iters="+ str(self.config["global_parameters"]["internal_iteration"]) + "  " + file, 
                                                    shell=True, executable="/bin/bash").wait()
            rc = child
            self.log.info(rc)
            if rc != 0:
                exit(1)
            
            self.log.info("Moving built file in correct folder:")
            subprocess.Popen("/usr/bin/chmod +x "+ file.replace('.ivy',''), 
                                                    shell=True, executable="/bin/bash").wait()
            subprocess.Popen("/bin/cp "+ file.replace('.ivy','')  + " "+ self.config["global_parameters"]["build_dir"], 
                                                    shell=True, executable="/bin/bash").wait()
            subprocess.Popen("/bin/cp "+ file.replace('.ivy','.cpp')  + " "+ self.config["global_parameters"]["build_dir"], 
                                                    shell=True, executable="/bin/bash").wait()
            subprocess.Popen("/bin/cp "+ file.replace('.ivy','.h')  + " "+ self.config["global_parameters"]["build_dir"], 
                                                    shell=True, executable="/bin/bash").wait()
            subprocess.Popen("/bin/rm "+ file.replace('.ivy',''), 
                                                    shell=True, executable="/bin/bash").wait()
            subprocess.Popen("/bin/rm "+ file.replace('.ivy','.cpp'), 
                                                    shell=True, executable="/bin/bash").wait()
            subprocess.Popen("/bin/rm "+ file.replace('.ivy','.h'), 
                                                    shell=True, executable="/bin/bash").wait()

    def launch_experiments(self, implementation=None):        
        if self.config["debug_parameters"].getboolean("memprof"):
            tracemalloc.start()
            
        if self.config["global_parameters"].getboolean("update_ivy"):
            self.update_ivy()
        self.setup_ivy_model()
        
        
        # TODO customize for multiple protocol
        # TODO more modulable
        # Set protocol-specific env var
        if self.config["verified_protocol"].getboolean("quic"):
            os.environ['INITIAL_VERSION'] = str(self.args.initial_version)
            ENV_VAR["INITIAL_VERSION"] = str(self.args.initial_version)
        elif self.config["verified_protocol"].getboolean("minip"):
            pass
        elif self.config["verified_protocol"].getboolean("bgp"):
            pass
        else:
            pass
        
        # Set environement-specific env var
        if not self.config["global_parameters"].getboolean("docker"):
            os.environ['IS_NOT_DOCKER'] = "true" 
            ENV_VAR["IS_NOT_DOCKER"]    = "true"
        else:
            if 'IS_NOT_DOCKER' in os.environ:
                del os.environ['IS_NOT_DOCKER']
            if 'IS_NOT_DOCKER' in ENV_VAR:
                del ENV_VAR['IS_NOT_DOCKER']
        
        # Set network-specific env var
        if not self.config["net_parameters"].getboolean("shadow"):
            os.environ['IS_NOT_SHADOW'] = "true" 
            ENV_VAR["IS_NOT_SHADOW"]    = "true"
        else:
            if 'IS_NOT_SHADOW' in os.environ:
                del os.environ['IS_NOT_SHADOW']
            if 'IS_NOT_SHADOW' in ENV_VAR:
                del ENV_VAR['IS_NOT_SHADOW']
        
        ENV_VAR["LOSS"]    = float(self.config["shadow_parameters"]["loss"])
        ENV_VAR["LATENCY"] = float(self.config["shadow_parameters"]["latency"])
        ENV_VAR["JITTER"]  = float(self.config["shadow_parameters"]["jitter"])
        
        if DEBUG:
            self.log.info(ENV_VAR["LOSS"])
            self.log.info(ENV_VAR["LATENCY"])
            self.log.info(ENV_VAR["JITTER"])
            self.log.info('IS_NOT_SHADOW' in os.environ)
            self.log.info('IS_NOT_SHADOW' in ENV_VAR)
        
                
        subprocess.Popen("sudo sysctl -w net.core.rmem_max=2500000", 
                            shell=True, executable="/bin/bash").wait() # for quic-go
        # TODO move that to tests execution and check
        # if self.config["net_parameters"].getboolean("vnet"):
        #     if self.args.mode == "mim" or self.args.categories == "attacks_test":
        #         subprocess.Popen("bash "+ SOURCE_DIR + "/vnet_setup_mim.sh", 
        #                                                 shell=True, executable="/bin/bash").wait()
        #     else:
        #         subprocess.Popen("bash "+ SOURCE_DIR + "/vnet_setup.sh", 
        #                                                 shell=True, executable="/bin/bash").wait() 
        # else:
        #     subprocess.Popen("bash "+ SOURCE_DIR + "/vnet_reset.sh", 
        #                                             shell=True, executable="/bin/bash").wait()
        test_to_do = []
        for category in self.tests:
            test_to_do.extend(self.tests[category])
            
        self.build_tests(test_to_do=test_to_do)

        if implementation == None or implementation == []:
            self.log.error("TODO implement in local mode, for now only with docker (ERROR)")
            sys.exit(0)
            # TODO implement in local mode, for now only with docker

        # TODO CHECK if implementation exist
        # if self.implementation not in IMPLEMENTATIONS:
        #     sys.stderr.write('unknown implementation: {}\n'.format(self.implementation))
        #     exit(1)

        if self.config["verified_protocol"].getboolean("quic"):
            runner = QuicRunner()
        elif self.config["verified_protocol"].getboolean("minip"):
            runner = MiniPRunner()
        elif self.config["verified_protocol"].getboolean("bgp"):
            runner = BGPRunner()
        else:
            self.log.error("No protocols selected")
            exit(0)
        


        # TODO make less general 
        if  "quic_server_test_0rtt" in self.executed_tests or  "quic_client_test_0rtt" in self.executed_tests:
            bar_f = progressbar.ProgressBar(max_value=(len(self.executed_tests)+2)*len(implementation)*self.config["global_parameters"].getint("iter"))
        else:
            bar_f = progressbar.ProgressBar(max_value=len(self.executed_tests)*len(implementation)*self.config["global_parameters"].getint("iter"))
        bar_f.start()
        self.count_1 = 0
        
        # TODO add protocol specific behavior module
        # subprocess.Popen("echo '' >> "+ SOURCE_DIR +"/tickets/ticket.bin", 
        #                 shell=True, executable="/bin/bash").wait()
        
        for test in self.executed_tests:
            initial_test = test
            ni = 1
            if self.config["verified_protocol"].getboolean("quic"):
                if test == "quic_client_test_0rtt_mim_replay":
                    os.environ['ZERORTT_TEST']="true" 
                    ENV_VAR["ZERORTT_TEST"]="true"
                elif test == "quic_server_test_0rtt" or test == "quic_client_test_0rtt":
                    os.environ['ZERORTT_TEST']="true" 
                    ENV_VAR["ZERORTT_TEST"]="true"
                    ni = 3
                else:
                    if 'ZERORTT_TEST' in os.environ:
                        del os.environ['ZERORTT_TEST']
                    if 'ZERORTT_TEST' in ENV_VAR:
                        del ENV_VAR["ZERORTT_TEST"]
                if test == "quic_server_test_retry_reuse_key": # TODO
                    runner.nclient = 2
                else:
                    runner.nclient = self.args.nclient
            
            # if "quic_client_test_version_negociation_mim" in test:
            #     subprocess.Popen("bash "+ SOURCE_DIR + "/mim-setup.sh", 
            #                                         shell=True, executable="/bin/bash").wait()
            # else:
            #     subprocess.Popen("bash "+ SOURCE_DIR + "/mim-reset.sh", 
            #                                         shell=True, executable="/bin/bash").wait()

            #if test == "quic_client_test_version_negociation_mim":
            #    subprocess.Popen("/bin/bash "+ SOURCE_DIR + "/mim-setup.sh", 
            #                                        shell=True, executable="/bin/bash").wait()
            #else:
            #    subprocess.Popen("/bin/bash "+ SOURCE_DIR + "/mim-reset.sh", 
            #                                        shell=True, executable="/bin/bash").wait()
            
            for j in range(0,ni):
                for implementation in implementation:  
                    self.log.info(implementation)
                    os.environ['TEST_IMPL'] = implementation
                    ENV_VAR["TEST_IMPL"]    = implementation
                    if self.config["verified_protocol"].getboolean("quic"):
                        os.environ['TEST_ALPN'] = self.args.alpn if implementation != "mvfst" else "hq"
                        ENV_VAR["TEST_ALPN"] = self.args.alpn if implementation != "mvfst" else "hq"
                        os.environ['SSLKEYLOGFILE'] = SOURCE_DIR +"/tls-keys/"+implementation+"_key.log"
                        ENV_VAR["SSLKEYLOGFILE"] = SOURCE_DIR +"/tls-keys/"+implementation+"_key.log"
                    for i in range(0,self.config["global_parameters"].getint("iter")):
                        if self.config["verified_protocol"].getboolean("quic"):
                            if j == 1: # TODO wtf
                                test = initial_test + "_app_close"
                            elif j == 2:
                                test = initial_test + "_co_close"
                        self.log.info("Test: "+test)
                        self.log.info("Implementation: "+implementation)
                        self.log.info("Iteration: "+str(i+1) +"/" + str(self.config["global_parameters"].getint("iter")))
                        os.environ['CNT'] = str(self.count_1)
                        ENV_VAR["CNT"] = str(self.count_1)
                        #os.environ['RND'] = os.getenv("RANDOM")
                        subprocess.Popen("> "+ SOURCE_DIR +"/tickets/ticket.bin", 
                                                    shell=True, executable="/bin/bash").wait()
                        folders = [os.path.join(self.config["global_parameters"]["dir"], f) for f in os.listdir(self.config["global_parameters"]["dir"]) if os.path.isdir(os.path.join(self.config["global_parameters"]["dir"], f))]
                        #self.log.info(folders)
                        pcap_i = len(folders)
                        self.log.info(pcap_i)
                        ivy_dir = self.config["global_parameters"]["dir"]+str(pcap_i)
                        subprocess.Popen("/bin/mkdir " + ivy_dir, 
                                                    shell=True, executable="/bin/bash").wait()
                        if self.config["net_parameters"].getboolean("vnet"):
                            pcap_name = ivy_dir +"/ivy_lo_"+ implementation +"_"+ test +".pcap"
                            subprocess.Popen("touch "+pcap_name, 
                                                        shell=True, executable="/bin/bash").wait()
                            subprocess.Popen("sudo /bin/chmod o=xw "+ pcap_name, 
                                                        shell=True, executable="/bin/bash").wait()
                            subprocess.Popen("touch "+pcap_name.replace("ivy_lo_","ivy_ivy_"), 
                                                        shell=True, executable="/bin/bash").wait()
                            subprocess.Popen("sudo /bin/chmod o=xw "+ pcap_name.replace("ivy_lo_","ivy_ivy_"), 
                                                        shell=True, executable="/bin/bash").wait()
                            subprocess.Popen("touch "+pcap_name.replace("ivy_lo_","implem_"), 
                                                        shell=True, executable="/bin/bash").wait()
                            subprocess.Popen("sudo /bin/chmod o=xw "+ pcap_name.replace("ivy_lo_","implem_"), 
                                                        shell=True, executable="/bin/bash").wait()
                        else:
                            pcap_name = ivy_dir +"/"+ implementation +"_"+ test +".pcap"
                            subprocess.Popen("touch "+pcap_name, 
                                                        shell=True, executable="/bin/bash").wait()
                            subprocess.Popen("sudo /bin/chmod o=xw "+ pcap_name, 
                                                        shell=True, executable="/bin/bash").wait()
                        self.log.info("\tStart thsark")
                        #time.sleep(10) # for server test 
                        # TODO kill entual old quic implem

                        if self.config["net_parameters"].getboolean("vnet"):
                            interface = "lo"
                            p = subprocess.Popen(["ip", "netns", "exec", "ivy", "tshark", "-w",
                                                pcap_name,
                                                "-i", interface, "-f", 'udp'],
                                                stdout=sys.stdout)
                            interface = "ivy"
                            p = subprocess.Popen(["ip", "netns", "exec", "ivy", "tshark", "-w",
                                                    pcap_name.replace("ivy_lo_","ivy_ivy_"),
                                                    "-i", interface, "-f", 'udp'],
                                                    stdout=sys.stdout)
                            interface = "implem"
                            p = subprocess.Popen(["ip", "netns", "exec", "implem", "tshark", "-w",
                                                pcap_name.replace("ivy_lo_","implem_"),
                                                "-i", interface, "-f", 'udp'],
                                                stdout=sys.stdout)
                        elif self.config["net_parameters"].getboolean("localhost"):
                            interface = "lo"
                            p = subprocess.Popen(["sudo", "tshark", "-w",
                                                pcap_name,
                                                "-i", interface, "-f", 'udp'],
                                                stdout=sys.stdout)
                        time.sleep(3) # TODO
                        runner.implementation = implementation
                        
                        ivy_out = ivy_dir + '/ivy_stdout.txt'
                        ivy_err = ivy_dir + '/ivy_stderr.txt'
                        sys.stdout = open(ivy_out, 'w')
                        sys.stderr = open(ivy_err, 'w')
                        self.log.info("\tStart run")
                        try:
                            runner.output_path = None
                            for mode in self.available_modes:
                                if mode in initial_test:
                                    os.environ['TEST_TYPE']= mode
                                    ENV_VAR["TEST_TYPE"]   = mode
                            runner.run_exp(initial_test,pcap_i,pcap_name,i,j)
                            
                        except Exception as e:
                            self.log.info(e)
                        finally: # In Runner.py
                            sys.stdout.close()
                            sys.stderr.close()
                            sys.stdout = sys.__stdout__
                            sys.stderr = sys.__stderr__
                            subprocess.Popen("/usr/bin/tail -2 " + ivy_err, 
                                                    shell=True, executable="/bin/bash").wait()
                            subprocess.Popen("/usr/bin/tail -2 " + ivy_out, 
                                                    shell=True, executable="/bin/bash").wait()
                            #subprocess.Popen("/usr/bin/tail $(/usr/bin/lsof -i udp) >/dev/null 2>&1", # deadlock in docker todo
                            #                        shell=True, executable="/bin/bash").wait()
                            self.log.info("\tKill thsark")
                            subprocess.Popen("sudo /usr/bin/pkill tshark", 
                                                    shell=True, executable="/bin/bash").wait()
                            #p.kill()
                            self.count_1 += 1
                            bar_f.update(self.count_1)
                            subprocess.Popen("bash "+ SOURCE_DIR + "/mim-reset.sh", 
                                                    shell=True, executable="/bin/bash").wait()
                            current_protocol = "quic" # TODO 
                            with open('configs/'+current_protocol+'/'+current_protocol+'_config.ini', 'w') as configfile:
                                with open('configs/'+current_protocol+'/default_'+current_protocol+'_config.ini', "r") as default_config:
                                    default_settings = default_config.read()
                                    configfile.write(default_settings)
        if self.config["net_parameters"].getboolean("vnet"):
            subprocess.Popen("bash "+ SOURCE_DIR + "/vnet_reset.sh", 
                            shell=True, executable="/bin/bash").wait()
        bar_f.finish()
        self.count_1 = None
        # self.remove_includes()
        TESTS_CUSTOM = []
        # subprocess.Popen("sudo /bin/cp -r "+ SOURCE_DIR +"/tls-keys/ " + self.config["global_parameters"]["dir"], 
        #                     shell=True, executable="/bin/bash").wait()
        # subprocess.Popen("sudo /bin/cp -r "+ SOURCE_DIR +"/tickets/ " + self.config["global_parameters"]["dir"], 
        #                     shell=True, executable="/bin/bash").wait()
        # subprocess.Popen("sudo /bin/cp -r "+ SOURCE_DIR +"/qlogs/ " + self.config["global_parameters"]["dir"], 
        #                     shell=True, executable="/bin/bash").wait()
        if self.config["debug_parameters"].getboolean("memprof"):
            snapshot = tracemalloc.take_snapshot()
            top_stats = snapshot.statistics('lineno')
            self.log.info("[ Top 50 ]")
            for stat in top_stats[:50]:
                self.log.info(stat)
                
        try:
            plantuml_file = "/ivy_trace.txt"
            plantuml_obj = PlantUML(url="http://www.plantuml.com/plantuml/img/",  basic_auth={}, form_auth={}, http_opts={}, request_opts={})

            plantuml_file_png = plantuml_file.replace('.puml', '.png') #"media/" + str(nb_exp) + "_plantuml.png"
            plantuml_obj.processes_file(plantuml_file,  plantuml_file_png)
            self.log.info("done")
        except Exception as e:
            self.log.info(e)
            pass
                
        # time.sleep(100)


def main():
    experiments = PFV()
    if experiments.args.webapp:
        from webapp.pfv_server import PFVServer
        app = PFVServer(SOURCE_DIR)
        app.run()
        sys.exit(app.exec_())
    elif experiments.args.worker:
        from webapp.pfv_client import PFVClient
        app = PFVClient(SOURCE_DIR)
        app.run()
        sys.exit(app.exec_())
    else:
        experiments.launch_experiments()

if __name__ == "__main__":    
    try:
        main()
    except Exception as e:
        print(e)
    finally:
        sys.stdout.close()
        sys.stderr.close() 
        sys.stdout = sys.__stdout__
        sys.stderr = sys.__stderr__       
        subprocess.Popen("kill $(lsof -i udp) >/dev/null 2>&1") 
        subprocess.Popen("sudo pkill tshark")
        subprocess.Popen("bash "+ SOURCE_DIR + "/vnet_reset.sh", 
                        shell=True, executable="/bin/bash").wait()
        subprocess.Popen("/bin/kill $(/usr/bin/lsof -i udp) >/dev/null 2>&1") 
        subprocess.Popen("sudo /usr/bin/pkill tshark")


