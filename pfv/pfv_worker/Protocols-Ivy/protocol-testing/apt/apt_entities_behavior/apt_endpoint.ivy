#lang ivy1.7

object endpoint_id = {
    type this = {
        client, client_alt, server,

        # QUIC specific
        client_vn,

        target, target_alt, malicious_client, malicious_server, man_in_the_middle, c2_server, bot}
}

# We use this type as a host id. There are two client host ids so we can model migration.


action endpoint_id_addr(ep_id : endpoint_id) returns (ep:ip.endpoint) = {
    ep.protocol := ip.udp; # TODO 

    ep.addr := target_addr if ep_id = endpoint_id.target | ep_id = endpoint_id.target_alt  
                else (client_addr if ep_id = endpoint_id.client
                else (server_addr if ep_id = endpoint_id.server
                else (client_vn_addr if ep_id = endpoint_id.client_vn
                else (mim_addr if ep_id = endpoint_id.man_in_the_middle
                else (malicious_client_addr if ep_id = endpoint_id.malicious_client
                else (malicious_server_addr if ep_id = endpoint_id.malicious_server
                else (c2_server_addr if ep_id = endpoint_id.c2_server
                else (bot_addr))))))));

    ep.port := target_port if ep_id = endpoint_id.target
                else (target_alt_port if ep_id = endpoint_id.target_alt
                else (client_port if ep_id = endpoint_id.client
                else (server_port if ep_id = endpoint_id.server
                else (client_vn_port if ep_id = endpoint_id.client_vn
                else (mim_port_in if ep_id = endpoint.man_in_the_middle
                else (malicious_client_port if ep_id = endpoint_id.malicious_client
                else (malicious_server_port if ep_id = endpoint_id.malicious_server
                else (c2_server_port if ep_id = endpoint_id.c2_server
                else (bot_port))))))));

}

object endpoint = {
    type this

    module mim_ep(address:ip.addr,port:ip.port, oport:ip.port) = { 
        variant this of endpoint = struct { }
        
        individual ep_in        : ip.endpoint
        individual ep_out       : ip.endpoint
        individual tls_id    : tls_api.id
        individual enc_level : quic_packet_type
        individual nat_configured : bool
        individual ppkt_saved_b : bool
        individual ppkt_saved : stream_data
        
        individual ppkt_to_be_replayed_to_server : forged_pkts
        function   ppkt_to_be_forwarded_to_server(C:stream_pos) : forged_pkts
        individual cppkt_forwarded_to_server : stream_pos
        individual last_cppkt_forwarded_to_server : stream_pos

        individual force_client_forward : bool  # useless for now
        function   ppkt_to_be_forwarded_to_client(C:stream_pos) : forged_pkts
        individual cppkt_forwarded_to_client : stream_pos
        individual last_cppkt_forwarded_to_client : stream_pos

        individual force_server_forward : bool
        
        individual forward_turn : bool
        individual forward_turn_count : stream_pos
        
        individual ppkt_to_be_reflected_to_target : forged_pkts
    
        individual ppkt_to_be_forge : stream_data
        individual ppkt_to_be_forge_parsed : forged_protected_quic_packet
        individual enc_level_ppkt_to_be_forge : quic_packet_type

        individual init_cids : bool # TODO remove

        individual wait_forward : bool # TODO remove

        function   max_retransmit(E:quic_packet_type,S:ip.endpoint) : stream_pos


        after init {
            enc_level := quic_packet_type.initial;
            ep_in.protocol := ip.udp;
            ep_in.addr := address;
            ep_in.port := port;
            ep_in.interface := ip.lo;
            
            ep_out.protocol := ip.udp;
            ep_out.addr := address;
            ep_out.port := oport;
            if ep_out.addr = 0x7f000001 {
                ep_out.interface := ip.lo;
            } else {
                ep_out.interface := ip.ivy;
            }
            
            nat_configured := false;
            ppkt_saved_b := false;
            init_cids := false;

            force_client_forward := false;
            force_server_forward := false;

            max_retransmit(E,S) := 0;

            # ppkt_to_be_forwarded_to_server(C) := forged_pkts.empty;
            # ppkt_to_be_forwarded_to_client(C) := forged_pkts.empty;
            # Allow to keep coalesced packed
            cppkt_forwarded_to_server := 0;
            cppkt_forwarded_to_client := 0;
            last_cppkt_forwarded_to_server := 0;
            last_cppkt_forwarded_to_client := 0;

            forward_turn := false;
            forward_turn_count := 0;
            
            wait_forward := true;
            
            ppkt_to_be_forge := stream_data.empty;
            enc_level_ppkt_to_be_forge := quic_packet_type.initial;
        }
        
        action set_ep(e:ip.endpoint) = {
            ep_in := e; # TODO
        }

        action set_tls_id(e:tls_api.id) = {
            tls_id := e;
        }

        action behavior(host:endpoint_id, s:net.socket, src:ip.endpoint, pkts:prot.arr) = {
            var dst := socket_endpoint_mim(host,s,src);  # because net API doesn't tell us the dst socket_endpoint_mim
            var idx := pkts.begin;
            # TODO should not be here

            if ~nat_configured {
                #call configure_NAT_attack_out_trick(src);
                #call configure_NAT_attack_out_localhost(src.port);
                nat_configured := true;
                mim_client_target.set_ep(src); # Like initial connection from client 
                mim_server_target.set_ep(dst);
                #mim_server_target.ep.interface := ip.ivy;
                if sock_mim_client = 0 {
                    fake_client.set_ep(mim_client_target.ep);
                    fake_client.ep.interface := ip.lo;
                    # TODO only for server tests
                    sock_mim_client := net.listen(endpoint_id.mim,fake_client.ep);
                }; 
            } 

            #require ppkt_to_be_forwarded_to_server.end = 0;
            #require ppkt_to_be_forwarded_to_client.end = 0;

            while idx < pkts.end {
                var ppkt := pkts.value(idx);
                var tls_id := src_tls_id(dst); # todo multiple
                var header := ppkt.value(0);
                var hdr_type : type_bits := bfe[0][6](ppkt.value(0));
                var tt := bvand(hdr_type,0x30);
                var is_long : bool := bvand(0x80,header) ~= 0;
                
                var version := ppkt.segment(1,1+4);
                var bversion := bytes_to_version(version);
                
                var ptype : byte := bvand(0x30,header);

                call recv_packet_mim(host,src,dst,ppkt);

                # Either we modify initial packet version and provoc VN
                # Either we manually forge version negociation packet
                var rppkt := ppkt;


                # if modify_packets {
                #     rppkt := modify_packet(ppkt); 
                # };

                if forward_packets { # To server
                    # call forward_packet_to(rppkt,host,s,src,dst);
                    # call forward_packet_to_client_event(src,dst,rppkt);       # also an inferred event
                    if src = mim_client_target.ep {
                        # We do that to avoid forwarding all request from very fast client 
                        var pkt_type : quic_packet_type := quic_packet_type.initial;
                        if is_long {
                            if bvand(ppkt.value(0),0xf0) = 0xc0 {
                                pkt_type := quic_packet_type.initial;
                                #max_retransmit(pkt_type,src) := max_retransmit(pkt_type,src) + 1;
                            } else if (bversion = 0) | version_not_found(src) { 
                                pkt_type := quic_packet_type.version_negociation;
                            } else if tt = 0x30 & ~(bversion = 0)  {
                                pkt_type := quic_packet_type.retry;
                                # wait_forward := false;
                            } else if tt = 0x10  & ~(bversion = 0) {
                                pkt_type := quic_packet_type.zero_rtt;
                                # wait_forward := false;
                            } else {
                                pkt_type := quic_packet_type.handshake;
                                # wait_forward := false;
                                #max_retransmit(pkt_type,src) := max_retransmit(pkt_type,src) + 1;
                            } 
                        } else {
                            pkt_type := quic_packet_type.one_rtt;
                            # wait_forward := false;
                        }
                        
                        if (pkt_type = enc_level_ppkt_to_be_forge | pkt_type = quic_packet_type.initial) & save_packet { #  & ~ppkt_saved_b
                            call save_packets(ppkt); # For replayed pre_shared_key
                            ppkt_to_be_replayed_to_server := ppkt_to_be_replayed_to_server.append(ppkt); # For replayed 0rtt packet directly e.g
                            ppkt_saved_b := true;
                        };

                        # if pkt_type = enc_level_ppkt_to_be_forge & is_long {
                        #     ppkt_to_be_forge := rppkt;
                        #     ppkt_to_be_forge_parsed := forged_protected_pkt_serdes.from_bytes(ppkt_to_be_forge);
                        #     call recv_protected_packet_mim(host,src,dst,ppkt_to_be_forge_parsed);
                        # }
                        #max_retransmit(pkt_type,src) := max_retransmit(pkt_type,src) + 1;
                        #if max_retransmit(pkt_type,src) <= 2 {
                        ppkt_to_be_forwarded_to_server(cppkt_forwarded_to_server) := ppkt_to_be_forwarded_to_server(cppkt_forwarded_to_server).append(rppkt);
                        # force_client_forward := true;
                        # } else {
                        #     ppkt_to_be_forwarded_to_server := forged_pkts.empty;
                        #     force_client_forward := false;
                        # }
                    } else if src = mim_server_target.ep {
                        var pkt_type : quic_packet_type := quic_packet_type.initial;
                        if is_long {
                            if bvand(ppkt.value(0),0xf0) = 0xc0 {
                                pkt_type := quic_packet_type.initial;
                                #max_retransmit(pkt_type,src) := max_retransmit(pkt_type,src) + 1;
                            } else if (bversion = 0) | version_not_found(src) { 
                                pkt_type := quic_packet_type.version_negociation;
                            } else if tt = 0x30 & ~(bversion = 0)  {
                                pkt_type := quic_packet_type.retry;
                                wait_forward := false;
                            } else if tt = 0x10  & ~(bversion = 0) {
                                pkt_type := quic_packet_type.zero_rtt;
                                wait_forward := false;
                            } else {
                                pkt_type := quic_packet_type.handshake;
                                wait_forward := false;
                                #max_retransmit(pkt_type,src) := max_retransmit(pkt_type,src) + 1;
                            } 
                        } else {
                            pkt_type := quic_packet_type.one_rtt;
                            wait_forward := false;
                        }
                        ppkt_to_be_forwarded_to_client(cppkt_forwarded_to_client) := ppkt_to_be_forwarded_to_client(cppkt_forwarded_to_client).append(rppkt);
                        # force_server_forward := true;
                    }
                };
                
                if forward_packets_target {
                    var ddst := target_agent.ep;
                    #call forward_packet_to(rppkt,host,s,src,ddst);
                    ppkt_to_be_reflected_to_target := ppkt_to_be_reflected_to_target.append(rppkt);
                    call reflection_packets(rppkt,0);
                };

                if replay_packets { # To server
                    call forward_packet_to(ppkt_saved,host,s,src,dst);
                };

                # TODO add specific mim action/relation for more clarety
                # negocation_of_version(src) := true;

                if ~init_cids { # Needed for generation of forged VN packets
                    var dcil : stream_pos := bfe[0][7](ppkt.value(5));
                    var ikm := cid_to_bytes(0,1); # dcid
                    if(~dcil = 0) {
                        client_initial_dcil := dcil;
                        ikm := ppkt.segment(6,6+dcil); # dcid
                    };
                    var scil : stream_pos := bfe[0][7](ppkt.value(6+dcil));
                    var skm := cid_to_bytes(0,1); # scid
                    if(~scil = 0) {
                        client_initial_scil := scil;
                        client_non_zero_scil := true;	
                        skm := ppkt.segment(6+dcil+1,6+dcil+1+scil); # scid
                    };
                    client_initial_dcid := bytes_to_cid(ikm);
                    client_initial_scid := bytes_to_cid(skm); # skm
                    call export_length_cid_mim(dcil,scil);
                    init_cids := true;
                };
                
                idx := idx.next; 
            };

            if forward_packets & keep_coalesed { # To server
                # call forward_packet_to(rppkt,host,s,src,dst);
                # call forward_packet_to_client_event(src,dst,rppkt);       # also an inferred event
                if src = mim_client_target.ep {
                    # ppkt_to_be_forwarded_to_server := pkts;
                    cppkt_forwarded_to_server := cppkt_forwarded_to_server + 1;
                } else if src = mim_server_target.ep {
                    # ppkt_to_be_forwarded_to_client := pkts;
                    cppkt_forwarded_to_client := cppkt_forwarded_to_client + 1;
                };
            };

            #forward_turn := true;
        }

        action forward_packet_to(ppkt:stream_data,host:endpoint_id, s:net.socket, src:ip.endpoint, dst:ip.endpoint) = {
            # forward packet
            var pkts_mim := prot.arr.empty;
            pkts_mim := pkts_mim.append(ppkt);
            call net.send(endpoint_id.mim,endpoint_to_socket(src),dst,pkts_mim);
        }

        action replay_packet(ppkt:stream_data,host:endpoint_id, s:net.socket, src:ip.endpoint) = {
            # replay packet
            var dst := socket_endpoint(host,s);
            var pkts_mim := prot.arr.empty;
            pkts_mim := pkts_mim.append(ppkt);
            call net.send(endpoint_id.mim,endpoint_to_socket(src),dst,pkts_mim);
        }

        # TODO use serializer
        action modify_packet(ppkt:stream_data) returns(rppkt:stream_data) =  {
            #var version := bytes_to_version(spkt.segment(1,5));
            var tppkt := ppkt;
            tppkt := tppkt.set(1,0xff);
            tppkt := tppkt.set(2,0x00);
            tppkt := tppkt.set(3,0x00);
            tppkt := tppkt.set(4,0x1d);
            rppkt := tppkt;
        }

        # TODO add dynamic condition to save packets
        action save_packets(ppkt:stream_data) = {
            # TODO if saved_packet_type ...
            #ppkt_saved := ppkt;
            <<<
            const char * session_file = getenv("SAVED_PACKET");
            std::cerr << "SAVED_PACKET 5b " << ppkt.size() << "\n";
            FILE *fp;
            if(session_file != NULL) {
                fp = fopen(session_file,"w");
                for(int j = 0; j < ppkt.size(); j++) {
                    fprintf(fp, "%02x",  ppkt[j]); //length field
                }
                fclose(fp);
            }        
            >>>
        }

        action get_saved_packets returns(ppkt:stream_data) = {
            # TODO if saved_packet_type ...
            #ppkt_saved := ppkt;
            <<<
            const char * session_file = getenv("SAVED_PACKET");
            std::cerr << "SAVED_PACKET 5b " << session_file<< "\n";
            FILE *fp;
            if(session_file != NULL) {
                fp = fopen(session_file,"r");
                read = getline(&line, &len, fp);
                fclose(fp);
                bool is_error = false;
                if(line != NULL) { 
                    std::cerr << "SAVED_PACKET 1 " << line << std::endl;
                    int hex_len = strlen(line);
                    std::cerr << "SAVED_PACKET hex_len " << hex_len << std::endl;
                    uint8_t secret[hex_len/2];
                    for (int j = 0; j < hex_len/2; j++) {
                        int a = ws_xton(line[j*2]);
                        int b = ws_xton(line[j*2 + 1]);
                        if (a == -1 || b == -1) {
                            is_error = true;
                            std::cerr << "a ERROR " << line[j*2] << std::endl;
                            std::cerr << "b ERROR " << line[j*2 + 1] << std::endl;
                            std::cerr << "SAVED_PACKET ERROR " << std::endl;
                            break;
                        }
                        secret[j] = a << 4 | b;
                    }  
                    std::cerr << "SAVED_PACKET TEST_ST 2 " << secret << std::endl;
                    for(int i = 0; i < hex_len/2 && !is_error; i++)
                        ppkt.push_back(secret[i]);
                }
            }        
            >>>
        }

        action reflection_packets(ppkt:stream_data,dst_port:ip.port) = {
            # spoof source ip/port
            # TODO: we should modify the packet directly, however we only see the QUIC packet and thus this 
            # is impossible for now to do so 
            # Instead: we send with target ep so it simulate the ip spoofing
            # forward to server
            var dst := server.ep;
            var pkts_mim := prot.arr.empty;
            pkts_mim := pkts_mim.append(ppkt);
            call net.send(endpoint_id.target,sock_target,dst,pkts_mim);
        }

        # TODO more flexible -> in test configuration phase ?
        action configure_NAT_attack_in(server_quic:ip.port) = {
            <<< 
                //  -o lo
                std::string command = "sudo iptables -t nat -A OUTPUT -d 10.0.2.1 -p udp --dport " + std::to_string(server_quic) + ":" + std::to_string(server_quic) + " ! --sport 4430:4440 -j DNAT --to-destination 10.0.3.1:4440 >/dev/null 2>&1"; 
                int n = command.length();
            
                // declaring character array
                char command_array[n + 1];
            
                // copying the contents of the
                // string to char array
                strcpy(command_array, command.c_str());

                int cr = system(command_array);
            >>>
        }

        action configure_NAT_attack_out_trick(dst:ip.endpoint) = {
            # <<<
            #     /**
            #         Not working in localhost but should be ok in private adress TODO
            #             -> To simulate that we set: sock_mim_client = sock (from server) to simulate NAT
            #     */
            #     const char * command = "sudo iptables -t nat -A POSTROUTING -o lo -d 127.0.0.1 -p udp --sport 4439:4439 -j SNAT --to-source 127.0.0.1:4443"; //  # error in localhost
            #     int cr = system( command );
            # >>>
            sock_mim_client := sock; 
        }

        # OK for localhost but not for private adress
        action configure_NAT_attack_out_localhost(dst:ip.port) = {
            <<<
                /**
                    Not working in localhost but should be ok in private adress TODO
                        -> To simulate that we set: sock_mim_client = sock (from server) to simulate NAT
                */
                // -o lo
                std::string command = "sudo iptables -t nat -A POSTROUTING -d 10.0.3.1 -p udp --sport 4439:4439 -j SNAT --to-source 10.0.1.1:" + std::to_string(dst); //  # error in localhost
                int n = command.length();

                // declaring character array
                char command_array[n + 1];
            
                // copying the contents of the
                // string to char array
                strcpy(command_array, command.c_str());

                int cr = system(command_array);
            >>>
        }

         action configure_NAT_attack_out(dst:ip.port) = {
            <<<
                /**
                    Not working in localhost but should be ok in private adress TODO
                        -> To simulate that we set: sock_mim_client = sock (from server) to simulate NAT
                */
                // -o lo
                std::string command = "sudo iptables -t nat -A POSTROUTING -d 10.0.3.1 -p udp --sport 4439:4439 -j SNAT --to-source 10.0.1.1:" + std::to_string(dst); //  # error in localhost
                int n = command.length();

                // declaring character array
                char command_array[n + 1];
            
                // copying the contents of the
                // string to char array
                strcpy(command_array, command.c_str());

                int cr = system(command_array);
            >>>
        }


        action reset_NAT = {
            <<<
                const char * command = "sudo iptables -t nat -L -n -v;sudo iptables -t nat -F >/dev/null 2>&1"; 
                int cr = system( command );
            >>>
        }
    
    }

    module attacker_ep(address:ip.addr,port:ip.port) = { 
        variant this of endpoint = struct { }
        individual ep        : ip.endpoint
        individual tls_id    : tls_api.id
        individual enc_level : quic_packet_type

        after init {
            enc_level := quic_packet_type.initial;
            ep.protocol := ip.udp;
            ep.addr := address;
            ep.port := port;
        }
        
        action set_ep(e:ip.endpoint) = {
            ep := e;
        }

        action set_tls_id(e:tls_api.id) = {
            tls_id := e;
        }

        action behavior(host:endpoint_id, s:net.socket, src:ip.endpoint, pkts:prot.arr) = {
            var dst := socket_endpoint(host,s);  # because net API doesn't tell us the dst
            var idx := pkts.begin;
            var past_data : stream_data := stream_data.empty;
            while idx < pkts.end {
                var ppkt := pkts.value(idx);
                var tls_id := src_tls_id(dst); # todo multiple
                var header := ppkt.value(0);
                var hdr_type : type_bits := bfe[0][6](ppkt.value(0));
                var tt := bvand(hdr_type,0x30);
                var is_long : bool := bvand(0x80,header) ~= 0;
                
                var version := ppkt.segment(1,1+4);
                var bversion := bytes_to_version(version);
                
                var ptype : byte := bvand(0x30,header);

                if (bversion = 0 & is_long) | version_not_found(src) { 
                    # for server test, for version_negociation
                    # 1000 0000 == version_negociation
                    past_data := past_data.extend(ppkt);
                    call tls_client_version_response(src,dst,past_data);
                } 
                else if tt = 0x30 & ~(bversion = 0)  {
                    #for server test, Retry packet
                    call tls_client_retry_response(src,dst,ppkt);
                } 
                # else if is_pad { #is_pad | is_rand_pad
                #     call padding_packet_event(src,dst,ppkt); # For quic-go and quand  client
                # } 
                else { 
                    var rnum := reference_pkt_num(ppkt,true);
                    var res := prot.decrypt(tls_id,rnum,ppkt);
                    if res.ok {
                        var is_pad := is_padding_packet(res.payload); # For picoquic  client
                        if is_pad { #is_pad | is_rand_pad
                            call padding_packet_event(host,src,dst,ppkt);
                        } else {
                            var pkt := pkt_serdes.from_bytes(res.data);
                            pkt.seq_num := prot.correct_pnum(rnum,pkt.seq_num,prot.get_pnum_len(res.data));
                            call recv_packet(host,src,dst,pkt);
                            call infer_tls_events(src,dst,pkt);   # infer any TLS events on server side
                            call packet_event(src,dst,pkt);       # also an inferred event
                        };
                    } else {
                        call undecryptable_packet_event(host,src,dst,ppkt);
                    };
                };
                idx := idx.next;
            };
            version_not_found(src) := false;
            call show_last_datagram_size(last_datagram_received_size);
            if ~first_datagram_received & host = endpoint_id.server { # for client tests
                require last_datagram_received_size + 8 > 1200; # 8 is for UDP datagram header
                first_datagram_received := true;
            };
            last_datagram_received_size := 0;
        }

        action configure_NAT_attack_in_spoof(server_quic:ip.port,target_ep:ip.port) = {
            <<<
                // should use postrouting
                std::string command = "sudo iptables -t nat -A OUTPUT -o lo -d 127.0.0.1 -p udp --dport " + std::to_string(server_quic) + ":" + std::to_string(server_quic) + " -j DNAT --to-destination 127.0.0.1:"+ std::to_string(target_ep) +">/dev/null 2>&1"; 
                int n = command.length();
                std::cerr << "configure_NAT_attack_in_spoof " << command << "\n";
                // declaring character array
                char command_array[n + 1];
            
                // copying the contents of the
                // string to char array
                strcpy(command_array, command.c_str());

                int cr = system(command_array);
            >>>
        }

        action configure_NAT_attack_in_spoof_hack(server_quic:ip.port,target_ep:ip.port) = {
            sock_attacker := sock_target; 
        }
        
        action reset_NAT = {
            <<<
                const char * command = "sudo iptables -t nat -L -n -v;sudo iptables -t nat -F >/dev/null 2>&1"; 
                int cr = system( command );
            >>>
        }
    }
    
    module c2_server_ep(address:ip.addr, port: ip.port) = {
        
    }

    module bot_ep(address:ip.addr, port:ip.port) = {

    }

    module target_ep(address:ip.addr,port:ip.port) = { 
        variant this of endpoint = struct { }
        
        individual ep         : ip.endpoint
        individual tls_id     : tls_api.id
        individual enc_level  : quic_packet_type
        individual ppkt_recvd : forged_pkts

        after init {
            enc_level := quic_packet_type.initial;
            ep.protocol := ip.udp;
            ep.addr := address;
            ep.port := port;
            ppkt_recvd := forged_pkts.empty;
        }
        
        action set_ep(e:ip.endpoint) = {
            ep := e;
        }

        action set_tls_id(e:tls_api.id) = {
            tls_id := e;
        }

        action setup_socket = {
            # TODO
        }

        action behavior(host:endpoint_id, s:net.socket, src:ip.endpoint, pkts:prot.arr) = {
            var dst := socket_endpoint(host,s);  # because net API doesn't tell us the dst
            var idx := pkts.begin;
            while idx < pkts.end {
                var ppkt := pkts.value(idx);
                var tls_id := src_tls_id(dst); # todo multiple
                var header := ppkt.value(0);
                var hdr_type : type_bits := bfe[0][6](ppkt.value(0));
                var tt := bvand(hdr_type,0x30);
                var is_long : bool := bvand(0x80,header) ~= 0;
                
                var version := ppkt.segment(1,1+4);
                var bversion := bytes_to_version(version);
                
                var ptype : byte := bvand(0x30,header);

                call recv_packet_target(host,src,dst,ppkt);
                ppkt_recvd := ppkt_recvd.append(ppkt);
                idx := idx.next;
            };
        }
    }
}