struct __bool;
namespace ivy
{
    struct cint;
    
}
namespace ivy
{
    struct func;
    
}
namespace ivy
{
    struct size_t;
    
}
namespace __char
{
    struct __t;
    
}
namespace __char
{
    struct kinds;
    
}
namespace pos
{
    struct __t;
    
}
namespace str
{
    struct __t;
    
}
namespace pretty
{
    struct token;
    
}
namespace vector__pretty__token
{
    namespace domain
    {
        struct __t;
        
    }
    
}
namespace vector__pretty__token
{
    struct __t;
    
}
namespace pretty
{
    struct state;
    
}
namespace vector__pretty__state
{
    namespace domain
    {
        struct __t;
        
    }
    
}
namespace vector__pretty__state
{
    struct __t;
    
}
namespace vector__pos
{
    namespace domain
    {
        struct __t;
        
    }
    
}
namespace vector__pos
{
    struct __t;
    
}
namespace pretty
{
    struct __t;
    
}
namespace annot
{
    struct __t;
    
}
namespace vector__str
{
    namespace domain
    {
        struct __t;
        
    }
    
}
namespace vector__str
{
    struct __t;
    
}
namespace annot_i
{
    struct __t;
    
}
namespace pstate
{
    struct __t;
    
}
namespace priority
{
    struct __t;
    
}
namespace ivy
{
    namespace verb
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace ident
    {
        struct __t;
        
    }
    
}
namespace vector__ivy__ident
{
    namespace domain
    {
        struct __t;
        
    }
    
}
namespace vector__ivy__ident
{
    struct __t;
    
}
namespace ivy
{
    namespace strident
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace numident
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace dotident
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace expr
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace symbol
    {
        struct __t;
        
    }
    
}
namespace vector__ivy__expr
{
    namespace domain
    {
        struct __t;
        
    }
    
}
namespace vector__ivy__expr
{
    struct __t;
    
}
namespace ivy
{
    namespace app
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace variable
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace pi
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace stmt
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace asgn
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace sequence
    {
        struct __t;
        
    }
    
}
namespace vector__ivy__stmt
{
    namespace domain
    {
        struct __t;
        
    }
    
}
namespace vector__ivy__stmt
{
    struct __t;
    
}
namespace ivy
{
    namespace skipst
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace ifst
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace whilest
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace breakst
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace decl
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace action_kind
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace prototype_argument
    {
        struct __t;
        
    }
    
}
namespace vector__ivy__prototype_argument
{
    namespace domain
    {
        struct __t;
        
    }
    
}
namespace vector__ivy__prototype_argument
{
    struct __t;
    
}
namespace ivy
{
    namespace prototype
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace actdc
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace ident_set
    {
        struct rec;
        
    }
    
}
namespace ivy
{
    namespace ident_set
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace varst
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace pragmast
    {
        struct __t;
        
    }
    
}
namespace vector__ivy__decl
{
    namespace domain
    {
        struct __t;
        
    }
    
}
namespace vector__ivy__decl
{
    struct __t;
    
}
namespace ivy
{
    namespace groupdc
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace typespec
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace enumspec
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace structspec
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace typedc
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace vardc
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace header
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace interpdc
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace includedc
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace moduledc
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace instantiatedc
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace objectdc
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace instancedc
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace initdc
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace version
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace prog
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace error
    {
        struct __t;
        
    }
    
}
namespace vector__ivy__error
{
    namespace domain
    {
        struct __t;
        
    }
    
}
namespace vector__ivy__error
{
    struct __t;
    
}
namespace ivy
{
    namespace type_clash
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace type_conversion
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace untyped
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace not_first_order
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace file_not_found
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace cannot_write
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace undefined
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace redefining
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace wrong_number_params
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace syntax_error
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace bad_syntax
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace prog
    {
        struct readst;
        
    }
    
}
namespace ivy
{
    namespace symeval
    {
        struct rec;
        
    }
    
}
namespace ivy
{
    namespace symeval
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace ident_to_moduledc
    {
        struct rec;
        
    }
    
}
namespace ivy
{
    namespace ident_to_moduledc
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace ident_to_ident
    {
        struct rec;
        
    }
    
}
namespace ivy
{
    namespace ident_to_ident
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace ident_to_instantiatedc
    {
        struct rec;
        
    }
    
}
namespace ivy
{
    namespace ident_to_instantiatedc
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace ident_to_annot
    {
        struct rec;
        
    }
    
}
namespace ivy
{
    namespace ident_to_annot
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace flatst
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace ident_to_exprs
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace subtypes
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace global_types
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace param_map
    {
        struct rec;
        
    }
    
}
namespace ivy
{
    namespace param_map
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace local_info
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace push_pop_locals
    {
        struct undo;
        
    }
    
}
namespace ivy
{
    namespace push_pop_locals
    {
        namespace map_t
        {
            struct rec;
            
        }
        
    }
    
}
namespace ivy
{
    namespace push_pop_locals
    {
        namespace map_t
        {
            struct __t;
            
        }
        
    }
    
}
namespace ivy
{
    namespace push_pop_locals
    {
        namespace vec_t
        {
            struct __t;
            
        }
        
    }
    
}
namespace ivy
{
    namespace push_pop_locals
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace local_tracker
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace root_mod_ref
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace decost
    {
        namespace map
        {
            struct rec;
            
        }
        
    }
    
}
namespace ivy
{
    namespace decost
    {
        namespace map
        {
            struct __t;
            
        }
        
    }
    
}
namespace ivy
{
    namespace decost
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace elidest
    {
        namespace map
        {
            struct rec;
            
        }
        
    }
    
}
namespace ivy
{
    namespace elidest
    {
        namespace map
        {
            struct __t;
            
        }
        
    }
    
}
namespace ivy
{
    namespace elidest
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace type_context
    {
        struct stack_entry;
        
    }
    
}
namespace vector__ivy__type_context__stack_entry
{
    namespace domain
    {
        struct __t;
        
    }
    
}
namespace vector__ivy__type_context__stack_entry
{
    struct __t;
    
}
namespace ivy
{
    namespace type_context
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace typeinferst
    {
        struct __t;
        
    }
    
}
namespace cpp
{
    namespace verb
    {
        struct __t;
        
    }
    
}
namespace cpp
{
    namespace ident
    {
        struct __t;
        
    }
    
}
namespace vector__cpp__ident
{
    namespace domain
    {
        struct __t;
        
    }
    
}
namespace vector__cpp__ident
{
    struct __t;
    
}
namespace cpp
{
    namespace strident
    {
        struct __t;
        
    }
    
}
namespace cpp
{
    namespace numident
    {
        struct __t;
        
    }
    
}
namespace cpp
{
    namespace dotident
    {
        struct __t;
        
    }
    
}
namespace cpp
{
    namespace expr
    {
        struct __t;
        
    }
    
}
namespace cpp
{
    namespace symbol
    {
        struct __t;
        
    }
    
}
namespace vector__cpp__expr
{
    namespace domain
    {
        struct __t;
        
    }
    
}
namespace vector__cpp__expr
{
    struct __t;
    
}
namespace cpp
{
    namespace app
    {
        struct __t;
        
    }
    
}
namespace cpp
{
    namespace variable
    {
        struct __t;
        
    }
    
}
namespace cpp
{
    namespace pi
    {
        struct __t;
        
    }
    
}
namespace cpp
{
    namespace stmt
    {
        struct __t;
        
    }
    
}
namespace cpp
{
    namespace asgn
    {
        struct __t;
        
    }
    
}
namespace cpp
{
    namespace sequence
    {
        struct __t;
        
    }
    
}
namespace vector__cpp__stmt
{
    namespace domain
    {
        struct __t;
        
    }
    
}
namespace vector__cpp__stmt
{
    struct __t;
    
}
namespace cpp
{
    namespace skipst
    {
        struct __t;
        
    }
    
}
namespace cpp
{
    namespace ifst
    {
        struct __t;
        
    }
    
}
namespace cpp
{
    namespace whilest
    {
        struct __t;
        
    }
    
}
namespace cpp
{
    namespace breakst
    {
        struct __t;
        
    }
    
}
namespace cpp
{
    namespace simpletype
    {
        struct __t;
        
    }
    
}
namespace vector__cpp__simpletype
{
    namespace domain
    {
        struct __t;
        
    }
    
}
namespace vector__cpp__simpletype
{
    struct __t;
    
}
namespace cpp
{
    namespace functype
    {
        struct __t;
        
    }
    
}
namespace cpp
{
    namespace varst
    {
        struct __t;
        
    }
    
}
namespace cpp
{
    namespace retst
    {
        struct __t;
        
    }
    
}
namespace cpp
{
    namespace decl
    {
        struct __t;
        
    }
    
}
namespace cpp
{
    namespace header
    {
        struct __t;
        
    }
    
}
namespace cpp
{
    namespace typedecl
    {
        struct __t;
        
    }
    
}
namespace cpp
{
    namespace enumdecl
    {
        struct __t;
        
    }
    
}
namespace cpp
{
    namespace vardecl
    {
        struct __t;
        
    }
    
}
namespace cpp
{
    namespace funcdecl
    {
        struct __t;
        
    }
    
}
namespace vector__cpp__decl
{
    namespace domain
    {
        struct __t;
        
    }
    
}
namespace vector__cpp__decl
{
    struct __t;
    
}
namespace cpp
{
    namespace structdecl
    {
        struct __t;
        
    }
    
}
namespace cpp
{
    namespace namespacedecl
    {
        struct __t;
        
    }
    
}
namespace cpp
{
    namespace groupdc
    {
        struct __t;
        
    }
    
}
namespace cpp
{
    namespace version
    {
        struct __t;
        
    }
    
}
namespace cpp
{
    namespace prog
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace access_path
    {
        struct __t;
        
    }
    
}
// A pair consisting of an lvalue and an alias count
namespace ivy
{
    struct lvalue_count;
    
}
namespace ivy
{
    namespace path_tree
    {
        namespace elem
        {
            struct __t;
            
        }
        
    }
    
}
namespace ivy
{
    namespace path_tree
    {
        namespace undo_rec
        {
            struct __t;
            
        }
        
    }
    
}
namespace vector__ivy__path_tree__undo_rec
{
    namespace domain
    {
        struct __t;
        
    }
    
}
namespace vector__ivy__path_tree__undo_rec
{
    struct __t;
    
}
namespace ivy
{
    namespace path_tree
    {
        struct __t;
        
    }
    
}
namespace vector__ivy__access_path
{
    namespace domain
    {
        struct __t;
        
    }
    
}
namespace vector__ivy__access_path
{
    struct __t;
    
}
namespace ivy
{
    namespace borrowing
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace ident_to_declvec
    {
        struct rec;
        
    }
    
}
namespace ivy
{
    namespace ident_to_declvec
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace ident_to_cppclass
    {
        struct rec;
        
    }
    
}
namespace ivy
{
    namespace ident_to_cppclass
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace ident_to_prototype
    {
        struct rec;
        
    }
    
}
namespace ivy
{
    namespace ident_to_prototype
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace ident_to_borrowing
    {
        struct undo;
        
    }
    
}
namespace ivy
{
    namespace ident_to_borrowing
    {
        namespace map_t
        {
            struct rec;
            
        }
        
    }
    
}
namespace ivy
{
    namespace ident_to_borrowing
    {
        namespace map_t
        {
            struct __t;
            
        }
        
    }
    
}
namespace ivy
{
    namespace ident_to_borrowing
    {
        namespace vec_t
        {
            struct __t;
            
        }
        
    }
    
}
namespace ivy
{
    namespace ident_to_borrowing
    {
        struct __t;
        
    }
    
}
namespace ivy
{
    namespace cppident_to_cppexpr
    {
        struct undo;
        
    }
    
}
namespace ivy
{
    namespace cppident_to_cppexpr
    {
        namespace map_t
        {
            struct rec;
            
        }
        
    }
    
}
namespace ivy
{
    namespace cppident_to_cppexpr
    {
        namespace map_t
        {
            struct __t;
            
        }
        
    }
    
}
namespace ivy
{
    namespace cppident_to_cppexpr
    {
        namespace vec_t
        {
            struct __t;
            
        }
        
    }
    
}
namespace ivy
{
    namespace cppident_to_cppexpr
    {
        struct __t;
        
    }
    
}
namespace vector__ivy__lvalue_count
{
    namespace domain
    {
        struct __t;
        
    }
    
}
namespace vector__ivy__lvalue_count
{
    struct __t;
    
}
namespace ivy
{
    namespace tocppst
    {
        struct __t;
        
    }
    
}
namespace pid
{
    struct __t;
    
}
namespace retcode
{
    struct __t;
    
}
#include "ivy.h"
struct __bool : ivy::native_bool
{
     __bool () {}
     __bool  (long long value) : ivy::native_bool (value) {}
     __bool  (const ivy::native_bool &value) : ivy::native_bool (value) {}
     operator ivy::native_bool () const {
        return (*this);
    }
};
namespace ivy
{
    struct cint : ivy::native_int< int >
    {
         cint () {}
         cint  (long long value) : ivy::native_int< int > (value) {}
         cint  (const ivy::native_int< int > &value) : ivy::native_int< int > (value) {}
         operator ivy::native_int< int > () const {
            return (*this);
        }
    };
    
}
namespace ivy
{
    struct func
    {
         func () {}
         func  (long long value) {}
         operator std::size_t () const {
            return 0;
        }
        static bool __is_seq () {
            return false;
        }
        ivy::native_bool operator ==  (const func &other) const {
            return true;
        }
        ivy::native_bool operator !=  (const func &other) const {
            return ! ((*this) == other);
        }
        bool __is_zero () const {
            return true;
        }
        struct __hash
        {
            std::size_t operator ()  (const func &x) const {
                return 0;
            }
        };
        
    };
    
}
namespace ivy
{
    struct size_t
    {
         size_t () {}
         size_t  (long long value) {}
         operator std::size_t () const {
            return 0;
        }
        static bool __is_seq () {
            return false;
        }
        ivy::native_bool operator ==  (const size_t &other) const {
            return true;
        }
        ivy::native_bool operator !=  (const size_t &other) const {
            return ! ((*this) == other);
        }
        bool __is_zero () const {
            return true;
        }
        struct __hash
        {
            std::size_t operator ()  (const size_t &x) const {
                return 0;
            }
        };
        
    };
    
}
namespace __char
{
    struct __t : ivy::native_int< char >
    {
        __bool is_alphanum () const;
        
        __bool is_bracket () const;
        
        __bool is_white () const;
        
        __char::kinds kind () const;
        
        __bool non_printing () const;
        
        __bool is_digit () const;
        
        __bool is_hex () const;
        
        __bool is_capital () const;
        
        __char::__t downcase () const;
        
         __t () {}
         __t  (long long value) : ivy::native_int< char > (value) {}
         __t  (const ivy::native_int< char > &value) : ivy::native_int< char > (value) {}
         operator ivy::native_int< char > () const {
            return (*this);
        }
    };
    
}
namespace __char
{
    
    enum __enum_kinds  {alphanum,bracket,punct};
    
    struct kinds : ivy::native_enum< __enum_kinds >
    {
         kinds () {}
         kinds  (long long value) : ivy::native_enum< __enum_kinds > (value) {}
         kinds  (const ivy::native_enum< __enum_kinds > &value) :
            ivy::native_enum< __enum_kinds > (value) {}
         operator ivy::native_enum< __enum_kinds > () const {
            return (*this);
        }
    };
    
}
namespace pos
{
    struct __t : ivy::native_unsigned< size_t >
    {
        pos::__t next () const;
        
        pos::__t prev () const;
        
        str::__t to_str () const;
        
         __t () {}
         __t  (long long value) : ivy::native_unsigned< size_t > (value) {}
         __t  (const ivy::native_unsigned< size_t > &value) : ivy::native_unsigned< size_t > (value)
        {}
         operator ivy::native_unsigned< size_t > () const {
            return (*this);
        }
    };
    
}
namespace str
{
    struct __t
    {
        
        // We have two destructors (fields) representing the array
        // contents. The `value` field is represented using a dense
        // encoding, which means the C++ type `std::vector<range>`.
        
        ivy::vector< __char::__t,pos::__t > value;
        
        pos::__t end;
        
        
        // The `begin` action always returns 0.
        
        pos::__t begin () const;
        
        
        // The `set` action sets an element of an array
        
        void set  (const pos::__t &i,const __char::__t &v);
        
        
        // The `append` action appends one character `c` to a array.
        
        void append  (const __char::__t &c);
        
        
        // The `extend` action appends a array `x` to a array `s`.
        
        void extend  (const str::__t &x);
        
        
        // The `resize` action sets the end marker of the string. 
        
        void resize  (const pos::__t &end);
        
        
        // The `back` action returns the last element of an array, or zero
        // if the array is empty.
        
        __char::__t back () const;
        
        
        // The `back` action removes he last element of the array, if the
        // array is not empty.
        
        void pop_back ();
        
        
        // The `segment` action gets the segment of an array from index `beg` to
        // index `en-1`.
        
        str::__t segment  (const pos::__t &beg,const pos::__t &en) const;
        
        
        // The `reverse` action reverses an array.
        
        void reverse ();
        
        void encode  (pretty::__t &b) const;
        
         __t () {}
         __t  (long long value) {}
         operator std::size_t () const {
            return 0;
        }
        static bool __is_seq () {
            return false;
        }
        ivy::native_bool operator ==  (const __t &other) const
        {
            return value == other . value & end == other . end;
        }
        ivy::native_bool operator !=  (const __t &other) const {
            return ! ((*this) == other);
        }
        bool __is_zero () const {
            return value . __is_zero() & end . __is_zero();
        }
        struct __hash
        {
            std::size_t operator ()  (const __t &x) const
            {
                return ivy::vector< __char::__t,pos::__t >::__hash() (x . value) +
                    pos::__t::__hash() (x . end);
            }
        };
        
    };
    
}
// The `empty` action returns an empty array
namespace str
{
    str::__t empty ();
    
}
namespace pretty
{
    struct token
    {
        __bool pair;
        
        pos::__t tdepth;
        
        str::__t first;
        
        pos::__t second;
        
         token () {}
         token  (long long value) {}
         operator std::size_t () const {
            return 0;
        }
        static bool __is_seq () {
            return false;
        }
        ivy::native_bool operator ==  (const token &other) const
        {
            return pair == other . pair & tdepth == other . tdepth & first == other . first & second
                == other . second;
        }
        ivy::native_bool operator !=  (const token &other) const {
            return ! ((*this) == other);
        }
        bool __is_zero () const
        {
            return pair . __is_zero() & tdepth . __is_zero() & first . __is_zero() &
                second . __is_zero();
        }
        struct __hash
        {
            std::size_t operator ()  (const token &x) const
            {
                return __bool::__hash() (x . pair) + pos::__t::__hash() (x . tdepth) +
                    str::__t::__hash() (x . first) + pos::__t::__hash() (x . second);
            }
        };
        
    };
    
}
namespace vector__pretty__token
{
    namespace domain
    {
        struct __t : ivy::native_unsigned< size_t >
        {
            vector__pretty__token::domain::__t next () const;
            
            vector__pretty__token::domain::__t prev () const;
            
             __t () {}
             __t  (long long value) : ivy::native_unsigned< size_t > (value) {}
             __t  (const ivy::native_unsigned< size_t > &value) :
                ivy::native_unsigned< size_t > (value) {}
             operator ivy::native_unsigned< size_t > () const {
                return (*this);
            }
        };
        
    }
    
}
namespace vector__pretty__token
{
    struct __t
    {
        ivy::vector< pretty::token,vector__pretty__token::domain::__t > value;
        
        vector__pretty__token::domain::__t end;
        
        vector__pretty__token::domain::__t begin () const;
        
        void set  (const vector__pretty__token::domain::__t &i,const pretty::token &v);
        
        void append  (const pretty::token &c);
        
        void extend  (const vector__pretty__token::__t &x);
        
        void resize  (const vector__pretty__token::domain::__t &end);
        
        pretty::token back () const;
        
        void pop_back ();
        
        vector__pretty__token::__t segment  (const vector__pretty__token::domain::__t &beg,const
            vector__pretty__token::domain::__t &en) const;
        
        void reverse ();
        
         __t () {}
         __t  (long long value) {}
         operator std::size_t () const {
            return 0;
        }
        static bool __is_seq () {
            return false;
        }
        ivy::native_bool operator ==  (const __t &other) const
        {
            return value == other . value & end == other . end;
        }
        ivy::native_bool operator !=  (const __t &other) const {
            return ! ((*this) == other);
        }
        bool __is_zero () const {
            return value . __is_zero() & end . __is_zero();
        }
        struct __hash
        {
            std::size_t operator ()  (const __t &x) const
            {
                return
                    ivy::vector< pretty::token,vector__pretty__token::domain::__t >::__hash() (x .
                        value) + vector__pretty__token::domain::__t::__hash() (x . end);
            }
        };
        
    };
    
}
namespace vector__pretty__token
{
    vector__pretty__token::__t empty ();
    
}
namespace pretty
{
    vector__pretty__token::__t foo;
    
}
namespace pretty
{
    struct state
    {
        vector__pretty__token::domain::__t begin;
        
        pos::__t total;
        
         state () {}
         state  (long long value) {}
         operator std::size_t () const {
            return 0;
        }
        static bool __is_seq () {
            return false;
        }
        ivy::native_bool operator ==  (const state &other) const
        {
            return begin == other . begin & total == other . total;
        }
        ivy::native_bool operator !=  (const state &other) const {
            return ! ((*this) == other);
        }
        bool __is_zero () const {
            return begin . __is_zero() & total . __is_zero();
        }
        struct __hash
        {
            std::size_t operator ()  (const state &x) const
            {
                return vector__pretty__token::domain::__t::__hash() (x . begin) +
                    pos::__t::__hash() (x . total);
            }
        };
        
    };
    
}
namespace vector__pretty__state
{
    namespace domain
    {
        struct __t : ivy::native_unsigned< size_t >
        {
            vector__pretty__state::domain::__t next () const;
            
            vector__pretty__state::domain::__t prev () const;
            
             __t () {}
             __t  (long long value) : ivy::native_unsigned< size_t > (value) {}
             __t  (const ivy::native_unsigned< size_t > &value) :
                ivy::native_unsigned< size_t > (value) {}
             operator ivy::native_unsigned< size_t > () const {
                return (*this);
            }
        };
        
    }
    
}
namespace vector__pretty__state
{
    struct __t
    {
        ivy::vector< pretty::state,vector__pretty__state::domain::__t > value;
        
        vector__pretty__state::domain::__t end;
        
        vector__pretty__state::domain::__t begin () const;
        
        void set  (const vector__pretty__state::domain::__t &i,const pretty::state &v);
        
        void append  (const pretty::state &c);
        
        void extend  (const vector__pretty__state::__t &x);
        
        void resize  (const vector__pretty__state::domain::__t &end);
        
        pretty::state back () const;
        
        void pop_back ();
        
        vector__pretty__state::__t segment  (const vector__pretty__state::domain::__t &beg,const
            vector__pretty__state::domain::__t &en) const;
        
        void reverse ();
        
         __t () {}
         __t  (long long value) {}
         operator std::size_t () const {
            return 0;
        }
        static bool __is_seq () {
            return false;
        }
        ivy::native_bool operator ==  (const __t &other) const
        {
            return value == other . value & end == other . end;
        }
        ivy::native_bool operator !=  (const __t &other) const {
            return ! ((*this) == other);
        }
        bool __is_zero () const {
            return value . __is_zero() & end . __is_zero();
        }
        struct __hash
        {
            std::size_t operator ()  (const __t &x) const
            {
                return
                    ivy::vector< pretty::state,vector__pretty__state::domain::__t >::__hash() (x .
                        value) + vector__pretty__state::domain::__t::__hash() (x . end);
            }
        };
        
    };
    
}
namespace vector__pretty__state
{
    vector__pretty__state::__t empty ();
    
}
namespace vector__pos
{
    namespace domain
    {
        struct __t : ivy::native_unsigned< size_t >
        {
            vector__pos::domain::__t next () const;
            
            vector__pos::domain::__t prev () const;
            
             __t () {}
             __t  (long long value) : ivy::native_unsigned< size_t > (value) {}
             __t  (const ivy::native_unsigned< size_t > &value) :
                ivy::native_unsigned< size_t > (value) {}
             operator ivy::native_unsigned< size_t > () const {
                return (*this);
            }
        };
        
    }
    
}
namespace vector__pos
{
    struct __t
    {
        ivy::vector< pos::__t,vector__pos::domain::__t > value;
        
        vector__pos::domain::__t end;
        
        vector__pos::domain::__t begin () const;
        
        void set  (const vector__pos::domain::__t &i,const pos::__t &v);
        
        void append  (const pos::__t &c);
        
        void extend  (const vector__pos::__t &x);
        
        void resize  (const vector__pos::domain::__t &end);
        
        pos::__t back () const;
        
        void pop_back ();
        
        vector__pos::__t segment  (const vector__pos::domain::__t &beg,const vector__pos::domain::__t
            &en) const;
        
        void reverse ();
        
         __t () {}
         __t  (long long value) {}
         operator std::size_t () const {
            return 0;
        }
        static bool __is_seq () {
            return false;
        }
        ivy::native_bool operator ==  (const __t &other) const
        {
            return value == other . value & end == other . end;
        }
        ivy::native_bool operator !=  (const __t &other) const {
            return ! ((*this) == other);
        }
        bool __is_zero () const {
            return value . __is_zero() & end . __is_zero();
        }
        struct __hash
        {
            std::size_t operator ()  (const __t &x) const
            {
                return ivy::vector< pos::__t,vector__pos::domain::__t >::__hash() (x . value) +
                    vector__pos::domain::__t::__hash() (x . end);
            }
        };
        
    };
    
}
namespace vector__pos
{
    vector__pos::__t empty ();
    
}
namespace pretty
{
    struct __t
    {
        vector__pretty__token::__t tokens;
        
        pretty::state st;
        
        pos::__t maxline;
        
        pos::__t indent;
        
        str::__t whitespace;
        
        vector__pretty__state::__t states;
        
        vector__pos::__t stack;
        
        str::__t output;
        
        pos::__t space;
        
        pos::__t depth;
        
        __bool cppstyle;
        
        ivy::vector< __bool,str::__t,pos::__t > annots;
        
        void do_indent ();
        
        void print  (const pretty::token &tok);
        
        void flush ();
        
        void add_length  (const pos::__t &len,const vector__pretty__token::domain::__t &at);
        
        void extend  (const str::__t &string);
        
        void newline ();
        
        void nest ();
        
        void unnest ();
        
         __t () {}
         __t  (long long value) {}
         operator std::size_t () const {
            return 0;
        }
        static bool __is_seq () {
            return false;
        }
        ivy::native_bool operator ==  (const __t &other) const
        {
            return tokens == other . tokens & st == other . st & maxline == other . maxline & indent
                == other . indent & whitespace == other . whitespace & states == other . states &
                stack == other . stack & output == other . output & space == other . space & depth
                == other . depth & cppstyle == other . cppstyle & annots == other . annots;
        }
        ivy::native_bool operator !=  (const __t &other) const {
            return ! ((*this) == other);
        }
        bool __is_zero () const
        {
            return tokens . __is_zero() & st . __is_zero() & maxline . __is_zero() &
                indent . __is_zero() & whitespace . __is_zero() & states . __is_zero() &
                stack . __is_zero() & output . __is_zero() & space . __is_zero() &
                depth . __is_zero() & cppstyle . __is_zero() & annots . __is_zero();
        }
        struct __hash
        {
            std::size_t operator ()  (const __t &x) const
            {
                return vector__pretty__token::__t::__hash() (x . tokens) +
                    pretty::state::__hash() (x . st) + pos::__t::__hash() (x . maxline) +
                    pos::__t::__hash() (x . indent) + str::__t::__hash() (x . whitespace) +
                    vector__pretty__state::__t::__hash() (x . states) +
                    vector__pos::__t::__hash() (x . stack) + str::__t::__hash() (x . output) +
                    pos::__t::__hash() (x . space) + pos::__t::__hash() (x . depth) +
                    __bool::__hash() (x . cppstyle) +
                    ivy::vector< __bool,str::__t,pos::__t >::__hash() (x . annots);
            }
        };
        
    };
    
}
namespace pretty
{
    pretty::__t make  (const pos::__t &maxline,const pos::__t &indent);
    
}
namespace annot
{
    struct __t
    {
        virtual void encode  (pretty::__t &b) const;
        
        virtual ivy::ptr< annot::__t > strip () const;
        
        virtual str::__t to_str () const;
        
         __t () {}
         __t  (long long value) {}
         operator std::size_t () const {
            return 0;
        }
        static bool __is_seq () {
            return false;
        }
        ivy::native_bool operator ==  (const __t &other) const {
            return true;
        }
        ivy::native_bool operator !=  (const __t &other) const {
            return ! ((*this) == other);
        }
        bool __is_zero () const {
            return true;
        }
        struct __hash
        {
            std::size_t operator ()  (const __t &x) const {
                return 0;
            }
        };
        
        virtual ivy::ptr< __t > __upcast () const {
            return (*this);
        }
        virtual  ~__t () {}
    };
    
}
namespace vector__str
{
    namespace domain
    {
        struct __t : ivy::native_unsigned< size_t >
        {
            vector__str::domain::__t next () const;
            
            vector__str::domain::__t prev () const;
            
             __t () {}
             __t  (long long value) : ivy::native_unsigned< size_t > (value) {}
             __t  (const ivy::native_unsigned< size_t > &value) :
                ivy::native_unsigned< size_t > (value) {}
             operator ivy::native_unsigned< size_t > () const {
                return (*this);
            }
        };
        
    }
    
}
namespace vector__str
{
    struct __t
    {
        ivy::vector< str::__t,vector__str::domain::__t > value;
        
        vector__str::domain::__t end;
        
        vector__str::domain::__t begin () const;
        
        void set  (const vector__str::domain::__t &i,const str::__t &v);
        
        void append  (const str::__t &c);
        
        void extend  (const vector__str::__t &x);
        
        void resize  (const vector__str::domain::__t &end);
        
        str::__t back () const;
        
        void pop_back ();
        
        vector__str::__t segment  (const vector__str::domain::__t &beg,const vector__str::domain::__t
            &en) const;
        
        void reverse ();
        
         __t () {}
         __t  (long long value) {}
         operator std::size_t () const {
            return 0;
        }
        static bool __is_seq () {
            return false;
        }
        ivy::native_bool operator ==  (const __t &other) const
        {
            return value == other . value & end == other . end;
        }
        ivy::native_bool operator !=  (const __t &other) const {
            return ! ((*this) == other);
        }
        bool __is_zero () const {
            return value . __is_zero() & end . __is_zero();
        }
        struct __hash
        {
            std::size_t operator ()  (const __t &x) const
            {
                return ivy::vector< str::__t,vector__str::domain::__t >::__hash() (x . value) +
                    vector__str::domain::__t::__hash() (x . end);
            }
        };
        
    };
    
}
namespace vector__str
{
    vector__str::__t empty ();
    
}
namespace annot_i
{
    struct __t : annot::__t
    {
        vector__str::__t comments;
        
        pos::__t line;
        
        str::__t file;
        
        void encode  (pretty::__t &b) const;
        
        ivy::ptr< annot::__t > strip () const;
        
        
        // Convert an annotation to a string for error reporting
        // purposes. We count line internally from zero, but in messages
        // they start from one.
        
        str::__t to_str () const;
        
         __t () {}
         __t  (long long value) {}
         operator std::size_t () const {
            return 0;
        }
        static bool __is_seq () {
            return false;
        }
        ivy::native_bool operator ==  (const __t &other) const
        {
            return comments == other . comments & line == other . line & file == other . file;
        }
        ivy::native_bool operator !=  (const __t &other) const {
            return ! ((*this) == other);
        }
        bool __is_zero () const
        {
            return comments . __is_zero() & line . __is_zero() & file . __is_zero();
        }
        struct __hash
        {
            std::size_t operator ()  (const __t &x) const
            {
                return vector__str::__t::__hash() (x . comments) + pos::__t::__hash() (x . line) +
                    str::__t::__hash() (x . file);
            }
        };
        
        virtual ivy::ptr< annot::__t > __upcast () const {
            return (*this);
        }
    };
    
}
namespace pstate
{
    struct __t
    {
        str::__t b;
        
        pos::__t p;
        
        str::__t tok;
        
        annot_i::__t ann;
        
        __bool ok;
        
        void consume ();
        
        void get_ann  (ivy::ptr< annot::__t > &ann);
        
         __t () {}
         __t  (long long value) {}
         operator std::size_t () const {
            return 0;
        }
        static bool __is_seq () {
            return false;
        }
        ivy::native_bool operator ==  (const __t &other) const
        {
            return b == other . b & p == other . p & tok == other . tok & ann == other . ann & ok ==
                other . ok;
        }
        ivy::native_bool operator !=  (const __t &other) const {
            return ! ((*this) == other);
        }
        bool __is_zero () const
        {
            return b . __is_zero() & p . __is_zero() & tok . __is_zero() & ann . __is_zero() &
                ok . __is_zero();
        }
        struct __hash
        {
            std::size_t operator ()  (const __t &x) const
            {
                return str::__t::__hash() (x . b) + pos::__t::__hash() (x . p) +
                    str::__t::__hash() (x . tok) + annot_i::__t::__hash() (x . ann) +
                    __bool::__hash() (x . ok);
            }
        };
        
    };
    
}
namespace pstate
{
    pstate::__t make  (const str::__t &s);
    
}
// Lexical analyzer. Read tokens from the input stream 
// ---------------------------------------------------
//
// A token is one of the following:
//
// - A singleton characeter in the bracket set
// - A maximal sequence of characters in the alphanumeric set
// - A maximal sequence of characters in the punctuation set
// - A numeric literal
// - A string literal
//
// Tokens may be separated by whitespace, which consists of space,
// tab, carriage return and newline characters as well as comments. A
// comment is a hash character up to and including the next newline or
// the end of stream, whichever comes first.
//
// A string literal consists of printing characters enclosed in double
// quote characters. The following escape sequences are recognized:
//
// - \n : newline character
//
// A backslash followed by any other printing character is interpreted
// as that character. 
//
// Any non-printing character other than carriage return and newline
// is considered a syntax error.
// 
void skip_space  (pstate::__t &st);
void get_line  (pstate::__t &st,str::__t &line);
void get_annot  (pstate::__t &st);
void read_string_literal  (pstate::__t &st);
namespace decimals
{
    void read  (pstate::__t &st);
    
}
namespace hexes
{
    void read  (pstate::__t &st);
    
}
// Parsing numeric literals. A numeric literal has one of these
// forms:
//
// - [0..9]+{\.[0..9]+{[eE]{[+-]}[0..9]+}}
// - 0[xX][0-9A-Fa-f]+ 
//
// That is, we allow the usual formats for non-negative integers,
// and floating point numbers, including hex integers. 
void read_numeric_literal  (pstate::__t &st);
void lex  (pstate::__t &st);
namespace pos
{
    pos::__t from_str  (const str::__t &x);
    
}
namespace stdio
{
    void write  (const str::__t &s);
    
}
// The `write` action writes a string to standard output followed
// by newline.
namespace stdio
{
    void writeln  (const str::__t &s);
    
}
// The `read` action from standard input untio EOF.
namespace stdio
{
    str::__t read ();
    
}
// The `readln` action reads a line from standard input, returning
// the line without any terminating newline character.
namespace stdio
{
    str::__t readln ();
    
}
namespace priority
{
    struct __t : ivy::native_int< int >
    {
         __t () {}
         __t  (long long value) : ivy::native_int< int > (value) {}
         __t  (const ivy::native_int< int > &value) : ivy::native_int< int > (value) {}
         operator ivy::native_int< int > () const {
            return (*this);
        }
    };
    
}
void parse_error  (const pos::__t &p,const str::__t &tok);
namespace ivy
{
    namespace verb
    {
        
        enum __enum___t  {none,arrow,plus,times,colon,app,empty,dot,__new,numeral,fltnum,castv,boolv,truev,falsev,__and,__or,__not,iff,equals,notequals,lt,leq,gt,geq,minus,div,string,ite,comma,varv,logvar,isav};
        
        struct __t : ivy::native_enum< __enum___t >
        {
             __t () {}
             __t  (long long value) : ivy::native_enum< __enum___t > (value) {}
             __t  (const ivy::native_enum< __enum___t > &value) :
                ivy::native_enum< __enum___t > (value) {}
             operator ivy::native_enum< __enum___t > () const {
                return (*this);
            }
        };
        
    }
    
}
namespace ivy
{
    ivy::vector< ivy::verb::__t,str::__t > str_to_verb;
    
}
namespace ivy
{
    ivy::vector< str::__t,ivy::verb::__t > verb_to_str;
    
}
namespace ivy
{
    ivy::vector< priority::__t,ivy::verb::__t > verb_to_prio;
    
}
namespace ivy
{
    ivy::vector< pos::__t,ivy::verb::__t > verb_to_arity;
    
}
// Numerals are symbols beginning with a digit. String literals begin
// with double quotes. Logical variables consist of a capital followed
// by any number of digits. Otherwise we determine
// the verb of a symbol from its name by looking it up in
// `str_to_verb`. The default is `none`, which indicates a
// program-defined symbol.
namespace ivy
{
    __bool is_logvar_name  (const str::__t &name);
    
}
namespace ivy
{
    ivy::verb::__t verb_from_name  (const str::__t &name);
    
}
namespace ivy
{
    namespace ident
    {
        struct __t
        {
            virtual void encode  (pretty::__t &b,const priority::__t &prio) const;
            
            virtual str::__t to_str () const;
            
            virtual ivy::ptr< ivy::ident::__t > get_namesp () const;
            
            virtual ivy::ptr< ivy::ident::__t > get_member () const;
            
            virtual vector__ivy__ident::__t get_subscripts () const;
            
            virtual ivy::ptr< ivy::ident::__t > prefix  (const ivy::ptr< ivy::ident::__t > &pref)
                const;
            
            virtual ivy::strident::__t get_last () const;
            
            virtual ivy::verb::__t get_verb () const;
            
            virtual ivy::ptr< ivy::ident::__t > flat  (const __bool &rhs,const ivy::flatst::__t &st)
                const;
            
            virtual ivy::ptr< cpp::ident::__t > to_cpp  (const __bool &native) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const {
                return true;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return true;
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const {
                    return 0;
                }
            };
            
            virtual ivy::ptr< __t > __upcast () const {
                return (*this);
            }
            virtual  ~__t () {}
        };
        
    }
    
}
namespace vector__ivy__ident
{
    namespace domain
    {
        struct __t : ivy::native_unsigned< size_t >
        {
            vector__ivy__ident::domain::__t next () const;
            
            vector__ivy__ident::domain::__t prev () const;
            
             __t () {}
             __t  (long long value) : ivy::native_unsigned< size_t > (value) {}
             __t  (const ivy::native_unsigned< size_t > &value) :
                ivy::native_unsigned< size_t > (value) {}
             operator ivy::native_unsigned< size_t > () const {
                return (*this);
            }
        };
        
    }
    
}
namespace vector__ivy__ident
{
    struct __t
    {
        ivy::vector< ivy::ptr< ivy::ident::__t >,vector__ivy__ident::domain::__t > value;
        
        vector__ivy__ident::domain::__t end;
        
        vector__ivy__ident::domain::__t begin () const;
        
        void set  (const vector__ivy__ident::domain::__t &i,const ivy::ptr< ivy::ident::__t > &v);
        
        void append  (const ivy::ptr< ivy::ident::__t > &c);
        
        void extend  (const vector__ivy__ident::__t &x);
        
        void resize  (const vector__ivy__ident::domain::__t &end);
        
        ivy::ptr< ivy::ident::__t > back () const;
        
        void pop_back ();
        
        vector__ivy__ident::__t segment  (const vector__ivy__ident::domain::__t &beg,const
            vector__ivy__ident::domain::__t &en) const;
        
        void reverse ();
        
         __t () {}
         __t  (long long value) {}
         operator std::size_t () const {
            return 0;
        }
        static bool __is_seq () {
            return false;
        }
        ivy::native_bool operator ==  (const __t &other) const
        {
            return value == other . value & end == other . end;
        }
        ivy::native_bool operator !=  (const __t &other) const {
            return ! ((*this) == other);
        }
        bool __is_zero () const {
            return value . __is_zero() & end . __is_zero();
        }
        struct __hash
        {
            std::size_t operator ()  (const __t &x) const
            {
                return
                    ivy::vector< ivy::ptr< ivy::ident::__t >,vector__ivy__ident::domain::__t >::__hash()
                        (x . value) + vector__ivy__ident::domain::__t::__hash() (x . end);
            }
        };
        
    };
    
}
namespace vector__ivy__ident
{
    vector__ivy__ident::__t empty ();
    
}
namespace ivy
{
    namespace strident
    {
        struct __t : ivy::ident::__t
        {
            str::__t val;
            
            vector__ivy__ident::__t subscrs;
            
            void encode  (pretty::__t &b,const priority::__t &prio) const;
            
            str::__t to_str () const;
            
            ivy::ptr< ivy::ident::__t > prefix  (const ivy::ptr< ivy::ident::__t > &pref) const;
            
            ivy::strident::__t get_last () const;
            
            ivy::verb::__t get_verb () const;
            
            ivy::ptr< ivy::ident::__t > flat  (const __bool &rhs,const ivy::flatst::__t &st) const;
            
            ivy::ptr< cpp::ident::__t > to_cpp  (const __bool &native) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return val == other . val & subscrs == other . subscrs;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return val . __is_zero() & subscrs . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return str::__t::__hash() (x . val) +
                        vector__ivy__ident::__t::__hash() (x . subscrs);
                }
            };
            
            virtual ivy::ptr< ivy::ident::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace ivy
{
    namespace strident
    {
        ivy::ptr< ivy::ident::__t > make  (const str::__t &val);
        
    }
    
}
namespace ivy
{
    namespace strident
    {
        ivy::ptr< ivy::ident::__t > make1  (const str::__t &val,const ivy::ptr< ivy::ident::__t > &arg);
        
    }
    
}
namespace ivy
{
    namespace strident
    {
        void parse  (pstate::__t &st,ivy::strident::__t &id);
        
    }
    
}
namespace ivy
{
    namespace numident
    {
        struct __t : ivy::ident::__t
        {
            pos::__t val;
            
            void encode  (pretty::__t &b,const priority::__t &prio) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const {
                return val == other . val;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return val . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const {
                    return pos::__t::__hash() (x . val);
                }
            };
            
            virtual ivy::ptr< ivy::ident::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace ivy
{
    namespace numident
    {
        ivy::ptr< ivy::ident::__t > make  (const pos::__t &val);
        
    }
    
}
namespace ivy
{
    namespace dotident
    {
        struct __t : ivy::ident::__t
        {
            ivy::ptr< ivy::ident::__t > namesp;
            
            ivy::strident::__t member;
            
            void encode  (pretty::__t &b,const priority::__t &prio) const;
            
            str::__t to_str () const;
            
            ivy::ptr< ivy::ident::__t > get_namesp () const;
            
            ivy::ptr< ivy::ident::__t > get_member () const;
            
            ivy::ptr< ivy::ident::__t > prefix  (const ivy::ptr< ivy::ident::__t > &pref) const;
            
            ivy::strident::__t get_last () const;
            
            ivy::ptr< ivy::ident::__t > flat  (const __bool &rhs,const ivy::flatst::__t &st) const;
            
            ivy::ptr< cpp::ident::__t > to_cpp  (const __bool &native) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return namesp == other . namesp & member == other . member;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return namesp . __is_zero() & member . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return ivy::ptr< ivy::ident::__t >::__hash() (x . namesp) +
                        ivy::strident::__t::__hash() (x . member);
                }
            };
            
            virtual ivy::ptr< ivy::ident::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace ivy
{
    namespace dotident
    {
        ivy::ptr< ivy::ident::__t > make  (const ivy::ptr< ivy::ident::__t > &namesp,const ivy::strident::__t
            &member);
        
    }
    
}
namespace ivy
{
    namespace expr
    {
        struct __t
        {
            virtual void encode  (pretty::__t &b,const priority::__t &prio) const;
            
            virtual str::__t enc () const;
            
            virtual ivy::verb::__t get_verb () const;
            
            virtual ivy::verb::__t get_verb_typed () const;
            
            virtual __bool is  (const ivy::verb::__t &vrb) const;
            
            virtual __bool is_typed  (const ivy::verb::__t &vrb) const;
            
            virtual ivy::ptr< ivy::expr::__t > get_arg  (const vector__ivy__expr::domain::__t &p)
                const;
            
            virtual ivy::ptr< ivy::ident::__t > get_name () const;
            
            virtual ivy::verb::__t app_verb () const;
            
            virtual ivy::ptr< annot::__t > get_ann () const;
            
            virtual ivy::ptr< ivy::expr::__t > get_func () const;
            
            virtual vector__ivy__expr::__t get_args () const;
            
            virtual ivy::ptr< ivy::expr::__t > prefix  (const ivy::ptr< ivy::ident::__t > &pref)
                const;
            
            
            // Tests whether two expressions are syntacically equal,
            // leaving aside annotations.
            
            virtual __bool eq  (const ivy::ptr< ivy::expr::__t > &e2) const;
            
            virtual ivy::ptr< ivy::expr::__t > reduce  (const ivy::symeval::__t &smap) const;
            
            virtual __bool occurs  (const ivy::ptr< ivy::ident::__t > &n) const;
            
            virtual __bool has_numident () const;
            
            virtual void flat  (ivy::flatst::__t &st,ivy::ptr< ivy::expr::__t > &res) const;
            
            virtual ivy::ptr< ivy::expr::__t > uncurry () const;
            
            virtual ivy::ptr< ivy::expr::__t > curry () const;
            
            virtual void type_decorate  (ivy::decost::__t &st,const ivy::symeval::__t &m,ivy::ptr< ivy::expr::__t >
                &res,ivy::ptr< ivy::expr::__t > &ty) const;
            
            virtual void type_fill_in  (ivy::decost::__t &st,ivy::ptr< ivy::expr::__t > &res) const;
            
            virtual void type_elide_int  (const __bool &b,const ivy::symeval::__t &m,ivy::elidest::__t
                &st,ivy::ptr< ivy::expr::__t > &res) const;
            
            virtual ivy::ptr< ivy::expr::__t > get_type () const;
            
            virtual void to_cpp  (ivy::tocppst::__t &st,ivy::ptr< cpp::expr::__t > &res) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const {
                return true;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return true;
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const {
                    return 0;
                }
            };
            
            virtual ivy::ptr< __t > __upcast () const {
                return (*this);
            }
            virtual  ~__t () {}
        };
        
    }
    
}
namespace ivy
{
    namespace expr
    {
        ivy::ptr< ivy::expr::__t > dec  (const str::__t &s);
        
    }
    
}
namespace ivy
{
    namespace expr
    {
        str::__t encdec  (const str::__t &s);
        
    }
    
}
namespace ivy
{
    namespace symbol
    {
        struct __t : ivy::expr::__t
        {
            ivy::ptr< ivy::ident::__t > name;
            
            ivy::verb::__t vrb;
            
            ivy::ptr< annot::__t > ann;
            
            void encode  (pretty::__t &b,const priority::__t &prio) const;
            
            ivy::verb::__t get_verb () const;
            
            ivy::ptr< ivy::ident::__t > get_name () const;
            
            ivy::ptr< annot::__t > get_ann () const;
            
            ivy::ptr< ivy::expr::__t > prefix  (const ivy::ptr< ivy::ident::__t > &pref) const;
            
            ivy::ptr< ivy::expr::__t > reduce  (const ivy::symeval::__t &smap) const;
            
            __bool occurs  (const ivy::ptr< ivy::ident::__t > &n) const;
            
            __bool has_numident () const;
            
            void flat  (ivy::flatst::__t &st,ivy::ptr< ivy::expr::__t > &res) const;
            
            void type_decorate  (ivy::decost::__t &st,const ivy::symeval::__t &m,ivy::ptr< ivy::expr::__t >
                &res,ivy::ptr< ivy::expr::__t > &ty) const;
            
            void type_fill_in  (ivy::decost::__t &st,ivy::ptr< ivy::expr::__t > &res) const;
            
            void type_elide_int  (const __bool &b,const ivy::symeval::__t &m,ivy::elidest::__t &st,ivy::ptr< ivy::expr::__t >
                &res) const;
            
            void to_cpp  (ivy::tocppst::__t &st,ivy::ptr< cpp::expr::__t > &res) const;
            
            void to_cpp_int  (ivy::tocppst::__t &st,cpp::symbol::__t &res) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return name == other . name & vrb == other . vrb & ann == other . ann;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const
            {
                return name . __is_zero() & vrb . __is_zero() & ann . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return ivy::ptr< ivy::ident::__t >::__hash() (x . name) +
                        ivy::verb::__t::__hash() (x . vrb) +
                        ivy::ptr< annot::__t >::__hash() (x . ann);
                }
            };
            
            virtual ivy::ptr< ivy::expr::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace ivy
{
    namespace symbol
    {
        ivy::ptr< ivy::expr::__t > make  (const ivy::ptr< ivy::ident::__t > &name,const ivy::ptr< annot::__t >
            &ann);
        
    }
    
}
namespace ivy
{
    namespace symbol
    {
        ivy::ptr< ivy::expr::__t > makestr  (const str::__t &name,const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace ivy
{
    namespace symbol
    {
        ivy::ptr< ivy::expr::__t > makestr1  (const str::__t &name,const ivy::ptr< ivy::ident::__t >
            &arg,const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace ivy
{
    namespace symbol
    {
        ivy::ptr< ivy::expr::__t > makenum  (const pos::__t &num,const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace ivy
{
    namespace symbol
    {
        void parse  (pstate::__t &st,ivy::ptr< ivy::expr::__t > &res);
        
    }
    
}
namespace vector__ivy__expr
{
    namespace domain
    {
        struct __t : ivy::native_unsigned< size_t >
        {
            vector__ivy__expr::domain::__t next () const;
            
            vector__ivy__expr::domain::__t prev () const;
            
             __t () {}
             __t  (long long value) : ivy::native_unsigned< size_t > (value) {}
             __t  (const ivy::native_unsigned< size_t > &value) :
                ivy::native_unsigned< size_t > (value) {}
             operator ivy::native_unsigned< size_t > () const {
                return (*this);
            }
        };
        
    }
    
}
namespace vector__ivy__expr
{
    struct __t
    {
        ivy::vector< ivy::ptr< ivy::expr::__t >,vector__ivy__expr::domain::__t > value;
        
        vector__ivy__expr::domain::__t end;
        
        vector__ivy__expr::domain::__t begin () const;
        
        void set  (const vector__ivy__expr::domain::__t &i,const ivy::ptr< ivy::expr::__t > &v);
        
        void append  (const ivy::ptr< ivy::expr::__t > &c);
        
        void extend  (const vector__ivy__expr::__t &x);
        
        void resize  (const vector__ivy__expr::domain::__t &end);
        
        ivy::ptr< ivy::expr::__t > back () const;
        
        void pop_back ();
        
        vector__ivy__expr::__t segment  (const vector__ivy__expr::domain::__t &beg,const
            vector__ivy__expr::domain::__t &en) const;
        
        void reverse ();
        
         __t () {}
         __t  (long long value) {}
         operator std::size_t () const {
            return 0;
        }
        static bool __is_seq () {
            return false;
        }
        ivy::native_bool operator ==  (const __t &other) const
        {
            return value == other . value & end == other . end;
        }
        ivy::native_bool operator !=  (const __t &other) const {
            return ! ((*this) == other);
        }
        bool __is_zero () const {
            return value . __is_zero() & end . __is_zero();
        }
        struct __hash
        {
            std::size_t operator ()  (const __t &x) const
            {
                return
                    ivy::vector< ivy::ptr< ivy::expr::__t >,vector__ivy__expr::domain::__t >::__hash()
                        (x . value) + vector__ivy__expr::domain::__t::__hash() (x . end);
            }
        };
        
    };
    
}
namespace vector__ivy__expr
{
    vector__ivy__expr::__t empty ();
    
}
namespace ivy
{
    namespace app
    {
        struct __t : ivy::expr::__t
        {
            ivy::ptr< ivy::expr::__t > func;
            
            vector__ivy__expr::__t args;
            
            ivy::ptr< annot::__t > ann;
            
            void encode  (pretty::__t &b,const priority::__t &prio) const;
            
            __bool is  (const ivy::verb::__t &vrb) const;
            
            __bool is_typed  (const ivy::verb::__t &vrb) const;
            
            ivy::verb::__t app_verb () const;
            
            ivy::ptr< ivy::expr::__t > get_func () const;
            
            vector__ivy__expr::__t get_args () const;
            
            ivy::ptr< ivy::expr::__t > get_arg  (const vector__ivy__expr::domain::__t &p) const;
            
            ivy::ptr< annot::__t > get_ann () const;
            
            ivy::ptr< ivy::expr::__t > reduce  (const ivy::symeval::__t &smap) const;
            
            __bool occurs  (const ivy::ptr< ivy::ident::__t > &n) const;
            
            __bool has_numident () const;
            
            void flat  (ivy::flatst::__t &st,ivy::ptr< ivy::expr::__t > &res) const;
            
            void type_decorate  (ivy::decost::__t &st,const ivy::symeval::__t &m,ivy::ptr< ivy::expr::__t >
                &res,ivy::ptr< ivy::expr::__t > &ty) const;
            
            void type_fill_in  (ivy::decost::__t &st,ivy::ptr< ivy::expr::__t > &res) const;
            
            void type_elide_int  (const __bool &b0,const ivy::symeval::__t &m,ivy::elidest::__t &st,ivy::ptr< ivy::expr::__t >
                &res) const;
            
            ivy::ptr< ivy::expr::__t > get_type () const;
            
            void to_cpp  (ivy::tocppst::__t &st,ivy::ptr< cpp::expr::__t > &res) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return func == other . func & args == other . args & ann == other . ann;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const
            {
                return func . __is_zero() & args . __is_zero() & ann . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return ivy::ptr< ivy::expr::__t >::__hash() (x . func) +
                        vector__ivy__expr::__t::__hash() (x . args) +
                        ivy::ptr< annot::__t >::__hash() (x . ann);
                }
            };
            
            virtual ivy::ptr< ivy::expr::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace ivy
{
    namespace app
    {
        ivy::ptr< ivy::expr::__t > make  (const ivy::ptr< ivy::expr::__t > &func,const
            vector__ivy__expr::__t &args,const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace ivy
{
    namespace app
    {
        ivy::ptr< ivy::expr::__t > make1  (const ivy::ptr< ivy::expr::__t > &func,const ivy::ptr< ivy::expr::__t >
            &arg0,const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace ivy
{
    namespace app
    {
        ivy::ptr< ivy::expr::__t > make2  (const ivy::ptr< ivy::expr::__t > &func,const ivy::ptr< ivy::expr::__t >
            &arg0,const ivy::ptr< ivy::expr::__t > &arg1,const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace ivy
{
    namespace variable
    {
        struct __t : ivy::expr::__t
        {
            pos::__t idx;
            
            ivy::ptr< annot::__t > ann;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return idx == other . idx & ann == other . ann;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return idx . __is_zero() & ann . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return pos::__t::__hash() (x . idx) + ivy::ptr< annot::__t >::__hash() (x . ann);
                }
            };
            
            virtual ivy::ptr< ivy::expr::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace ivy
{
    namespace variable
    {
        ivy::ptr< ivy::expr::__t > make  (const pos::__t &idx);
        
    }
    
}
namespace ivy
{
    namespace pi
    {
        struct __t : ivy::expr::__t
        {
            vector__ivy__expr::__t vars;
            
            ivy::ptr< ivy::expr::__t > body;
            
            ivy::ptr< annot::__t > ann;
            
            void encode  (pretty::__t &b,const priority::__t &prio) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return vars == other . vars & body == other . body & ann == other . ann;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const
            {
                return vars . __is_zero() & body . __is_zero() & ann . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return vector__ivy__expr::__t::__hash() (x . vars) +
                        ivy::ptr< ivy::expr::__t >::__hash() (x . body) +
                        ivy::ptr< annot::__t >::__hash() (x . ann);
                }
            };
            
            virtual ivy::ptr< ivy::expr::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace ivy
{
    namespace pi
    {
        ivy::ptr< ivy::expr::__t > make  (const vector__ivy__expr::__t &vars,const ivy::ptr< ivy::expr::__t >
            &body,const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace ivy
{
    namespace iff
    {
        ivy::ptr< ivy::expr::__t > make  (const ivy::ptr< ivy::expr::__t > &lhs,const ivy::ptr< ivy::expr::__t >
            &rhs,const ivy::ptr< annot::__t > &ann);
        
    }
    
}
// Translate the vector `[x1,..,xn]` to the expression `x1 * ... *
// xn`, where `*` is a binary operator that associates to the left.
namespace ivy
{
    namespace iff
    {
        ivy::ptr< ivy::expr::__t > fold_left  (const vector__ivy__expr::__t &args,const ivy::ptr< annot::__t >
            &ann);
        
    }
    
}
// Works for comma and cross product
// Translate the expression `x1 * ... * xn` to the vector `[x1,..,xn]`,
// where `*` is a binary operator that associates to the left.
namespace ivy
{
    namespace iff
    {
        vector__ivy__expr::__t unfold_left  (const ivy::ptr< ivy::expr::__t > &s);
        
    }
    
}
namespace ivy
{
    namespace __or
    {
        ivy::ptr< ivy::expr::__t > make  (const ivy::ptr< ivy::expr::__t > &lhs,const ivy::ptr< ivy::expr::__t >
            &rhs,const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace ivy
{
    namespace __or
    {
        ivy::ptr< ivy::expr::__t > fold_left  (const vector__ivy__expr::__t &args,const ivy::ptr< annot::__t >
            &ann);
        
    }
    
}
namespace ivy
{
    namespace __or
    {
        vector__ivy__expr::__t unfold_left  (const ivy::ptr< ivy::expr::__t > &s);
        
    }
    
}
namespace ivy
{
    namespace __and
    {
        ivy::ptr< ivy::expr::__t > make  (const ivy::ptr< ivy::expr::__t > &lhs,const ivy::ptr< ivy::expr::__t >
            &rhs,const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace ivy
{
    namespace __and
    {
        ivy::ptr< ivy::expr::__t > fold_left  (const vector__ivy__expr::__t &args,const ivy::ptr< annot::__t >
            &ann);
        
    }
    
}
namespace ivy
{
    namespace __and
    {
        vector__ivy__expr::__t unfold_left  (const ivy::ptr< ivy::expr::__t > &s);
        
    }
    
}
namespace ivy
{
    namespace lt
    {
        ivy::ptr< ivy::expr::__t > make  (const ivy::ptr< ivy::expr::__t > &lhs,const ivy::ptr< ivy::expr::__t >
            &rhs,const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace ivy
{
    namespace lt
    {
        ivy::ptr< ivy::expr::__t > fold_left  (const vector__ivy__expr::__t &args,const ivy::ptr< annot::__t >
            &ann);
        
    }
    
}
namespace ivy
{
    namespace lt
    {
        vector__ivy__expr::__t unfold_left  (const ivy::ptr< ivy::expr::__t > &s);
        
    }
    
}
namespace ivy
{
    namespace leq
    {
        ivy::ptr< ivy::expr::__t > make  (const ivy::ptr< ivy::expr::__t > &lhs,const ivy::ptr< ivy::expr::__t >
            &rhs,const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace ivy
{
    namespace leq
    {
        ivy::ptr< ivy::expr::__t > fold_left  (const vector__ivy__expr::__t &args,const ivy::ptr< annot::__t >
            &ann);
        
    }
    
}
namespace ivy
{
    namespace leq
    {
        vector__ivy__expr::__t unfold_left  (const ivy::ptr< ivy::expr::__t > &s);
        
    }
    
}
namespace ivy
{
    namespace gt
    {
        ivy::ptr< ivy::expr::__t > make  (const ivy::ptr< ivy::expr::__t > &lhs,const ivy::ptr< ivy::expr::__t >
            &rhs,const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace ivy
{
    namespace gt
    {
        ivy::ptr< ivy::expr::__t > fold_left  (const vector__ivy__expr::__t &args,const ivy::ptr< annot::__t >
            &ann);
        
    }
    
}
namespace ivy
{
    namespace gt
    {
        vector__ivy__expr::__t unfold_left  (const ivy::ptr< ivy::expr::__t > &s);
        
    }
    
}
namespace ivy
{
    namespace geq
    {
        ivy::ptr< ivy::expr::__t > make  (const ivy::ptr< ivy::expr::__t > &lhs,const ivy::ptr< ivy::expr::__t >
            &rhs,const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace ivy
{
    namespace geq
    {
        ivy::ptr< ivy::expr::__t > fold_left  (const vector__ivy__expr::__t &args,const ivy::ptr< annot::__t >
            &ann);
        
    }
    
}
namespace ivy
{
    namespace geq
    {
        vector__ivy__expr::__t unfold_left  (const ivy::ptr< ivy::expr::__t > &s);
        
    }
    
}
namespace ivy
{
    namespace plus
    {
        ivy::ptr< ivy::expr::__t > make  (const ivy::ptr< ivy::expr::__t > &lhs,const ivy::ptr< ivy::expr::__t >
            &rhs,const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace ivy
{
    namespace plus
    {
        ivy::ptr< ivy::expr::__t > fold_left  (const vector__ivy__expr::__t &args,const ivy::ptr< annot::__t >
            &ann);
        
    }
    
}
namespace ivy
{
    namespace plus
    {
        vector__ivy__expr::__t unfold_left  (const ivy::ptr< ivy::expr::__t > &s);
        
    }
    
}
namespace ivy
{
    namespace minus
    {
        ivy::ptr< ivy::expr::__t > make  (const ivy::ptr< ivy::expr::__t > &lhs,const ivy::ptr< ivy::expr::__t >
            &rhs,const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace ivy
{
    namespace minus
    {
        ivy::ptr< ivy::expr::__t > fold_left  (const vector__ivy__expr::__t &args,const ivy::ptr< annot::__t >
            &ann);
        
    }
    
}
namespace ivy
{
    namespace minus
    {
        vector__ivy__expr::__t unfold_left  (const ivy::ptr< ivy::expr::__t > &s);
        
    }
    
}
namespace ivy
{
    namespace times
    {
        ivy::ptr< ivy::expr::__t > make  (const ivy::ptr< ivy::expr::__t > &lhs,const ivy::ptr< ivy::expr::__t >
            &rhs,const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace ivy
{
    namespace times
    {
        ivy::ptr< ivy::expr::__t > fold_left  (const vector__ivy__expr::__t &args,const ivy::ptr< annot::__t >
            &ann);
        
    }
    
}
namespace ivy
{
    namespace times
    {
        vector__ivy__expr::__t unfold_left  (const ivy::ptr< ivy::expr::__t > &s);
        
    }
    
}
namespace ivy
{
    namespace div
    {
        ivy::ptr< ivy::expr::__t > make  (const ivy::ptr< ivy::expr::__t > &lhs,const ivy::ptr< ivy::expr::__t >
            &rhs,const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace ivy
{
    namespace div
    {
        ivy::ptr< ivy::expr::__t > fold_left  (const vector__ivy__expr::__t &args,const ivy::ptr< annot::__t >
            &ann);
        
    }
    
}
namespace ivy
{
    namespace div
    {
        vector__ivy__expr::__t unfold_left  (const ivy::ptr< ivy::expr::__t > &s);
        
    }
    
}
namespace ivy
{
    namespace empty
    {
        ivy::ptr< ivy::expr::__t > make  (const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace ivy
{
    namespace boolv
    {
        ivy::ptr< ivy::expr::__t > make  (const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace ivy
{
    namespace truev
    {
        ivy::ptr< ivy::expr::__t > make  (const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace ivy
{
    namespace falsev
    {
        ivy::ptr< ivy::expr::__t > make  (const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace ivy
{
    namespace comma
    {
        ivy::ptr< ivy::expr::__t > make  (const ivy::ptr< ivy::expr::__t > &lhs,const ivy::ptr< ivy::expr::__t >
            &rhs,const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace ivy
{
    namespace comma
    {
        ivy::ptr< ivy::expr::__t > fold_left  (const vector__ivy__expr::__t &args,const ivy::ptr< annot::__t >
            &ann);
        
    }
    
}
namespace ivy
{
    namespace comma
    {
        vector__ivy__expr::__t unfold_left  (const ivy::ptr< ivy::expr::__t > &s);
        
    }
    
}
namespace ivy
{
    namespace dot
    {
        ivy::ptr< ivy::expr::__t > make  (const ivy::ptr< ivy::expr::__t > &lhs,const ivy::ptr< ivy::expr::__t >
            &rhs,const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace ivy
{
    namespace dot
    {
        ivy::ptr< ivy::expr::__t > fold_left  (const vector__ivy__expr::__t &args,const ivy::ptr< annot::__t >
            &ann);
        
    }
    
}
namespace ivy
{
    namespace dot
    {
        vector__ivy__expr::__t unfold_left  (const ivy::ptr< ivy::expr::__t > &s);
        
    }
    
}
namespace ivy
{
    namespace expr
    {
        vector__ivy__expr::__t foo;
        
    }
    
}
// workaround
namespace ivy
{
    namespace expr
    {
        void parse  (pstate::__t &st,const priority::__t &prio,ivy::ptr< ivy::expr::__t > &res);
        
    }
    
}
namespace ivy
{
    namespace expr
    {
        namespace tup
        {
            void encode  (const vector__ivy__expr::__t &s,pretty::__t &b,const priority::__t &prio);
            
        }
        
    }
    
}
namespace ivy
{
    namespace expr
    {
        namespace tup
        {
            void parse  (pstate::__t &st,const priority::__t &prio,vector__ivy__expr::__t &res);
            
        }
        
    }
    
}
namespace ivy
{
    namespace stmt
    {
        struct __t
        {
            virtual void encode  (pretty::__t &b,const priority::__t &prio) const;
            
            virtual str::__t enc () const;
            
            virtual ivy::ptr< ivy::expr::__t > get_expr () const;
            
            virtual ivy::ptr< ivy::expr::__t > get_lhs () const;
            
            virtual ivy::ptr< ivy::expr::__t > get_rhs () const;
            
            virtual ivy::ptr< annot::__t > get_ann () const;
            
            virtual void flat  (ivy::flatst::__t &st,ivy::ptr< ivy::stmt::__t > &res) const;
            
            virtual ivy::ptr< ivy::ident::__t > get_ident () const;
            
            
            // Get just the roots that are modified by a statement
            
            virtual void mod_roots  (ivy::root_mod_ref::__t &st) const;
            
            virtual void typeinfer  (ivy::typeinferst::__t &st,ivy::ptr< ivy::stmt::__t > &res)
                const;
            
            virtual void typeinfer_desugar  (const __bool &desugar,ivy::typeinferst::__t &st,ivy::ptr< ivy::stmt::__t >
                &ress) const;
            
            virtual void to_cpp  (ivy::tocppst::__t &st,ivy::ptr< cpp::stmt::__t > &res) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const {
                return true;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return true;
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const {
                    return 0;
                }
            };
            
            virtual ivy::ptr< __t > __upcast () const {
                return (*this);
            }
            virtual  ~__t () {}
        };
        
    }
    
}
namespace ivy
{
    namespace stmt
    {
        ivy::ptr< ivy::stmt::__t > dec  (const str::__t &s);
        
    }
    
}
namespace ivy
{
    namespace stmt
    {
        str::__t encdec  (const str::__t &s);
        
    }
    
}
namespace ivy
{
    namespace asgn
    {
        struct __t : ivy::stmt::__t
        {
            ivy::ptr< ivy::expr::__t > lhs;
            
            ivy::ptr< ivy::expr::__t > rhs;
            
            ivy::ptr< annot::__t > ann;
            
            void encode  (pretty::__t &b,const priority::__t &prio) const;
            
            void encode_int  (pretty::__t &b,const priority::__t &prio) const;
            
            
            // This gets the lhs of the assignment
            
            ivy::ptr< ivy::expr::__t > get_lhs () const;
            
            
            // This gets the rhs of the assignment
            
            ivy::ptr< ivy::expr::__t > get_rhs () const;
            
            ivy::ptr< annot::__t > get_ann () const;
            
            void flat  (ivy::flatst::__t &st,ivy::ptr< ivy::stmt::__t > &res) const;
            
            void flat_int  (ivy::flatst::__t &st,ivy::asgn::__t &res) const;
            
            void mod_roots  (ivy::root_mod_ref::__t &st) const;
            
            void typeinfer_desugar  (const __bool &desugar,ivy::typeinferst::__t &st,ivy::ptr< ivy::stmt::__t >
                &ress) const;
            
            void typeinfer  (ivy::typeinferst::__t &st,ivy::ptr< ivy::stmt::__t > &ress) const;
            
            void to_cpp  (ivy::tocppst::__t &st,ivy::ptr< cpp::stmt::__t > &resd) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return lhs == other . lhs & rhs == other . rhs & ann == other . ann;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const
            {
                return lhs . __is_zero() & rhs . __is_zero() & ann . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return ivy::ptr< ivy::expr::__t >::__hash() (x . lhs) +
                        ivy::ptr< ivy::expr::__t >::__hash() (x . rhs) +
                        ivy::ptr< annot::__t >::__hash() (x . ann);
                }
            };
            
            virtual ivy::ptr< ivy::stmt::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace ivy
{
    namespace asgn
    {
        ivy::ptr< ivy::stmt::__t > make  (const ivy::ptr< ivy::expr::__t > &x,const ivy::ptr< ivy::expr::__t >
            &y,const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace ivy
{
    namespace sequence
    {
        struct __t : ivy::stmt::__t
        {
            ivy::ptr< ivy::stmt::__t > lhs;
            
            ivy::ptr< ivy::stmt::__t > rhs;
            
            ivy::ptr< annot::__t > ann;
            
            void encode  (pretty::__t &b,const priority::__t &prio) const;
            
            void encode_int  (pretty::__t &b,const priority::__t &prio) const;
            
            ivy::ptr< annot::__t > get_ann () const;
            
            void flat  (ivy::flatst::__t &st,ivy::ptr< ivy::stmt::__t > &res) const;
            
            void flat_int  (ivy::flatst::__t &st,ivy::sequence::__t &res) const;
            
            void mod_roots  (ivy::root_mod_ref::__t &st) const;
            
            void typeinfer  (ivy::typeinferst::__t &st,ivy::ptr< ivy::stmt::__t > &ress) const;
            
            void to_cpp  (ivy::tocppst::__t &st,ivy::ptr< cpp::stmt::__t > &resd) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return lhs == other . lhs & rhs == other . rhs & ann == other . ann;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const
            {
                return lhs . __is_zero() & rhs . __is_zero() & ann . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return ivy::ptr< ivy::stmt::__t >::__hash() (x . lhs) +
                        ivy::ptr< ivy::stmt::__t >::__hash() (x . rhs) +
                        ivy::ptr< annot::__t >::__hash() (x . ann);
                }
            };
            
            virtual ivy::ptr< ivy::stmt::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace ivy
{
    namespace sequence
    {
        ivy::ptr< ivy::stmt::__t > make  (const ivy::ptr< ivy::stmt::__t > &x,const ivy::ptr< ivy::stmt::__t >
            &y,const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace vector__ivy__stmt
{
    namespace domain
    {
        struct __t : ivy::native_unsigned< size_t >
        {
            vector__ivy__stmt::domain::__t next () const;
            
            vector__ivy__stmt::domain::__t prev () const;
            
             __t () {}
             __t  (long long value) : ivy::native_unsigned< size_t > (value) {}
             __t  (const ivy::native_unsigned< size_t > &value) :
                ivy::native_unsigned< size_t > (value) {}
             operator ivy::native_unsigned< size_t > () const {
                return (*this);
            }
        };
        
    }
    
}
namespace vector__ivy__stmt
{
    struct __t
    {
        ivy::vector< ivy::ptr< ivy::stmt::__t >,vector__ivy__stmt::domain::__t > value;
        
        vector__ivy__stmt::domain::__t end;
        
        vector__ivy__stmt::domain::__t begin () const;
        
        void set  (const vector__ivy__stmt::domain::__t &i,const ivy::ptr< ivy::stmt::__t > &v);
        
        void append  (const ivy::ptr< ivy::stmt::__t > &c);
        
        void extend  (const vector__ivy__stmt::__t &x);
        
        void resize  (const vector__ivy__stmt::domain::__t &end);
        
        ivy::ptr< ivy::stmt::__t > back () const;
        
        void pop_back ();
        
        vector__ivy__stmt::__t segment  (const vector__ivy__stmt::domain::__t &beg,const
            vector__ivy__stmt::domain::__t &en) const;
        
        void reverse ();
        
         __t () {}
         __t  (long long value) {}
         operator std::size_t () const {
            return 0;
        }
        static bool __is_seq () {
            return false;
        }
        ivy::native_bool operator ==  (const __t &other) const
        {
            return value == other . value & end == other . end;
        }
        ivy::native_bool operator !=  (const __t &other) const {
            return ! ((*this) == other);
        }
        bool __is_zero () const {
            return value . __is_zero() & end . __is_zero();
        }
        struct __hash
        {
            std::size_t operator ()  (const __t &x) const
            {
                return
                    ivy::vector< ivy::ptr< ivy::stmt::__t >,vector__ivy__stmt::domain::__t >::__hash()
                        (x . value) + vector__ivy__stmt::domain::__t::__hash() (x . end);
            }
        };
        
    };
    
}
namespace vector__ivy__stmt
{
    vector__ivy__stmt::__t empty ();
    
}
namespace ivy
{
    namespace sequence
    {
        vector__ivy__stmt::__t dummy;
        
    }
    
}
// workaround
// Translate the vector `[x1,..,xn]` to the expression `x1 * ... *
// xn`, where `*` is a binary operator that associates to the right.
namespace ivy
{
    namespace sequence
    {
        ivy::ptr< ivy::stmt::__t > fold_right  (const vector__ivy__stmt::__t &args,const ivy::ptr< annot::__t >
            &ann);
        
    }
    
}
namespace ivy
{
    namespace skipst
    {
        struct __t : ivy::stmt::__t
        {
            ivy::ptr< annot::__t > ann;
            
            void encode  (pretty::__t &b,const priority::__t &prio) const;
            
            ivy::ptr< annot::__t > get_ann () const;
            
            
            //        instantiate generic_to_cpp(skipst,cpp.skipst,cpp.stmt)
            
            void to_cpp  (ivy::tocppst::__t &st,ivy::ptr< cpp::stmt::__t > &res) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const {
                return ann == other . ann;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return ann . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return ivy::ptr< annot::__t >::__hash() (x . ann);
                }
            };
            
            virtual ivy::ptr< ivy::stmt::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace ivy
{
    namespace skipst
    {
        ivy::ptr< ivy::stmt::__t > make  (const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace ivy
{
    namespace ifst
    {
        struct __t : ivy::stmt::__t
        {
            ivy::ptr< ivy::expr::__t > cond;
            
            ivy::ptr< ivy::stmt::__t > thenst;
            
            ivy::ptr< ivy::stmt::__t > elsest;
            
            ivy::ptr< annot::__t > ann;
            
            void encode  (pretty::__t &b,const priority::__t &prio) const;
            
            void encode_int  (pretty::__t &b,const priority::__t &prio) const;
            
            ivy::ptr< annot::__t > get_ann () const;
            
            void flat  (ivy::flatst::__t &st,ivy::ptr< ivy::stmt::__t > &res) const;
            
            void flat_int  (ivy::flatst::__t &st,ivy::ifst::__t &res) const;
            
            void mod_roots  (ivy::root_mod_ref::__t &st) const;
            
            void typeinfer  (ivy::typeinferst::__t &st,ivy::ptr< ivy::stmt::__t > &res) const;
            
            void typeinfer_int  (ivy::typeinferst::__t &st,ivy::ifst::__t &res) const;
            
            void to_cpp  (ivy::tocppst::__t &st,ivy::ptr< cpp::stmt::__t > &resd) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return cond == other . cond & thenst == other . thenst & elsest == other . elsest &
                    ann == other . ann;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const
            {
                return cond . __is_zero() & thenst . __is_zero() & elsest . __is_zero() &
                    ann . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return ivy::ptr< ivy::expr::__t >::__hash() (x . cond) +
                        ivy::ptr< ivy::stmt::__t >::__hash() (x . thenst) +
                        ivy::ptr< ivy::stmt::__t >::__hash() (x . elsest) +
                        ivy::ptr< annot::__t >::__hash() (x . ann);
                }
            };
            
            virtual ivy::ptr< ivy::stmt::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace ivy
{
    namespace ifst
    {
        ivy::ptr< ivy::stmt::__t > make  (const ivy::ptr< ivy::expr::__t > &cond,const ivy::ptr< ivy::stmt::__t >
            &thenst,const ivy::ptr< ivy::stmt::__t > &elsest,const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace ivy
{
    namespace whilest
    {
        struct __t : ivy::stmt::__t
        {
            ivy::ptr< ivy::expr::__t > cond;
            
            ivy::ptr< ivy::stmt::__t > body;
            
            ivy::ptr< annot::__t > ann;
            
            void encode  (pretty::__t &b,const priority::__t &prio) const;
            
            void encode_int  (pretty::__t &b,const priority::__t &prio) const;
            
            ivy::ptr< annot::__t > get_ann () const;
            
            void flat  (ivy::flatst::__t &st,ivy::ptr< ivy::stmt::__t > &res) const;
            
            void flat_int  (ivy::flatst::__t &st,ivy::whilest::__t &res) const;
            
            void mod_roots  (ivy::root_mod_ref::__t &st) const;
            
            void typeinfer  (ivy::typeinferst::__t &st,ivy::ptr< ivy::stmt::__t > &res) const;
            
            void typeinfer_int  (ivy::typeinferst::__t &st,ivy::whilest::__t &res) const;
            
            void to_cpp  (ivy::tocppst::__t &st,ivy::ptr< cpp::stmt::__t > &resd) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return cond == other . cond & body == other . body & ann == other . ann;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const
            {
                return cond . __is_zero() & body . __is_zero() & ann . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return ivy::ptr< ivy::expr::__t >::__hash() (x . cond) +
                        ivy::ptr< ivy::stmt::__t >::__hash() (x . body) +
                        ivy::ptr< annot::__t >::__hash() (x . ann);
                }
            };
            
            virtual ivy::ptr< ivy::stmt::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace ivy
{
    namespace whilest
    {
        ivy::ptr< ivy::stmt::__t > make  (const ivy::ptr< ivy::expr::__t > &cond,const ivy::ptr< ivy::stmt::__t >
            &body,const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace ivy
{
    namespace breakst
    {
        struct __t : ivy::stmt::__t
        {
            ivy::ptr< annot::__t > ann;
            
            void encode  (pretty::__t &b,const priority::__t &prio) const;
            
            void encode_int  (pretty::__t &b,const priority::__t &prio) const;
            
            ivy::ptr< annot::__t > get_ann () const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const {
                return ann == other . ann;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return ann . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return ivy::ptr< annot::__t >::__hash() (x . ann);
                }
            };
            
            virtual ivy::ptr< ivy::stmt::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace ivy
{
    namespace breakst
    {
        ivy::ptr< ivy::stmt::__t > make  (const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace ivy
{
    namespace stmt
    {
        void parse  (pstate::__t &st,const priority::__t &prio,ivy::ptr< ivy::stmt::__t > &res);
        
    }
    
}
namespace ivy
{
    namespace decl
    {
        struct __t
        {
            virtual void encode  (pretty::__t &b,const priority::__t &prio) const;
            
            virtual str::__t enc () const;
            
            virtual ivy::ptr< ivy::expr::__t > get_expr () const;
            
            virtual ivy::ptr< annot::__t > get_ann () const;
            
            virtual ivy::ptr< ivy::stmt::__t > get_body () const;
            
            virtual void flat  (ivy::flatst::__t &st) const;
            
            virtual void defd  (ivy::flatst::__t &st) const;
            
            virtual void build_subtypes  (ivy::subtypes::__t &st) const;
            
            virtual void build_global_types  (ivy::global_types::__t &st) const;
            
            virtual void typeinfer  (ivy::typeinferst::__t &st,ivy::ptr< ivy::decl::__t > &res)
                const;
            
            virtual void to_cpp  (ivy::tocppst::__t &st,ivy::ptr< cpp::decl::__t > &res) const;
            
            virtual void reg_member  (ivy::tocppst::__t &st) const;
            
            virtual __bool emitted  (const ivy::tocppst::__t &st) const;
            
            virtual void record_prototypes  (ivy::tocppst::__t &st) const;
            
            virtual ivy::ptr< ivy::decl::__t > func_to_action () const;
            
            virtual ivy::ptr< ivy::decl::__t > fix_action  (const ivy::tocppst::__t &st) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const {
                return true;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return true;
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const {
                    return 0;
                }
            };
            
            virtual ivy::ptr< __t > __upcast () const {
                return (*this);
            }
            virtual  ~__t () {}
        };
        
    }
    
}
namespace ivy
{
    namespace decl
    {
        ivy::ptr< ivy::decl::__t > dec  (const str::__t &s);
        
    }
    
}
namespace ivy
{
    namespace decl
    {
        str::__t encdec  (const str::__t &s);
        
    }
    
}
namespace ivy
{
    namespace action_kind
    {
        
        enum __enum___t  {internal,external,imported,exported};
        
        struct __t : ivy::native_enum< __enum___t >
        {
             __t () {}
             __t  (long long value) : ivy::native_enum< __enum___t > (value) {}
             __t  (const ivy::native_enum< __enum___t > &value) :
                ivy::native_enum< __enum___t > (value) {}
             operator ivy::native_enum< __enum___t > () const {
                return (*this);
            }
        };
        
    }
    
}
namespace ivy
{
    namespace prototype_argument
    {
        struct __t
        {
            ivy::ptr< ivy::expr::__t > name;
            
            __bool is_input;
            
            vector__ivy__expr::domain::__t inpos;
            
            __bool is_output;
            
            vector__ivy__expr::domain::__t outpos;
            
            __bool is_ref;
            
            __bool is_const;
            
            __bool is_copy;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return name == other . name & is_input == other . is_input & inpos == other . inpos
                    & is_output == other . is_output & outpos == other . outpos & is_ref == other .
                    is_ref & is_const == other . is_const & is_copy == other . is_copy;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const
            {
                return name . __is_zero() & is_input . __is_zero() & inpos . __is_zero() &
                    is_output . __is_zero() & outpos . __is_zero() & is_ref . __is_zero() &
                    is_const . __is_zero() & is_copy . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return ivy::ptr< ivy::expr::__t >::__hash() (x . name) +
                        __bool::__hash() (x . is_input) +
                        vector__ivy__expr::domain::__t::__hash() (x . inpos) +
                        __bool::__hash() (x . is_output) +
                        vector__ivy__expr::domain::__t::__hash() (x . outpos) +
                        __bool::__hash() (x . is_ref) + __bool::__hash() (x . is_const) +
                        __bool::__hash() (x . is_copy);
                }
            };
            
        };
        
    }
    
}
namespace vector__ivy__prototype_argument
{
    namespace domain
    {
        struct __t : ivy::native_unsigned< size_t >
        {
            vector__ivy__prototype_argument::domain::__t next () const;
            
            vector__ivy__prototype_argument::domain::__t prev () const;
            
             __t () {}
             __t  (long long value) : ivy::native_unsigned< size_t > (value) {}
             __t  (const ivy::native_unsigned< size_t > &value) :
                ivy::native_unsigned< size_t > (value) {}
             operator ivy::native_unsigned< size_t > () const {
                return (*this);
            }
        };
        
    }
    
}
namespace vector__ivy__prototype_argument
{
    struct __t
    {
        ivy::vector< ivy::prototype_argument::__t,vector__ivy__prototype_argument::domain::__t >
            value;
        
        vector__ivy__prototype_argument::domain::__t end;
        
        vector__ivy__prototype_argument::domain::__t begin () const;
        
        void set  (const vector__ivy__prototype_argument::domain::__t &i,const ivy::prototype_argument::__t
            &v);
        
        void append  (const ivy::prototype_argument::__t &c);
        
        void extend  (const vector__ivy__prototype_argument::__t &x);
        
        void resize  (const vector__ivy__prototype_argument::domain::__t &end);
        
        ivy::prototype_argument::__t back () const;
        
        void pop_back ();
        
        vector__ivy__prototype_argument::__t segment  (const vector__ivy__prototype_argument::domain::__t
            &beg,const vector__ivy__prototype_argument::domain::__t &en) const;
        
        void reverse ();
        
         __t () {}
         __t  (long long value) {}
         operator std::size_t () const {
            return 0;
        }
        static bool __is_seq () {
            return false;
        }
        ivy::native_bool operator ==  (const __t &other) const
        {
            return value == other . value & end == other . end;
        }
        ivy::native_bool operator !=  (const __t &other) const {
            return ! ((*this) == other);
        }
        bool __is_zero () const {
            return value . __is_zero() & end . __is_zero();
        }
        struct __hash
        {
            std::size_t operator ()  (const __t &x) const
            {
                return
                    ivy::vector< ivy::prototype_argument::__t,vector__ivy__prototype_argument::domain::__t >::__hash()
                        (x . value) +
                    vector__ivy__prototype_argument::domain::__t::__hash() (x . end);
            }
        };
        
    };
    
}
namespace vector__ivy__prototype_argument
{
    vector__ivy__prototype_argument::__t empty ();
    
}
namespace ivy
{
    namespace prototype
    {
        struct __t
        {
            vector__ivy__prototype_argument::__t args;
            
            __bool has_ret;
            
            ivy::prototype_argument::__t ret;
            
            __bool any_non_const_ref () const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return args == other . args & has_ret == other . has_ret & ret == other . ret;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const
            {
                return args . __is_zero() & has_ret . __is_zero() & ret . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return vector__ivy__prototype_argument::__t::__hash() (x . args) +
                        __bool::__hash() (x . has_ret) +
                        ivy::prototype_argument::__t::__hash() (x . ret);
                }
            };
            
        };
        
    }
    
}
namespace ivy
{
    namespace actdc
    {
        struct __t : ivy::decl::__t
        {
            ivy::ptr< ivy::expr::__t > name;
            
            ivy::action_kind::__t kind;
            
            vector__ivy__expr::__t inputs;
            
            vector__ivy__expr::__t outputs;
            
            __bool has_body;
            
            ivy::ptr< ivy::stmt::__t > body;
            
            ivy::ptr< annot::__t > ann;
            
            __bool has_proto;
            
            ivy::prototype::__t proto;
            
            void encode  (pretty::__t &b,const priority::__t &prio) const;
            
            
            // A member is a action of the form `action type.member(x:type,...)`
            
            __bool is_member () const;
            
            
            // If this is a member action, return the type it is a member of.
            
            ivy::ptr< ivy::ident::__t > member_type () const;
            
            ivy::ptr< ivy::stmt::__t > get_body () const;
            
            void flat  (ivy::flatst::__t &st) const;
            
            void flat_int  (ivy::flatst::__t &st,ivy::actdc::__t &res) const;
            
            void defd  (ivy::flatst::__t &st) const;
            
            void build_global_types  (ivy::global_types::__t &st) const;
            
            ivy::prototype::__t get_proto  (const ivy::global_types::__t &gl,const ivy::subtypes::__t
                &st) const;
            
            void typeinfer  (ivy::typeinferst::__t &st,ivy::ptr< ivy::decl::__t > &res) const;
            
            void typeinfer_int  (ivy::typeinferst::__t &st,ivy::actdc::__t &res) const;
            
            void record_prototypes  (ivy::tocppst::__t &st) const;
            
            
            // Here, we translate an Ivy action declaration to a C++
            // function declaration. The C++ function declarations depends
            // on the action prototype.  If the action is a member action,
            // we drop the first input and replace it with `*this`.
            
            void to_cpp  (ivy::tocppst::__t &st,ivy::ptr< cpp::decl::__t > &resd) const;
            
            
            // Here, we register actions as members of types. These will be emitted
            // as members of the corresponding C++ class. 
            
            void reg_member  (ivy::tocppst::__t &st) const;
            
            
            // An action declaration is not emitted if it is a member and
            // does not have a body. External actions are never emitted.
            
            __bool emitted  (const ivy::tocppst::__t &st) const;
            
            
            // If a virtual action has `this` as an in-out parameter, we don't have an appropriate
            // prototype. The easiest way to handle this is to eliminate the in-out parameter by
            // replacing the output parameter with a fresh name and copying the value. For example,
            // suppose we have this action:
            //
            //     action t.f(s:t,...) returns (s:t,...) { ... }
            //
            // We replace this by the following equivalent action:
            //
            //     action t.f(__this:t,...) returns (s:t,...) { s := __this; ... }
            //
            // This results in a copy of `s` that might be unnecessary if its value is dead. However,
            // it gets us aroud the problem that assigning a value of a subtype to `*this` will result
            // in the value being sliced.
            
            ivy::ptr< ivy::decl::__t > fix_action  (const ivy::tocppst::__t &st) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return name == other . name & kind == other . kind & inputs == other . inputs &
                    outputs == other . outputs & has_body == other . has_body & body == other . body
                    & ann == other . ann & has_proto == other . has_proto & proto == other . proto;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const
            {
                return name . __is_zero() & kind . __is_zero() & inputs . __is_zero() &
                    outputs . __is_zero() & has_body . __is_zero() & body . __is_zero() &
                    ann . __is_zero() & has_proto . __is_zero() & proto . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return ivy::ptr< ivy::expr::__t >::__hash() (x . name) +
                        ivy::action_kind::__t::__hash() (x . kind) +
                        vector__ivy__expr::__t::__hash() (x . inputs) +
                        vector__ivy__expr::__t::__hash() (x . outputs) +
                        __bool::__hash() (x . has_body) +
                        ivy::ptr< ivy::stmt::__t >::__hash() (x . body) +
                        ivy::ptr< annot::__t >::__hash() (x . ann) +
                        __bool::__hash() (x . has_proto) + ivy::prototype::__t::__hash() (x . proto);
                }
            };
            
            virtual ivy::ptr< ivy::decl::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace ivy
{
    namespace actdc
    {
        ivy::ptr< ivy::decl::__t > make  (const ivy::ptr< ivy::expr::__t > &name,const
            vector__ivy__expr::__t &inputs,const vector__ivy__expr::__t &outputs,const __bool &has_body,const
            ivy::ptr< ivy::stmt::__t > &body);
        
    }
    
}
namespace ivy
{
    namespace ident_set
    {
        struct rec
        {
            __bool full;
            
            __bool val;
            
             rec () {}
             rec  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const rec &other) const
            {
                return full == other . full & val == other . val;
            }
            ivy::native_bool operator !=  (const rec &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return full . __is_zero() & val . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const rec &x) const
                {
                    return __bool::__hash() (x . full) + __bool::__hash() (x . val);
                }
            };
            
        };
        
    }
    
}
namespace ivy
{
    namespace ident_set
    {
        struct __t
        {
            ivy::vector< ivy::ident_set::rec,ivy::ptr< ivy::ident::__t > > map;
            
            
            // mutate a map a so that x in maps to y
            
            void set  (const ivy::ptr< ivy::ident::__t > &x,const __bool &y);
            
            
            // get the value y such that x maps to z in a, else
            // leave y unchanged.
            
            void get  (const ivy::ptr< ivy::ident::__t > &x,__bool &y) const;
            
            
            // return true if x maps to some value
            
            __bool mem  (const ivy::ptr< ivy::ident::__t > &x) const;
            
            
            // remove a key x from the map
            
            void remove  (const ivy::ptr< ivy::ident::__t > &x);
            
            __bool value  (const ivy::ptr< ivy::ident::__t > &x) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const {
                return map == other . map;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return map . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return
                        ivy::vector< ivy::ident_set::rec,ivy::ptr< ivy::ident::__t > >::__hash() (x
                            . map);
                }
            };
            
        };
        
    }
    
}
// return an empty map
namespace ivy
{
    namespace ident_set
    {
        ivy::ident_set::__t empty ();
        
    }
    
}
namespace ivy
{
    namespace colon
    {
        ivy::ptr< ivy::expr::__t > make  (const ivy::ptr< ivy::expr::__t > &lhs,const ivy::ptr< ivy::expr::__t >
            &rhs,const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace ivy
{
    namespace colon
    {
        ivy::ptr< ivy::expr::__t > fold_left  (const vector__ivy__expr::__t &args,const ivy::ptr< annot::__t >
            &ann);
        
    }
    
}
namespace ivy
{
    namespace colon
    {
        vector__ivy__expr::__t unfold_left  (const ivy::ptr< ivy::expr::__t > &s);
        
    }
    
}
namespace ivy
{
    namespace arrow
    {
        ivy::ptr< ivy::expr::__t > make  (const ivy::ptr< ivy::expr::__t > &lhs,const ivy::ptr< ivy::expr::__t >
            &rhs,const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace ivy
{
    namespace arrow
    {
        ivy::ptr< ivy::expr::__t > fold_left  (const vector__ivy__expr::__t &args,const ivy::ptr< annot::__t >
            &ann);
        
    }
    
}
namespace ivy
{
    namespace arrow
    {
        vector__ivy__expr::__t unfold_left  (const ivy::ptr< ivy::expr::__t > &s);
        
    }
    
}
namespace ivy
{
    namespace castop
    {
        ivy::ptr< ivy::expr::__t > make  (const ivy::ptr< ivy::expr::__t > &arg,const ivy::ptr< annot::__t >
            &ann);
        
    }
    
}
namespace ivy
{
    namespace equals
    {
        ivy::ptr< ivy::expr::__t > make  (const ivy::ptr< ivy::expr::__t > &lhs,const ivy::ptr< ivy::expr::__t >
            &rhs,const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace ivy
{
    namespace equals
    {
        ivy::ptr< ivy::expr::__t > fold_left  (const vector__ivy__expr::__t &args,const ivy::ptr< annot::__t >
            &ann);
        
    }
    
}
namespace ivy
{
    namespace equals
    {
        vector__ivy__expr::__t unfold_left  (const ivy::ptr< ivy::expr::__t > &s);
        
    }
    
}
namespace ivy
{
    namespace notequals
    {
        ivy::ptr< ivy::expr::__t > make  (const ivy::ptr< ivy::expr::__t > &lhs,const ivy::ptr< ivy::expr::__t >
            &rhs,const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace ivy
{
    namespace notequals
    {
        ivy::ptr< ivy::expr::__t > fold_left  (const vector__ivy__expr::__t &args,const ivy::ptr< annot::__t >
            &ann);
        
    }
    
}
namespace ivy
{
    namespace notequals
    {
        vector__ivy__expr::__t unfold_left  (const ivy::ptr< ivy::expr::__t > &s);
        
    }
    
}
namespace ivy
{
    namespace __not
    {
        ivy::ptr< ivy::expr::__t > make  (const ivy::ptr< ivy::expr::__t > &arg,const ivy::ptr< annot::__t >
            &ann);
        
    }
    
}
namespace ivy
{
    namespace ite
    {
        ivy::ptr< ivy::expr::__t > make  (const ivy::ptr< ivy::expr::__t > &arg0,const ivy::ptr< ivy::expr::__t >
            &arg1,const ivy::ptr< ivy::expr::__t > &arg2,const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace ivy
{
    namespace varv
    {
        ivy::ptr< ivy::expr::__t > make  (const ivy::ptr< ivy::expr::__t > &arg,const ivy::ptr< annot::__t >
            &ann);
        
    }
    
}
namespace ivy
{
    namespace isaop
    {
        ivy::ptr< ivy::expr::__t > make  (const ivy::ptr< ivy::expr::__t > &lhs,const ivy::ptr< ivy::expr::__t >
            &rhs,const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace ivy
{
    namespace isaop
    {
        ivy::ptr< ivy::expr::__t > fold_left  (const vector__ivy__expr::__t &args,const ivy::ptr< annot::__t >
            &ann);
        
    }
    
}
namespace ivy
{
    namespace isaop
    {
        vector__ivy__expr::__t unfold_left  (const ivy::ptr< ivy::expr::__t > &s);
        
    }
    
}
namespace ivy
{
    namespace varst
    {
        struct __t : ivy::stmt::__t
        {
            ivy::ptr< ivy::expr::__t > name;
            
            ivy::ptr< annot::__t > ann;
            
            void encode  (pretty::__t &b,const priority::__t &prio) const;
            
            void encode_int  (pretty::__t &b,const priority::__t &prio) const;
            
            ivy::ptr< ivy::expr::__t > get_expr () const;
            
            void flat  (ivy::flatst::__t &st,ivy::ptr< ivy::stmt::__t > &res) const;
            
            void flat_int  (ivy::flatst::__t &st,ivy::varst::__t &res) const;
            
            ivy::ptr< ivy::ident::__t > get_ident () const;
            
            
            //        instantiate generic_to_cpp(ivy.varst,cpp.varst,cpp.stmt)
            
            void to_cpp  (ivy::tocppst::__t &st,ivy::ptr< cpp::stmt::__t > &resd) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return name == other . name & ann == other . ann;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return name . __is_zero() & ann . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return ivy::ptr< ivy::expr::__t >::__hash() (x . name) +
                        ivy::ptr< annot::__t >::__hash() (x . ann);
                }
            };
            
            virtual ivy::ptr< ivy::stmt::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace ivy
{
    namespace varst
    {
        ivy::ptr< ivy::stmt::__t > make  (const ivy::ptr< ivy::expr::__t > &name,const ivy::ptr< annot::__t >
            &ann);
        
    }
    
}
namespace ivy
{
    namespace pragmast
    {
        struct __t : ivy::stmt::__t
        {
            ivy::ptr< ivy::expr::__t > prg;
            
            ivy::ptr< annot::__t > ann;
            
            void encode  (pretty::__t &b,const priority::__t &prio) const;
            
            void encode_int  (pretty::__t &b,const priority::__t &prio) const;
            
            ivy::ptr< ivy::expr::__t > get_expr () const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return prg == other . prg & ann == other . ann;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return prg . __is_zero() & ann . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return ivy::ptr< ivy::expr::__t >::__hash() (x . prg) +
                        ivy::ptr< annot::__t >::__hash() (x . ann);
                }
            };
            
            virtual ivy::ptr< ivy::stmt::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace ivy
{
    namespace pragmast
    {
        ivy::ptr< ivy::stmt::__t > make  (const ivy::ptr< ivy::expr::__t > &prg,const ivy::ptr< annot::__t >
            &ann);
        
    }
    
}
namespace ivy
{
    namespace stmt
    {
        void parse_stmt_term  (pstate::__t &st);
        
    }
    
}
// allow to omit final semicolon
namespace ivy
{
    namespace stmt
    {
        void parse_lang_stmt  (pstate::__t &st,const priority::__t &prio,ivy::ptr< ivy::stmt::__t >
            &res);
        
    }
    
}
namespace vector__ivy__decl
{
    namespace domain
    {
        struct __t : ivy::native_unsigned< size_t >
        {
            vector__ivy__decl::domain::__t next () const;
            
            vector__ivy__decl::domain::__t prev () const;
            
             __t () {}
             __t  (long long value) : ivy::native_unsigned< size_t > (value) {}
             __t  (const ivy::native_unsigned< size_t > &value) :
                ivy::native_unsigned< size_t > (value) {}
             operator ivy::native_unsigned< size_t > () const {
                return (*this);
            }
        };
        
    }
    
}
namespace vector__ivy__decl
{
    struct __t
    {
        ivy::vector< ivy::ptr< ivy::decl::__t >,vector__ivy__decl::domain::__t > value;
        
        vector__ivy__decl::domain::__t end;
        
        vector__ivy__decl::domain::__t begin () const;
        
        void set  (const vector__ivy__decl::domain::__t &i,const ivy::ptr< ivy::decl::__t > &v);
        
        void append  (const ivy::ptr< ivy::decl::__t > &c);
        
        void extend  (const vector__ivy__decl::__t &x);
        
        void resize  (const vector__ivy__decl::domain::__t &end);
        
        ivy::ptr< ivy::decl::__t > back () const;
        
        void pop_back ();
        
        vector__ivy__decl::__t segment  (const vector__ivy__decl::domain::__t &beg,const
            vector__ivy__decl::domain::__t &en) const;
        
        void reverse ();
        
         __t () {}
         __t  (long long value) {}
         operator std::size_t () const {
            return 0;
        }
        static bool __is_seq () {
            return false;
        }
        ivy::native_bool operator ==  (const __t &other) const
        {
            return value == other . value & end == other . end;
        }
        ivy::native_bool operator !=  (const __t &other) const {
            return ! ((*this) == other);
        }
        bool __is_zero () const {
            return value . __is_zero() & end . __is_zero();
        }
        struct __hash
        {
            std::size_t operator ()  (const __t &x) const
            {
                return
                    ivy::vector< ivy::ptr< ivy::decl::__t >,vector__ivy__decl::domain::__t >::__hash()
                        (x . value) + vector__ivy__decl::domain::__t::__hash() (x . end);
            }
        };
        
    };
    
}
namespace vector__ivy__decl
{
    vector__ivy__decl::__t empty ();
    
}
namespace ivy
{
    namespace groupdc
    {
        struct __t : ivy::decl::__t
        {
            vector__ivy__decl::__t decls;
            
            ivy::ptr< annot::__t > ann;
            
            void encode  (pretty::__t &b,const priority::__t &prio) const;
            
            void flat  (ivy::flatst::__t &st) const;
            
            void defd  (ivy::flatst::__t &st) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return decls == other . decls & ann == other . ann;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return decls . __is_zero() & ann . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return vector__ivy__decl::__t::__hash() (x . decls) +
                        ivy::ptr< annot::__t >::__hash() (x . ann);
                }
            };
            
            virtual ivy::ptr< ivy::decl::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace ivy
{
    namespace groupdc
    {
        ivy::ptr< ivy::decl::__t > make  (const vector__ivy__decl::__t &decls);
        
    }
    
}
namespace ivy
{
    namespace typespec
    {
        struct __t
        {
            virtual void encode  (pretty::__t &b,const priority::__t &prio) const;
            
            virtual vector__ivy__expr::__t get_elems () const;
            
            virtual void flat  (ivy::flatst::__t &st,ivy::ptr< ivy::typespec::__t > &res) const;
            
            virtual void defd  (ivy::flatst::__t &st,const ivy::ptr< ivy::ident::__t > &id) const;
            
            virtual void to_destrs  (ivy::flatst::__t &st,const ivy::ptr< ivy::expr::__t > &ty)
                const;
            
            virtual void auto_flat_spec  (ivy::flatst::__t &st,const ivy::ptr< ivy::expr::__t > &ty)
                const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const {
                return true;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return true;
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const {
                    return 0;
                }
            };
            
            virtual ivy::ptr< __t > __upcast () const {
                return (*this);
            }
            virtual  ~__t () {}
        };
        
    }
    
}
namespace ivy
{
    namespace typespec
    {
        void parse  (pstate::__t &st,const priority::__t &prio,ivy::ptr< ivy::typespec::__t > &res);
        
    }
    
}
namespace ivy
{
    namespace curly_tup
    {
        void encode  (const vector__ivy__expr::__t &s,pretty::__t &b,const priority::__t &prio);
        
    }
    
}
namespace ivy
{
    namespace curly_tup
    {
        void parse  (pstate::__t &st,const priority::__t &prio,vector__ivy__expr::__t &res);
        
    }
    
}
namespace ivy
{
    namespace enumspec
    {
        struct __t : ivy::typespec::__t
        {
            vector__ivy__expr::__t constructors;
            
            ivy::ptr< annot::__t > ann;
            
            void encode  (pretty::__t &b,const priority::__t &prio) const;
            
            vector__ivy__expr::__t get_elems () const;
            
            void flat  (ivy::flatst::__t &st,ivy::ptr< ivy::typespec::__t > &res) const;
            
            void defd  (ivy::flatst::__t &st,const ivy::ptr< ivy::ident::__t > &id) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return constructors == other . constructors & ann == other . ann;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return constructors . __is_zero() & ann . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return vector__ivy__expr::__t::__hash() (x . constructors) +
                        ivy::ptr< annot::__t >::__hash() (x . ann);
                }
            };
            
            virtual ivy::ptr< ivy::typespec::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace ivy
{
    namespace structspec
    {
        struct __t : ivy::typespec::__t
        {
            vector__ivy__expr::__t destructors;
            
            ivy::ptr< annot::__t > ann;
            
            void encode  (pretty::__t &b,const priority::__t &prio) const;
            
            vector__ivy__expr::__t get_elems () const;
            
            void defd  (ivy::flatst::__t &st,const ivy::ptr< ivy::ident::__t > &id) const;
            
            void auto_flat_spec  (ivy::flatst::__t &st,const ivy::ptr< ivy::expr::__t > &ty) const;
            
            void to_destrs  (ivy::flatst::__t &st,const ivy::ptr< ivy::expr::__t > &ty) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return destructors == other . destructors & ann == other . ann;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return destructors . __is_zero() & ann . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return vector__ivy__expr::__t::__hash() (x . destructors) +
                        ivy::ptr< annot::__t >::__hash() (x . ann);
                }
            };
            
            virtual ivy::ptr< ivy::typespec::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace ivy
{
    namespace typedc
    {
        struct __t : ivy::decl::__t
        {
            ivy::ptr< ivy::expr::__t > sort;
            
            __bool has_super;
            
            ivy::ptr< ivy::expr::__t > super;
            
            __bool has_spec;
            
            ivy::ptr< ivy::typespec::__t > spec;
            
            ivy::ptr< annot::__t > ann;
            
            void encode  (pretty::__t &b,const priority::__t &prio) const;
            
            void flat  (ivy::flatst::__t &st) const;
            
            void defd  (ivy::flatst::__t &st) const;
            
            void build_subtypes  (ivy::subtypes::__t &st) const;
            
            void build_global_types  (ivy::global_types::__t &st) const;
            
            void to_cpp  (ivy::tocppst::__t &st,ivy::ptr< cpp::decl::__t > &resd) const;
            
            void reg_member  (ivy::tocppst::__t &st) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return sort == other . sort & has_super == other . has_super & super == other .
                    super & has_spec == other . has_spec & spec == other . spec & ann == other . ann;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const
            {
                return sort . __is_zero() & has_super . __is_zero() & super . __is_zero() &
                    has_spec . __is_zero() & spec . __is_zero() & ann . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return ivy::ptr< ivy::expr::__t >::__hash() (x . sort) +
                        __bool::__hash() (x . has_super) +
                        ivy::ptr< ivy::expr::__t >::__hash() (x . super) +
                        __bool::__hash() (x . has_spec) +
                        ivy::ptr< ivy::typespec::__t >::__hash() (x . spec) +
                        ivy::ptr< annot::__t >::__hash() (x . ann);
                }
            };
            
            virtual ivy::ptr< ivy::decl::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace ivy
{
    namespace typedc
    {
        ivy::ptr< ivy::decl::__t > make  (const ivy::ptr< ivy::expr::__t > &sort);
        
    }
    
}
namespace ivy
{
    namespace vardc
    {
        struct __t : ivy::decl::__t
        {
            ivy::ptr< ivy::expr::__t > typing;
            
            __bool is_destructor;
            
            __bool has_def;
            
            ivy::ptr< ivy::expr::__t > def;
            
            ivy::ptr< annot::__t > ann;
            
            void encode  (pretty::__t &b,const priority::__t &prio) const;
            
            void flat  (ivy::flatst::__t &st) const;
            
            void flat_int  (ivy::flatst::__t &st,ivy::vardc::__t &res) const;
            
            void defd  (ivy::flatst::__t &st) const;
            
            void build_global_types  (ivy::global_types::__t &st) const;
            
            void typeinfer  (ivy::typeinferst::__t &st,ivy::ptr< ivy::decl::__t > &res) const;
            
            void typeinfer_int  (ivy::typeinferst::__t &st,ivy::vardc::__t &res) const;
            
            ivy::ptr< ivy::decl::__t > func_to_action () const;
            
            void to_cpp  (ivy::tocppst::__t &st,ivy::ptr< cpp::decl::__t > &resd) const;
            
            
            // A type destructor is translated to a data member of the class;
            
            void reg_member  (ivy::tocppst::__t &st) const;
            
            
            // An variable declaration is not emitted if it is a destructor.
            
            __bool emitted  (const ivy::tocppst::__t &st) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return typing == other . typing & is_destructor == other . is_destructor & has_def
                    == other . has_def & def == other . def & ann == other . ann;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const
            {
                return typing . __is_zero() & is_destructor . __is_zero() & has_def . __is_zero() &
                    def . __is_zero() & ann . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return ivy::ptr< ivy::expr::__t >::__hash() (x . typing) +
                        __bool::__hash() (x . is_destructor) + __bool::__hash() (x . has_def) +
                        ivy::ptr< ivy::expr::__t >::__hash() (x . def) +
                        ivy::ptr< annot::__t >::__hash() (x . ann);
                }
            };
            
            virtual ivy::ptr< ivy::decl::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace ivy
{
    namespace vardc
    {
        ivy::ptr< ivy::decl::__t > make  (const ivy::ptr< ivy::expr::__t > &typing,const __bool &is_destructor,const
            ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace ivy
{
    namespace header
    {
        struct __t : ivy::decl::__t
        {
            str::__t filename;
            
            ivy::ptr< annot::__t > ann;
            
            void encode  (pretty::__t &b,const priority::__t &prio) const;
            
            void flat  (ivy::flatst::__t &st) const;
            
            void flat_int  (ivy::flatst::__t &st,ivy::header::__t &res) const;
            
            void to_cpp  (ivy::tocppst::__t &st,ivy::ptr< cpp::decl::__t > &res) const;
            
            void to_cpp_int  (ivy::tocppst::__t &st,cpp::header::__t &res) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return filename == other . filename & ann == other . ann;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return filename . __is_zero() & ann . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return str::__t::__hash() (x . filename) +
                        ivy::ptr< annot::__t >::__hash() (x . ann);
                }
            };
            
            virtual ivy::ptr< ivy::decl::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace ivy
{
    namespace header
    {
        ivy::ptr< ivy::decl::__t > make  (const str::__t &filename);
        
    }
    
}
namespace ivy
{
    namespace interpdc
    {
        struct __t : ivy::decl::__t
        {
            ivy::ptr< ivy::expr::__t > itype;
            
            ivy::ptr< ivy::expr::__t > ctype;
            
            ivy::ptr< annot::__t > ann;
            
            void encode  (pretty::__t &b,const priority::__t &prio) const;
            
            void flat  (ivy::flatst::__t &st) const;
            
            void flat_int  (ivy::flatst::__t &st,ivy::interpdc::__t &res) const;
            
            
            // An interpret declararation determines the C++ superclass of the type.
            
            void reg_member  (ivy::tocppst::__t &st) const;
            
            
            // Interpret declarations are never emitted
            
            __bool emitted  (const ivy::tocppst::__t &st) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return itype == other . itype & ctype == other . ctype & ann == other . ann;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const
            {
                return itype . __is_zero() & ctype . __is_zero() & ann . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return ivy::ptr< ivy::expr::__t >::__hash() (x . itype) +
                        ivy::ptr< ivy::expr::__t >::__hash() (x . ctype) +
                        ivy::ptr< annot::__t >::__hash() (x . ann);
                }
            };
            
            virtual ivy::ptr< ivy::decl::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace ivy
{
    namespace interpdc
    {
        ivy::ptr< ivy::decl::__t > make  (const ivy::ptr< ivy::expr::__t > &itype,const ivy::ptr< ivy::expr::__t >
            &ctype,const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace ivy
{
    namespace includedc
    {
        struct __t : ivy::decl::__t
        {
            ivy::ptr< ivy::expr::__t > file;
            
            ivy::ptr< annot::__t > ann;
            
            void encode  (pretty::__t &b,const priority::__t &prio) const;
            
            ivy::ptr< ivy::expr::__t > get_expr () const;
            
            ivy::ptr< annot::__t > get_ann () const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return file == other . file & ann == other . ann;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return file . __is_zero() & ann . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return ivy::ptr< ivy::expr::__t >::__hash() (x . file) +
                        ivy::ptr< annot::__t >::__hash() (x . ann);
                }
            };
            
            virtual ivy::ptr< ivy::decl::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace ivy
{
    namespace includedc
    {
        ivy::ptr< ivy::decl::__t > make  (const ivy::ptr< ivy::expr::__t > &file,const ivy::ptr< annot::__t >
            &ann);
        
    }
    
}
namespace ivy
{
    namespace moduledc
    {
        struct __t : ivy::decl::__t
        {
            ivy::ptr< ivy::expr::__t > name;
            
            vector__ivy__expr::__t prms;
            
            ivy::ptr< ivy::decl::__t > body;
            
            ivy::ptr< annot::__t > ann;
            
            void encode  (pretty::__t &b,const priority::__t &prio) const;
            
            void defd  (ivy::flatst::__t &st) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return name == other . name & prms == other . prms & body == other . body & ann ==
                    other . ann;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const
            {
                return name . __is_zero() & prms . __is_zero() & body . __is_zero() &
                    ann . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return ivy::ptr< ivy::expr::__t >::__hash() (x . name) +
                        vector__ivy__expr::__t::__hash() (x . prms) +
                        ivy::ptr< ivy::decl::__t >::__hash() (x . body) +
                        ivy::ptr< annot::__t >::__hash() (x . ann);
                }
            };
            
            virtual ivy::ptr< ivy::decl::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace ivy
{
    namespace moduledc
    {
        ivy::ptr< ivy::decl::__t > make  (const ivy::ptr< ivy::expr::__t > &name,const
            vector__ivy__expr::__t &prms,const ivy::ptr< ivy::decl::__t > &body);
        
    }
    
}
namespace ivy
{
    namespace instantiatedc
    {
        struct __t : ivy::decl::__t
        {
            ivy::ptr< ivy::expr::__t > name;
            
            vector__ivy__expr::__t prms;
            
            ivy::ptr< annot::__t > ann;
            
            void encode  (pretty::__t &b,const priority::__t &prio) const;
            
            void setup  (ivy::flatst::__t &st,const __bool &check,ivy::moduledc::__t &mod) const;
            
            void flat  (ivy::flatst::__t &st) const;
            
            void defd  (ivy::flatst::__t &st) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return name == other . name & prms == other . prms & ann == other . ann;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const
            {
                return name . __is_zero() & prms . __is_zero() & ann . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return ivy::ptr< ivy::expr::__t >::__hash() (x . name) +
                        vector__ivy__expr::__t::__hash() (x . prms) +
                        ivy::ptr< annot::__t >::__hash() (x . ann);
                }
            };
            
            virtual ivy::ptr< ivy::decl::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace ivy
{
    namespace instantiatedc
    {
        ivy::ptr< ivy::decl::__t > make  (const ivy::ptr< ivy::expr::__t > &name,const
            vector__ivy__expr::__t &prms,const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace ivy
{
    namespace objectdc
    {
        struct __t : ivy::decl::__t
        {
            ivy::ptr< ivy::expr::__t > name;
            
            ivy::ptr< ivy::decl::__t > body;
            
            ivy::ptr< annot::__t > ann;
            
            void encode  (pretty::__t &b,const priority::__t &prio) const;
            
            void flat  (ivy::flatst::__t &st) const;
            
            void defd  (ivy::flatst::__t &st) const;
            
            
            // An object declaration corresponds to a namespace in C++. However,
            // we emit namespace declarations for the object members, not here.
            // Here, we just record the object identifiers, so we know when they
            // clash with type identifiers.
            
            void reg_member  (ivy::tocppst::__t &st) const;
            
            
            // Object declarations are never emitted
            
            __bool emitted  (const ivy::tocppst::__t &st) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return name == other . name & body == other . body & ann == other . ann;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const
            {
                return name . __is_zero() & body . __is_zero() & ann . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return ivy::ptr< ivy::expr::__t >::__hash() (x . name) +
                        ivy::ptr< ivy::decl::__t >::__hash() (x . body) +
                        ivy::ptr< annot::__t >::__hash() (x . ann);
                }
            };
            
            virtual ivy::ptr< ivy::decl::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace ivy
{
    namespace objectdc
    {
        ivy::ptr< ivy::decl::__t > make  (const ivy::ptr< ivy::expr::__t > &name,const ivy::ptr< ivy::decl::__t >
            &body,const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace ivy
{
    namespace instancedc
    {
        struct __t : ivy::decl::__t
        {
            ivy::ptr< ivy::expr::__t > objname;
            
            ivy::ptr< ivy::expr::__t > modname;
            
            vector__ivy__expr::__t prms;
            
            __bool is_auto;
            
            ivy::ptr< annot::__t > ann;
            
            void encode  (pretty::__t &b,const priority::__t &prio) const;
            
            ivy::ptr< ivy::decl::__t > desugar () const;
            
            void flat  (ivy::flatst::__t &st) const;
            
            void defd  (ivy::flatst::__t &st) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return objname == other . objname & modname == other . modname & prms == other .
                    prms & is_auto == other . is_auto & ann == other . ann;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const
            {
                return objname . __is_zero() & modname . __is_zero() & prms . __is_zero() &
                    is_auto . __is_zero() & ann . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return ivy::ptr< ivy::expr::__t >::__hash() (x . objname) +
                        ivy::ptr< ivy::expr::__t >::__hash() (x . modname) +
                        vector__ivy__expr::__t::__hash() (x . prms) + __bool::__hash() (x . is_auto)
                        + ivy::ptr< annot::__t >::__hash() (x . ann);
                }
            };
            
            virtual ivy::ptr< ivy::decl::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace ivy
{
    namespace instancedc
    {
        ivy::ptr< ivy::decl::__t > make  (const ivy::ptr< ivy::expr::__t > &objname,const ivy::ptr< ivy::expr::__t >
            &modname,const vector__ivy__expr::__t &prms);
        
    }
    
}
namespace ivy
{
    namespace initdc
    {
        struct __t : ivy::decl::__t
        {
            ivy::ptr< ivy::stmt::__t > body;
            
            ivy::ptr< annot::__t > ann;
            
            void encode  (pretty::__t &b,const priority::__t &prio) const;
            
            ivy::ptr< ivy::stmt::__t > get_body () const;
            
            void flat  (ivy::flatst::__t &st) const;
            
            void flat_int  (ivy::flatst::__t &st,ivy::initdc::__t &res) const;
            
            void typeinfer  (ivy::typeinferst::__t &st,ivy::ptr< ivy::decl::__t > &res) const;
            
            void typeinfer_int  (ivy::typeinferst::__t &st,ivy::initdc::__t &res) const;
            
            __bool emitted  (const ivy::tocppst::__t &st) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return body == other . body & ann == other . ann;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return body . __is_zero() & ann . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return ivy::ptr< ivy::stmt::__t >::__hash() (x . body) +
                        ivy::ptr< annot::__t >::__hash() (x . ann);
                }
            };
            
            virtual ivy::ptr< ivy::decl::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace ivy
{
    void parse_action  (pstate::__t &st,const priority::__t &prio,const ivy::action_kind::__t &kind,ivy::ptr< ivy::decl::__t >
        &res);
    
}
namespace ivy
{
    namespace decl
    {
        void parse  (pstate::__t &st,const priority::__t &prio,ivy::ptr< ivy::decl::__t > &res);
        
    }
    
}
namespace ivy
{
    namespace decl
    {
        void parse_list  (pstate::__t &st,const priority::__t &prio,vector__ivy__decl::__t &res);
        
    }
    
}
namespace ivy
{
    namespace version
    {
        struct __t
        {
            vector__pos::__t nums;
            
            void encode  (pretty::__t &b) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const {
                return nums == other . nums;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return nums . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return vector__pos::__t::__hash() (x . nums);
                }
            };
            
        };
        
    }
    
}
namespace ivy
{
    namespace version
    {
        void parse  (pstate::__t &st,const priority::__t &prio,ivy::version::__t &res);
        
    }
    
}
namespace ivy
{
    namespace prog
    {
        struct __t
        {
            ivy::version::__t vers;
            
            vector__ivy__decl::__t decls;
            
            str::__t enc () const;
            
            void encode  (pretty::__t &b,const priority::__t &prio) const;
            
            void flat ();
            
            ivy::subtypes::__t get_subtypes () const;
            
            ivy::global_types::__t get_global_types  (const __bool &curried) const;
            
            void typeinfer ();
            
            cpp::prog::__t to_cpp () const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return vers == other . vers & decls == other . decls;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return vers . __is_zero() & decls . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return ivy::version::__t::__hash() (x . vers) +
                        vector__ivy__decl::__t::__hash() (x . decls);
                }
            };
            
        };
        
    }
    
}
namespace ivy
{
    namespace prog
    {
        ivy::prog::__t dec  (const str::__t &s);
        
    }
    
}
namespace ivy
{
    namespace prog
    {
        str::__t encdec  (const str::__t &s);
        
    }
    
}
namespace ivy
{
    namespace prog
    {
        ivy::prog::__t make  (const vector__ivy__decl::__t &decls);
        
    }
    
}
// Note, the Ivy verison number is encoded in the first comment line
namespace ivy
{
    namespace prog
    {
        void parse_to  (pstate::__t &st,const priority::__t &prio,ivy::prog::__t &res);
        
    }
    
}
namespace ivy
{
    namespace prog
    {
        void parse  (pstate::__t &st,const priority::__t &prio,ivy::prog::__t &res);
        
    }
    
}
namespace ivy
{
    namespace error
    {
        struct __t
        {
            virtual void encode  (pretty::__t &b) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const {
                return true;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return true;
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const {
                    return 0;
                }
            };
            
            virtual ivy::ptr< __t > __upcast () const {
                return (*this);
            }
            virtual  ~__t () {}
        };
        
    }
    
}
namespace vector__ivy__error
{
    namespace domain
    {
        struct __t : ivy::native_unsigned< size_t >
        {
            vector__ivy__error::domain::__t next () const;
            
            vector__ivy__error::domain::__t prev () const;
            
             __t () {}
             __t  (long long value) : ivy::native_unsigned< size_t > (value) {}
             __t  (const ivy::native_unsigned< size_t > &value) :
                ivy::native_unsigned< size_t > (value) {}
             operator ivy::native_unsigned< size_t > () const {
                return (*this);
            }
        };
        
    }
    
}
namespace vector__ivy__error
{
    struct __t
    {
        ivy::vector< ivy::ptr< ivy::error::__t >,vector__ivy__error::domain::__t > value;
        
        vector__ivy__error::domain::__t end;
        
        vector__ivy__error::domain::__t begin () const;
        
        void set  (const vector__ivy__error::domain::__t &i,const ivy::ptr< ivy::error::__t > &v);
        
        void append  (const ivy::ptr< ivy::error::__t > &c);
        
        void extend  (const vector__ivy__error::__t &x);
        
        void resize  (const vector__ivy__error::domain::__t &end);
        
        ivy::ptr< ivy::error::__t > back () const;
        
        void pop_back ();
        
        vector__ivy__error::__t segment  (const vector__ivy__error::domain::__t &beg,const
            vector__ivy__error::domain::__t &en) const;
        
        void reverse ();
        
         __t () {}
         __t  (long long value) {}
         operator std::size_t () const {
            return 0;
        }
        static bool __is_seq () {
            return false;
        }
        ivy::native_bool operator ==  (const __t &other) const
        {
            return value == other . value & end == other . end;
        }
        ivy::native_bool operator !=  (const __t &other) const {
            return ! ((*this) == other);
        }
        bool __is_zero () const {
            return value . __is_zero() & end . __is_zero();
        }
        struct __hash
        {
            std::size_t operator ()  (const __t &x) const
            {
                return
                    ivy::vector< ivy::ptr< ivy::error::__t >,vector__ivy__error::domain::__t >::__hash()
                        (x . value) + vector__ivy__error::domain::__t::__hash() (x . end);
            }
        };
        
    };
    
}
namespace vector__ivy__error
{
    vector__ivy__error::__t empty ();
    
}
namespace ivy
{
    vector__ivy__error::__t errors;
    
}
// Reports an error and returns
namespace ivy
{
    void report_error  (const ivy::ptr< ivy::error::__t > &e,const ivy::ptr< annot::__t > &ann);
    
}
namespace ivy
{
    namespace type_clash
    {
        struct __t : ivy::error::__t
        {
            ivy::ptr< ivy::expr::__t > e;
            
            ivy::ptr< ivy::expr::__t > t1;
            
            ivy::ptr< ivy::expr::__t > t2;
            
            void encode  (pretty::__t &b) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return e == other . e & t1 == other . t1 & t2 == other . t2;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return e . __is_zero() & t1 . __is_zero() & t2 . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return ivy::ptr< ivy::expr::__t >::__hash() (x . e) +
                        ivy::ptr< ivy::expr::__t >::__hash() (x . t1) +
                        ivy::ptr< ivy::expr::__t >::__hash() (x . t2);
                }
            };
            
            virtual ivy::ptr< ivy::error::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace ivy
{
    namespace type_clash
    {
        ivy::type_clash::__t make  (const ivy::ptr< ivy::expr::__t > &e,const ivy::ptr< ivy::expr::__t >
            &t1,const ivy::ptr< ivy::expr::__t > &t2);
        
    }
    
}
namespace ivy
{
    namespace type_conversion
    {
        struct __t : ivy::error::__t
        {
            ivy::ptr< ivy::expr::__t > e;
            
            ivy::ptr< ivy::expr::__t > t1;
            
            ivy::ptr< ivy::expr::__t > t2;
            
            void encode  (pretty::__t &b) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return e == other . e & t1 == other . t1 & t2 == other . t2;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return e . __is_zero() & t1 . __is_zero() & t2 . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return ivy::ptr< ivy::expr::__t >::__hash() (x . e) +
                        ivy::ptr< ivy::expr::__t >::__hash() (x . t1) +
                        ivy::ptr< ivy::expr::__t >::__hash() (x . t2);
                }
            };
            
            virtual ivy::ptr< ivy::error::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace ivy
{
    namespace type_conversion
    {
        ivy::type_conversion::__t make  (const ivy::ptr< ivy::expr::__t > &e,const ivy::ptr< ivy::expr::__t >
            &t1,const ivy::ptr< ivy::expr::__t > &t2);
        
    }
    
}
namespace ivy
{
    namespace untyped
    {
        struct __t : ivy::error::__t
        {
            ivy::ptr< ivy::expr::__t > e;
            
            ivy::ptr< ivy::expr::__t > t1;
            
            void encode  (pretty::__t &b) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return e == other . e & t1 == other . t1;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return e . __is_zero() & t1 . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return ivy::ptr< ivy::expr::__t >::__hash() (x . e) +
                        ivy::ptr< ivy::expr::__t >::__hash() (x . t1);
                }
            };
            
            virtual ivy::ptr< ivy::error::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace ivy
{
    namespace untyped
    {
        ivy::untyped::__t make  (const ivy::ptr< ivy::expr::__t > &e,const ivy::ptr< ivy::expr::__t >
            &t1);
        
    }
    
}
namespace ivy
{
    namespace not_first_order
    {
        struct __t : ivy::error::__t
        {
            ivy::ptr< ivy::expr::__t > e;
            
            ivy::ptr< ivy::expr::__t > t1;
            
            void encode  (pretty::__t &b) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return e == other . e & t1 == other . t1;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return e . __is_zero() & t1 . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return ivy::ptr< ivy::expr::__t >::__hash() (x . e) +
                        ivy::ptr< ivy::expr::__t >::__hash() (x . t1);
                }
            };
            
            virtual ivy::ptr< ivy::error::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace ivy
{
    namespace not_first_order
    {
        ivy::not_first_order::__t make  (const ivy::ptr< ivy::expr::__t > &e,const ivy::ptr< ivy::expr::__t >
            &t1);
        
    }
    
}
namespace ivy
{
    namespace file_not_found
    {
        struct __t : ivy::error::__t
        {
            str::__t n;
            
            void encode  (pretty::__t &b) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const {
                return n == other . n;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return n . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const {
                    return str::__t::__hash() (x . n);
                }
            };
            
            virtual ivy::ptr< ivy::error::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace ivy
{
    namespace file_not_found
    {
        ivy::file_not_found::__t make  (const str::__t &n);
        
    }
    
}
namespace ivy
{
    namespace cannot_write
    {
        struct __t : ivy::error::__t
        {
            str::__t n;
            
            void encode  (pretty::__t &b) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const {
                return n == other . n;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return n . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const {
                    return str::__t::__hash() (x . n);
                }
            };
            
            virtual ivy::ptr< ivy::error::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace ivy
{
    namespace cannot_write
    {
        ivy::cannot_write::__t make  (const str::__t &n);
        
    }
    
}
namespace ivy
{
    namespace undefined
    {
        struct __t : ivy::error::__t
        {
            ivy::ptr< ivy::ident::__t > n;
            
            void encode  (pretty::__t &b) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const {
                return n == other . n;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return n . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return ivy::ptr< ivy::ident::__t >::__hash() (x . n);
                }
            };
            
            virtual ivy::ptr< ivy::error::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace ivy
{
    namespace undefined
    {
        ivy::undefined::__t make  (const ivy::ptr< ivy::ident::__t > &n);
        
    }
    
}
namespace ivy
{
    namespace redefining
    {
        struct __t : ivy::error::__t
        {
            ivy::ptr< ivy::ident::__t > n;
            
            ivy::ptr< annot::__t > ann;
            
            void encode  (pretty::__t &b) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return n == other . n & ann == other . ann;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return n . __is_zero() & ann . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return ivy::ptr< ivy::ident::__t >::__hash() (x . n) +
                        ivy::ptr< annot::__t >::__hash() (x . ann);
                }
            };
            
            virtual ivy::ptr< ivy::error::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace ivy
{
    namespace redefining
    {
        ivy::redefining::__t make  (const ivy::ptr< ivy::ident::__t > &n,const ivy::ptr< annot::__t >
            &ann);
        
    }
    
}
namespace ivy
{
    namespace wrong_number_params
    {
        struct __t : ivy::error::__t
        {
            vector__ivy__expr::domain::__t n;
            
            void encode  (pretty::__t &b) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const {
                return n == other . n;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return n . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return vector__ivy__expr::domain::__t::__hash() (x . n);
                }
            };
            
            virtual ivy::ptr< ivy::error::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace ivy
{
    namespace wrong_number_params
    {
        ivy::wrong_number_params::__t make  (const vector__ivy__expr::domain::__t &n);
        
    }
    
}
namespace ivy
{
    namespace syntax_error
    {
        struct __t : ivy::error::__t
        {
            str::__t tok;
            
            void encode  (pretty::__t &b) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const {
                return tok == other . tok;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return tok . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const {
                    return str::__t::__hash() (x . tok);
                }
            };
            
            virtual ivy::ptr< ivy::error::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace ivy
{
    namespace syntax_error
    {
        ivy::syntax_error::__t make  (const str::__t &tok);
        
    }
    
}
namespace ivy
{
    namespace bad_syntax
    {
        struct __t : ivy::error::__t
        {
            ivy::ptr< ivy::expr::__t > e;
            
            void encode  (pretty::__t &b) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const {
                return e == other . e;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return e . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return ivy::ptr< ivy::expr::__t >::__hash() (x . e);
                }
            };
            
            virtual ivy::ptr< ivy::error::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace ivy
{
    namespace bad_syntax
    {
        ivy::bad_syntax::__t make  (const ivy::ptr< ivy::expr::__t > &e);
        
    }
    
}
namespace env
{
    str::__t get  (const str::__t &name);
    
}
namespace ivy
{
    namespace file
    {
        void read  (const str::__t &fname,str::__t &b,__bool &ok);
        
    }
    
}
namespace ivy
{
    namespace file
    {
        __bool write  (const str::__t &fname,const str::__t &b);
        
    }
    
}
namespace ivy
{
    namespace file
    {
        __bool exist  (const str::__t &fname);
        
    }
    
}
namespace ivy
{
    void write_file  (const str::__t &name,const str::__t &buf);
    
}
namespace ivy
{
    vector__str::__t include_path;
    
}
namespace ivy
{
    namespace prog
    {
        struct readst
        {
            ivy::ident_set::__t have_read;
            
             readst () {}
             readst  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const readst &other) const
            {
                return have_read == other . have_read;
            }
            ivy::native_bool operator !=  (const readst &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return have_read . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const readst &x) const
                {
                    return ivy::ident_set::__t::__hash() (x . have_read);
                }
            };
            
        };
        
    }
    
}
namespace ivy
{
    namespace prog
    {
        void find_include  (str::__t &name);
        
    }
    
}
namespace ivy
{
    namespace prog
    {
        void read_file_int  (const str::__t &name,const ivy::ptr< annot::__t > &ann,ivy::prog::__t &p,ivy::prog::readst
            &rst);
        
    }
    
}
// Read the main file, named `name`. We prepend `include ivy`
// to the file, to cause the standard preamble to be read.
namespace ivy
{
    namespace prog
    {
        ivy::prog::__t read_file  (const str::__t &name);
        
    }
    
}
namespace ivy
{
    namespace path
    {
        void change_extension  (str::__t &path,const str::__t &ext);
        
    }
    
}
namespace ivy
{
    namespace path
    {
        void drop_extension  (str::__t &path);
        
    }
    
}
namespace ivy
{
    namespace path
    {
        void concat  (str::__t &path1,const str::__t &path2);
        
    }
    
}
namespace ivy
{
    namespace symeval
    {
        struct rec
        {
            __bool full;
            
            ivy::ptr< ivy::expr::__t > val;
            
             rec () {}
             rec  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const rec &other) const
            {
                return full == other . full & val == other . val;
            }
            ivy::native_bool operator !=  (const rec &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return full . __is_zero() & val . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const rec &x) const
                {
                    return __bool::__hash() (x . full) +
                        ivy::ptr< ivy::expr::__t >::__hash() (x . val);
                }
            };
            
        };
        
    }
    
}
namespace ivy
{
    namespace symeval
    {
        struct __t
        {
            ivy::vector< ivy::symeval::rec,ivy::ptr< ivy::ident::__t > > map;
            
            void set  (const ivy::ptr< ivy::ident::__t > &x,const ivy::ptr< ivy::expr::__t > &y);
            
            void get  (const ivy::ptr< ivy::ident::__t > &x,ivy::ptr< ivy::expr::__t > &y) const;
            
            __bool mem  (const ivy::ptr< ivy::ident::__t > &x) const;
            
            void remove  (const ivy::ptr< ivy::ident::__t > &x);
            
            ivy::ptr< ivy::expr::__t > value  (const ivy::ptr< ivy::ident::__t > &x) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const {
                return map == other . map;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return map . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return
                        ivy::vector< ivy::symeval::rec,ivy::ptr< ivy::ident::__t > >::__hash() (x .
                            map);
                }
            };
            
        };
        
    }
    
}
namespace ivy
{
    namespace symeval
    {
        ivy::symeval::__t empty ();
        
    }
    
}
namespace ivy
{
    void subst_vector  (vector__ivy__expr::__t &v,const ivy::symeval::__t &smap);
    
}
namespace ivy
{
    namespace ident_to_moduledc
    {
        struct rec
        {
            __bool full;
            
            ivy::moduledc::__t val;
            
             rec () {}
             rec  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const rec &other) const
            {
                return full == other . full & val == other . val;
            }
            ivy::native_bool operator !=  (const rec &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return full . __is_zero() & val . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const rec &x) const
                {
                    return __bool::__hash() (x . full) + ivy::moduledc::__t::__hash() (x . val);
                }
            };
            
        };
        
    }
    
}
namespace ivy
{
    namespace ident_to_moduledc
    {
        struct __t
        {
            ivy::vector< ivy::ident_to_moduledc::rec,ivy::ptr< ivy::ident::__t > > map;
            
            void set  (const ivy::ptr< ivy::ident::__t > &x,const ivy::moduledc::__t &y);
            
            void get  (const ivy::ptr< ivy::ident::__t > &x,ivy::moduledc::__t &y) const;
            
            __bool mem  (const ivy::ptr< ivy::ident::__t > &x) const;
            
            void remove  (const ivy::ptr< ivy::ident::__t > &x);
            
            ivy::moduledc::__t value  (const ivy::ptr< ivy::ident::__t > &x) const;
            
            ivy::moduledc::__t get_def  (const ivy::ptr< ivy::ident::__t > &x,const ivy::ptr< annot::__t >
                &ann) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const {
                return map == other . map;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return map . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return
                        ivy::vector< ivy::ident_to_moduledc::rec,ivy::ptr< ivy::ident::__t > >::__hash()
                            (x . map);
                }
            };
            
        };
        
    }
    
}
namespace ivy
{
    namespace ident_to_moduledc
    {
        ivy::ident_to_moduledc::__t empty ();
        
    }
    
}
namespace ivy
{
    namespace ident_to_ident
    {
        struct rec
        {
            __bool full;
            
            ivy::ptr< ivy::ident::__t > val;
            
             rec () {}
             rec  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const rec &other) const
            {
                return full == other . full & val == other . val;
            }
            ivy::native_bool operator !=  (const rec &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return full . __is_zero() & val . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const rec &x) const
                {
                    return __bool::__hash() (x . full) +
                        ivy::ptr< ivy::ident::__t >::__hash() (x . val);
                }
            };
            
        };
        
    }
    
}
namespace ivy
{
    namespace ident_to_ident
    {
        struct __t
        {
            ivy::vector< ivy::ident_to_ident::rec,ivy::ptr< ivy::ident::__t > > map;
            
            void set  (const ivy::ptr< ivy::ident::__t > &x,const ivy::ptr< ivy::ident::__t > &y);
            
            void get  (const ivy::ptr< ivy::ident::__t > &x,ivy::ptr< ivy::ident::__t > &y) const;
            
            __bool mem  (const ivy::ptr< ivy::ident::__t > &x) const;
            
            void remove  (const ivy::ptr< ivy::ident::__t > &x);
            
            ivy::ptr< ivy::ident::__t > value  (const ivy::ptr< ivy::ident::__t > &x) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const {
                return map == other . map;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return map . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return
                        ivy::vector< ivy::ident_to_ident::rec,ivy::ptr< ivy::ident::__t > >::__hash()
                            (x . map);
                }
            };
            
        };
        
    }
    
}
namespace ivy
{
    namespace ident_to_ident
    {
        ivy::ident_to_ident::__t empty ();
        
    }
    
}
namespace ivy
{
    namespace ident_to_instantiatedc
    {
        struct rec
        {
            __bool full;
            
            ivy::instantiatedc::__t val;
            
             rec () {}
             rec  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const rec &other) const
            {
                return full == other . full & val == other . val;
            }
            ivy::native_bool operator !=  (const rec &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return full . __is_zero() & val . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const rec &x) const
                {
                    return __bool::__hash() (x . full) + ivy::instantiatedc::__t::__hash() (x . val);
                }
            };
            
        };
        
    }
    
}
namespace ivy
{
    namespace ident_to_instantiatedc
    {
        struct __t
        {
            ivy::vector< ivy::ident_to_instantiatedc::rec,ivy::ptr< ivy::ident::__t > > map;
            
            void set  (const ivy::ptr< ivy::ident::__t > &x,const ivy::instantiatedc::__t &y);
            
            void get  (const ivy::ptr< ivy::ident::__t > &x,ivy::instantiatedc::__t &y) const;
            
            __bool mem  (const ivy::ptr< ivy::ident::__t > &x) const;
            
            void remove  (const ivy::ptr< ivy::ident::__t > &x);
            
            ivy::instantiatedc::__t value  (const ivy::ptr< ivy::ident::__t > &x) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const {
                return map == other . map;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return map . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return
                        ivy::vector< ivy::ident_to_instantiatedc::rec,ivy::ptr< ivy::ident::__t > >::__hash()
                            (x . map);
                }
            };
            
        };
        
    }
    
}
namespace ivy
{
    namespace ident_to_instantiatedc
    {
        ivy::ident_to_instantiatedc::__t empty ();
        
    }
    
}
namespace ivy
{
    namespace ident_to_annot
    {
        struct rec
        {
            __bool full;
            
            ivy::ptr< annot::__t > val;
            
             rec () {}
             rec  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const rec &other) const
            {
                return full == other . full & val == other . val;
            }
            ivy::native_bool operator !=  (const rec &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return full . __is_zero() & val . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const rec &x) const
                {
                    return __bool::__hash() (x . full) + ivy::ptr< annot::__t >::__hash() (x . val);
                }
            };
            
        };
        
    }
    
}
namespace ivy
{
    namespace ident_to_annot
    {
        struct __t
        {
            ivy::vector< ivy::ident_to_annot::rec,ivy::ptr< ivy::ident::__t > > map;
            
            void set  (const ivy::ptr< ivy::ident::__t > &x,const ivy::ptr< annot::__t > &y);
            
            void get  (const ivy::ptr< ivy::ident::__t > &x,ivy::ptr< annot::__t > &y) const;
            
            __bool mem  (const ivy::ptr< ivy::ident::__t > &x) const;
            
            void remove  (const ivy::ptr< ivy::ident::__t > &x);
            
            ivy::ptr< annot::__t > value  (const ivy::ptr< ivy::ident::__t > &x) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const {
                return map == other . map;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return map . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return
                        ivy::vector< ivy::ident_to_annot::rec,ivy::ptr< ivy::ident::__t > >::__hash()
                            (x . map);
                }
            };
            
        };
        
    }
    
}
namespace ivy
{
    namespace ident_to_annot
    {
        ivy::ident_to_annot::__t empty ();
        
    }
    
}
namespace ivy
{
    namespace flatst
    {
        struct __t
        {
            
            // Accumulated declarations
            
            vector__ivy__decl::__t decls;
            
            
            // The module parameter valuations
            
            ivy::ident_to_ident::__t prmvals;
            
            
            // The module declarations, by name
            
            ivy::ident_to_moduledc::__t moddecls;
            
            
            // The set of defined identifiers
            
            ivy::ident_set::__t defs;
            
            
            // The locations of definitions of traits (non-objects)
            
            ivy::ident_to_annot::__t non_objects;
            
            
            // True if the hierarchy root is set
            
            __bool has_root;
            
            
            // The current hierarchy root
            
            ivy::ptr< ivy::ident::__t > root;
            
            
            // The current local variables as a set
            
            ivy::ident_set::__t locals;
            
            
            // The set of global variables
            
            ivy::ident_set::__t globals;
            
            
            // True if we are defining an identifier
            
            __bool defining;
            
            
            // True if we are on an absolute identifier
            
            __bool absolute;
            
            
            // True if we are on rhs of a dot operator
            
            __bool dot_rhs;
            
            
            // Maps autoinstance keys to instantiations
            
            ivy::ident_to_instantiatedc::__t autodefs;
            
            
            // Auto instantiations that are pending
            
            ivy::ident_set::__t autos_pending;
            
            
            // True if we don't want to check undefined
            
            __bool no_undefined;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return decls == other . decls & prmvals == other . prmvals & moddecls == other .
                    moddecls & defs == other . defs & non_objects == other . non_objects & has_root
                    == other . has_root & root == other . root & locals == other . locals & globals
                    == other . globals & defining == other . defining & absolute == other . absolute
                    & dot_rhs == other . dot_rhs & autodefs == other . autodefs & autos_pending ==
                    other . autos_pending & no_undefined == other . no_undefined;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const
            {
                return decls . __is_zero() & prmvals . __is_zero() & moddecls . __is_zero() &
                    defs . __is_zero() & non_objects . __is_zero() & has_root . __is_zero() &
                    root . __is_zero() & locals . __is_zero() & globals . __is_zero() &
                    defining . __is_zero() & absolute . __is_zero() & dot_rhs . __is_zero() &
                    autodefs . __is_zero() & autos_pending . __is_zero() &
                    no_undefined . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return vector__ivy__decl::__t::__hash() (x . decls) +
                        ivy::ident_to_ident::__t::__hash() (x . prmvals) +
                        ivy::ident_to_moduledc::__t::__hash() (x . moddecls) +
                        ivy::ident_set::__t::__hash() (x . defs) +
                        ivy::ident_to_annot::__t::__hash() (x . non_objects) +
                        __bool::__hash() (x . has_root) +
                        ivy::ptr< ivy::ident::__t >::__hash() (x . root) +
                        ivy::ident_set::__t::__hash() (x . locals) +
                        ivy::ident_set::__t::__hash() (x . globals) +
                        __bool::__hash() (x . defining) + __bool::__hash() (x . absolute) +
                        __bool::__hash() (x . dot_rhs) +
                        ivy::ident_to_instantiatedc::__t::__hash() (x . autodefs) +
                        ivy::ident_set::__t::__hash() (x . autos_pending) +
                        __bool::__hash() (x . no_undefined);
                }
            };
            
        };
        
    }
    
}
namespace ivy
{
    ivy::ident_to_ident::__t prm_map  (const vector__ivy__expr::__t &fml,const vector__ivy__expr::__t
        &act,const ivy::ptr< annot::__t > &ann);
    
}
// A dot operator has two possible interpretations: it indicates a
// member of an object, or an application of a destructor or member
// action. When defining a name, it is always the former. When not
// defining, we check whether the lhs of the dot is defined. If it is,
// we treat the dot as an object member reference.
namespace ivy
{
    ivy::ptr< ivy::expr::__t > applydot  (const ivy::ptr< ivy::expr::__t > &arg,const ivy::ptr< ivy::ident::__t >
        &member,const ivy::ptr< annot::__t > &ann,const ivy::flatst::__t &st);
    
}
namespace ivy
{
    void find_ident  (const ivy::ptr< ivy::ident::__t > &root,ivy::ptr< ivy::ident::__t > &s,const
        ivy::flatst::__t &st);
    
}
namespace ivy
{
    void add_def_id  (const ivy::ptr< ivy::ident::__t > &id,ivy::flatst::__t &st,const __bool &is_global,const
        __bool &is_object,const ivy::ptr< annot::__t > &ann);
    
}
namespace ivy
{
    void add_def  (const ivy::ptr< ivy::expr::__t > &s,ivy::flatst::__t &st,const __bool &is_global,const
        __bool &is_object);
    
}
namespace ivy
{
    void check_defined  (const ivy::ptr< ivy::ident::__t > &name,const ivy::flatst::__t &st,const
        ivy::ptr< annot::__t > &ann);
    
}
namespace ivy
{
    void setup_local_vars  (const ivy::ptr< ivy::stmt::__t > &s,ivy::flatst::__t &st,vector__ivy__ident::__t
        &del);
    
}
namespace ivy
{
    void remove_local_vars  (const vector__ivy__ident::__t &del,ivy::flatst::__t &st);
    
}
namespace ivy
{
    void flat_formal  (const ivy::ptr< ivy::expr::__t > &s,ivy::flatst::__t &st,ivy::ptr< ivy::expr::__t >
        &res);
    
}
namespace ivy
{
    ivy::ptr< ivy::ident::__t > formal_ident  (const ivy::ptr< ivy::expr::__t > &s);
    
}
namespace ivy
{
    void flat_exprvec  (vector__ivy__expr::__t &es,ivy::flatst::__t &st);
    
}
namespace ivy
{
    void flat_formalvec  (vector__ivy__expr::__t &es,ivy::flatst::__t &st);
    
}
namespace ivy
{
    void local_vec  (const vector__ivy__expr::__t &es,const __bool &val,ivy::flatst::__t &st);
    
}
namespace ivy
{
    void canon_typing  (ivy::ptr< ivy::expr::__t > &typing);
    
}
namespace ivy
{
    void make_auto_key  (const ivy::ptr< ivy::ident::__t > &id,const __bool &rev,ivy::ptr< ivy::ident::__t >
        &key,ivy::symeval::__t &pmap);
    
}
namespace ivy
{
    void find_auto_inst  (const ivy::ptr< ivy::ident::__t > &id,const ivy::flatst::__t &st,ivy::instantiatedc::__t
        &idc,__bool &ok);
    
}
namespace ivy
{
    void auto_defd_rec  (const ivy::ptr< ivy::expr::__t > &s,ivy::flatst::__t &st);
    
}
namespace ivy
{
    void auto_defd  (const ivy::ptr< ivy::expr::__t > &s,ivy::flatst::__t &st);
    
}
namespace ivy
{
    void auto_flat_rec  (const ivy::ptr< ivy::expr::__t > &s,ivy::flatst::__t &st);
    
}
namespace ivy
{
    void auto_flat  (const ivy::ptr< ivy::expr::__t > &s,ivy::flatst::__t &st);
    
}
namespace ivy
{
    void check_syntax_symbol  (const ivy::ptr< ivy::expr::__t > &e);
    
}
// Get the symbol that is typed in a typing. Examples:
//
// - in `x : t`, the typed symbol is `x`
// - in `f(X:u) : t`, the typed symbol is `f`
// - in `f(X:u)` the typed symbol is `f'
namespace ivy
{
    ivy::ptr< ivy::expr::__t > get_typed_symbol  (const ivy::ptr< ivy::expr::__t > &typing);
    
}
namespace ivy
{
    void is_typing_lhs_syntax  (const ivy::ptr< ivy::expr::__t > &lhs,__bool &res,ivy::ptr< ivy::expr::__t >
        &bad);
    
}
namespace ivy
{
    void is_typing_rhs_syntax  (const ivy::ptr< ivy::expr::__t > &rhs,__bool &res,ivy::ptr< ivy::expr::__t >
        &bad);
    
}
namespace ivy
{
    void check_syntax_typing  (const ivy::ptr< ivy::expr::__t > &typing,const __bool &has_def);
    
}
namespace ivy
{
    void check_syntax_symbol_vec  (const vector__ivy__expr::__t &s);
    
}
namespace ivy
{
    void set_root  (ivy::flatst::__t &st,const ivy::ptr< ivy::expr::__t > &s);
    
}
namespace ivy
{
    void auto_instance_defd  (const ivy::instancedc::__t &s,ivy::flatst::__t &st);
    
}
namespace ivy
{
    namespace ident_to_exprs
    {
        struct __t
        {
            ivy::vector< vector__ivy__expr::__t,ivy::ptr< ivy::ident::__t > > value;
            
            
            // mutate a relation map a so that x is related to y
            
            void add  (const ivy::ptr< ivy::ident::__t > &x,const ivy::ptr< ivy::expr::__t > &y);
            
            
            // get a vector of values y such that x maps to y in a
            
            vector__ivy__expr::__t get  (const ivy::ptr< ivy::ident::__t > &x) const;
            
            
            // return true if x maps to some value
            
            __bool mem  (const ivy::ptr< ivy::ident::__t > &x) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const {
                return value == other . value;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return value . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return
                        ivy::vector< vector__ivy__expr::__t,ivy::ptr< ivy::ident::__t > >::__hash()
                            (x . value);
                }
            };
            
        };
        
    }
    
}
// return an empty map
namespace ivy
{
    namespace ident_to_exprs
    {
        ivy::ident_to_exprs::__t empty ();
        
    }
    
}
namespace ivy
{
    namespace subtypes
    {
        struct __t
        {
            ivy::ident_to_exprs::__t subtypes_of;
            
            ivy::symeval::__t supertype_of;
            
            __bool is_subtype  (const ivy::ptr< ivy::expr::__t > &sub,const ivy::ptr< ivy::expr::__t >
                &super) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return subtypes_of == other . subtypes_of & supertype_of == other . supertype_of;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return subtypes_of . __is_zero() & supertype_of . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return ivy::ident_to_exprs::__t::__hash() (x . subtypes_of) +
                        ivy::symeval::__t::__hash() (x . supertype_of);
                }
            };
            
        };
        
    }
    
}
namespace ivy
{
    namespace global_types
    {
        struct __t
        {
            ivy::symeval::__t type_of;
            
            ivy::ident_set::__t is_action;
            
            ivy::vector< __bool,ivy::ptr< ivy::ident::__t > > is_destructor;
            
            __bool curried;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return type_of == other . type_of & is_action == other . is_action & is_destructor
                    == other . is_destructor & curried == other . curried;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const
            {
                return type_of . __is_zero() & is_action . __is_zero() & is_destructor . __is_zero()
                    & curried . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return ivy::symeval::__t::__hash() (x . type_of) +
                        ivy::ident_set::__t::__hash() (x . is_action) +
                        ivy::vector< __bool,ivy::ptr< ivy::ident::__t > >::__hash() (x .
                            is_destructor) + __bool::__hash() (x . curried);
                }
            };
            
        };
        
    }
    
}
// A complete typing looks like one of these:
//
// (1)  x:t
// (2)  f(x1:t1,...,xn:tn) : t
// (3)  (f : (t1*...*tn->t)(...)) : u
// (4)  (f : (t1*...*tn->t)(...))
//
namespace ivy
{
    __bool is_typing_complete  (const ivy::ptr< ivy::expr::__t > &typing);
    
}
namespace ivy
{
    ivy::ptr< ivy::expr::__t > get_formal_type  (const vector__ivy__expr::__t &typings,const ivy::ptr< annot::__t >
        &ann);
    
}
// Returns true is an action is virtual. A virtual action is one that
// overrides an action of a superclass or is overridden by an action of
// a subclass. This action assumes that parameter s is a member action.
namespace ivy
{
    __bool is_virtual_action  (const ivy::actdc::__t &s,const ivy::global_types::__t &gl,const ivy::subtypes::__t
        &st);
    
}
namespace ivy
{
    namespace param_map
    {
        struct rec
        {
            __bool full;
            
            vector__ivy__expr::domain::__t val;
            
             rec () {}
             rec  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const rec &other) const
            {
                return full == other . full & val == other . val;
            }
            ivy::native_bool operator !=  (const rec &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return full . __is_zero() & val . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const rec &x) const
                {
                    return __bool::__hash() (x . full) +
                        vector__ivy__expr::domain::__t::__hash() (x . val);
                }
            };
            
        };
        
    }
    
}
namespace ivy
{
    namespace param_map
    {
        struct __t
        {
            ivy::vector< ivy::param_map::rec,ivy::ptr< ivy::ident::__t > > map;
            
            void set  (const ivy::ptr< ivy::ident::__t > &x,const vector__ivy__expr::domain::__t &y);
            
            void get  (const ivy::ptr< ivy::ident::__t > &x,vector__ivy__expr::domain::__t &y) const;
            
            __bool mem  (const ivy::ptr< ivy::ident::__t > &x) const;
            
            void remove  (const ivy::ptr< ivy::ident::__t > &x);
            
            vector__ivy__expr::domain::__t value  (const ivy::ptr< ivy::ident::__t > &x) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const {
                return map == other . map;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return map . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return
                        ivy::vector< ivy::param_map::rec,ivy::ptr< ivy::ident::__t > >::__hash() (x
                            . map);
                }
            };
            
        };
        
    }
    
}
namespace ivy
{
    namespace param_map
    {
        ivy::param_map::__t empty ();
        
    }
    
}
namespace ivy
{
    ivy::param_map::__t param_set  (const vector__ivy__expr::__t &ps);
    
}
// Uncurry a function. This converts `f : t -> (... -> u)` to `t.f : (t * ... -> u)`.
namespace ivy
{
    ivy::ptr< ivy::expr::__t > uncurry_func  (const ivy::ptr< ivy::expr::__t > &func);
    
}
// Given a function type `ty = (t * ... -> u)`, return `t`.
namespace ivy
{
    ivy::ptr< ivy::expr::__t > get_dom0  (const ivy::ptr< ivy::expr::__t > &ty);
    
}
// Test whether a type-decorated function is a member
// function. That is, it returns true if `func` has the form
// `t.f : (t * ...) -> u`.
namespace ivy
{
    __bool func_is_member  (const ivy::ptr< ivy::expr::__t > &func);
    
}
// A function application can be in several forms
//
// - (x:t).f            returns t.f(x)
// - (x:t).f(a1...an)   returns t.f(x,a1...an)
// - (f:...)(a1...an)   returns f(a1...an)
//
// This action analyzes an app, returning the type-decorated
// function and the argument vector. This assumes that the app is
// already type-decorated.
namespace ivy
{
    void get_app  (const ivy::ptr< ivy::expr::__t > &s,ivy::ptr< ivy::expr::__t > &func,vector__ivy__expr::__t
        &args);
    
}
// Returns true if the term `s` is functional, meaning it contains
// no action calls.
namespace ivy
{
    __bool is_functional  (const ivy::ptr< ivy::expr::__t > &s,const ivy::global_types::__t &gl);
    
}
// Canonize a function application. If it is in member style,
// convert it to an ordinary function call.
namespace ivy
{
    void canon_app  (ivy::ptr< ivy::expr::__t > &s);
    
}
namespace ivy
{
    namespace local_info
    {
        struct __t
        {
            __bool is_live;
            
            __bool is_ref;
            
            pos::__t loop_nesting;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return is_live == other . is_live & is_ref == other . is_ref & loop_nesting == other
                    . loop_nesting;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const
            {
                return is_live . __is_zero() & is_ref . __is_zero() & loop_nesting . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return __bool::__hash() (x . is_live) + __bool::__hash() (x . is_ref) +
                        pos::__t::__hash() (x . loop_nesting);
                }
            };
            
        };
        
    }
    
}
namespace ivy
{
    namespace push_pop_locals
    {
        struct undo
        {
            ivy::ptr< ivy::ident::__t > id;
            
            __bool present;
            
            ivy::local_info::__t value;
            
             undo () {}
             undo  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const undo &other) const
            {
                return id == other . id & present == other . present & value == other . value;
            }
            ivy::native_bool operator !=  (const undo &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const
            {
                return id . __is_zero() & present . __is_zero() & value . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const undo &x) const
                {
                    return ivy::ptr< ivy::ident::__t >::__hash() (x . id) +
                        __bool::__hash() (x . present) + ivy::local_info::__t::__hash() (x . value);
                }
            };
            
        };
        
    }
    
}
namespace ivy
{
    namespace push_pop_locals
    {
        namespace map_t
        {
            struct rec
            {
                __bool full;
                
                ivy::local_info::__t val;
                
                 rec () {}
                 rec  (long long value) {}
                 operator std::size_t () const {
                    return 0;
                }
                static bool __is_seq () {
                    return false;
                }
                ivy::native_bool operator ==  (const rec &other) const
                {
                    return full == other . full & val == other . val;
                }
                ivy::native_bool operator !=  (const rec &other) const {
                    return ! ((*this) == other);
                }
                bool __is_zero () const {
                    return full . __is_zero() & val . __is_zero();
                }
                struct __hash
                {
                    std::size_t operator ()  (const rec &x) const
                    {
                        return __bool::__hash() (x . full) +
                            ivy::local_info::__t::__hash() (x . val);
                    }
                };
                
            };
            
        }
        
    }
    
}
namespace ivy
{
    namespace push_pop_locals
    {
        namespace map_t
        {
            struct __t
            {
                ivy::vector< ivy::push_pop_locals::map_t::rec,ivy::ptr< ivy::ident::__t > > map;
                
                void set  (const ivy::ptr< ivy::ident::__t > &x,const ivy::local_info::__t &y);
                
                void get  (const ivy::ptr< ivy::ident::__t > &x,ivy::local_info::__t &y) const;
                
                __bool mem  (const ivy::ptr< ivy::ident::__t > &x) const;
                
                void remove  (const ivy::ptr< ivy::ident::__t > &x);
                
                ivy::local_info::__t value  (const ivy::ptr< ivy::ident::__t > &x) const;
                
                 __t () {}
                 __t  (long long value) {}
                 operator std::size_t () const {
                    return 0;
                }
                static bool __is_seq () {
                    return false;
                }
                ivy::native_bool operator ==  (const __t &other) const {
                    return map == other . map;
                }
                ivy::native_bool operator !=  (const __t &other) const {
                    return ! ((*this) == other);
                }
                bool __is_zero () const {
                    return map . __is_zero();
                }
                struct __hash
                {
                    std::size_t operator ()  (const __t &x) const
                    {
                        return
                            ivy::vector< ivy::push_pop_locals::map_t::rec,ivy::ptr< ivy::ident::__t > >::__hash()
                                (x . map);
                    }
                };
                
            };
            
        }
        
    }
    
}
namespace ivy
{
    namespace push_pop_locals
    {
        namespace map_t
        {
            ivy::push_pop_locals::map_t::__t empty ();
            
        }
        
    }
    
}
namespace ivy
{
    namespace push_pop_locals
    {
        namespace vec_t
        {
            struct __t
            {
                ivy::vector< ivy::push_pop_locals::undo,pos::__t > value;
                
                pos::__t end;
                
                pos::__t begin () const;
                
                void set  (const pos::__t &i,const ivy::push_pop_locals::undo &v);
                
                void append  (const ivy::push_pop_locals::undo &c);
                
                void extend  (const ivy::push_pop_locals::vec_t::__t &x);
                
                void resize  (const pos::__t &end);
                
                ivy::push_pop_locals::undo back () const;
                
                void pop_back ();
                
                ivy::push_pop_locals::vec_t::__t segment  (const pos::__t &beg,const pos::__t &en)
                    const;
                
                void reverse ();
                
                 __t () {}
                 __t  (long long value) {}
                 operator std::size_t () const {
                    return 0;
                }
                static bool __is_seq () {
                    return false;
                }
                ivy::native_bool operator ==  (const __t &other) const
                {
                    return value == other . value & end == other . end;
                }
                ivy::native_bool operator !=  (const __t &other) const {
                    return ! ((*this) == other);
                }
                bool __is_zero () const {
                    return value . __is_zero() & end . __is_zero();
                }
                struct __hash
                {
                    std::size_t operator ()  (const __t &x) const
                    {
                        return
                            ivy::vector< ivy::push_pop_locals::undo,pos::__t >::__hash() (x . value)
                            + pos::__t::__hash() (x . end);
                    }
                };
                
            };
            
        }
        
    }
    
}
namespace ivy
{
    namespace push_pop_locals
    {
        namespace vec_t
        {
            ivy::push_pop_locals::vec_t::__t empty ();
            
        }
        
    }
    
}
namespace ivy
{
    namespace push_pop_locals
    {
        struct __t
        {
            ivy::push_pop_locals::map_t::__t map;
            
            ivy::push_pop_locals::vec_t::__t del;
            
            vector__pos::__t stack;
            
            void set  (const ivy::ptr< ivy::ident::__t > &id,const ivy::local_info::__t &v);
            
            __bool mem  (const ivy::ptr< ivy::ident::__t > &id) const;
            
            ivy::local_info::__t value  (const ivy::ptr< ivy::ident::__t > &id) const;
            
            void push ();
            
            void pop ();
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return map == other . map & del == other . del & stack == other . stack;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const
            {
                return map . __is_zero() & del . __is_zero() & stack . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return ivy::push_pop_locals::map_t::__t::__hash() (x . map) +
                        ivy::push_pop_locals::vec_t::__t::__hash() (x . del) +
                        vector__pos::__t::__hash() (x . stack);
                }
            };
            
        };
        
    }
    
}
namespace ivy
{
    namespace local_tracker
    {
        struct __t
        {
            ivy::push_pop_locals::__t map;
            
            void push ();
            
            void add_var  (const ivy::ptr< ivy::expr::__t > &typing,const __bool &is_ref,const pos::__t
                &loop_nesting);
            
            void push_vars  (const vector__ivy__expr::__t &typings);
            
            void push_stmt  (const ivy::ptr< ivy::stmt::__t > &stm,const pos::__t &loop_nesting);
            
            void pop ();
            
            __bool mem  (const ivy::ptr< ivy::ident::__t > &id) const;
            
            ivy::local_info::__t value  (const ivy::ptr< ivy::ident::__t > &id) const;
            
            void set  (const ivy::ptr< ivy::ident::__t > &id,const ivy::local_info::__t &value);
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const {
                return map == other . map;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return map . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return ivy::push_pop_locals::__t::__hash() (x . map);
                }
            };
            
        };
        
    }
    
}
namespace ivy
{
    namespace root_mod_ref
    {
        struct __t
        {
            ivy::ident_set::__t mod;
            
            ivy::ident_set::__t ref;
            
            ivy::local_tracker::__t ignore;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return mod == other . mod & ref == other . ref & ignore == other . ignore;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const
            {
                return mod . __is_zero() & ref . __is_zero() & ignore . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return ivy::ident_set::__t::__hash() (x . mod) +
                        ivy::ident_set::__t::__hash() (x . ref) +
                        ivy::local_tracker::__t::__hash() (x . ignore);
                }
            };
            
        };
        
    }
    
}
// Get the root modset of an assignment, given its lhs. There are several cases:
//
// - `x:...`: `x` is a root
// - `x:...,y:...`: both `x` and `y` are roots    
// - `(x:...).(f:...)(...)`: `x` is a root (and `f` must be a destructor)
// - `(f:...)(...)` where `f` is *not* a destructor: `f` is the root
//
// The following cases are not allowed on the lhs of an assignment:
//
// - `(f:...)(x:...,...)` where `f` is a destructor
// - `(x:...).(f:...)(...)`: where `f` is not a destructor
namespace ivy
{
    void get_lhs_roots  (const ivy::ptr< ivy::expr::__t > &s,ivy::root_mod_ref::__t &st);
    
}
// This function gives the types of the builtin-in symbols
namespace ivy
{
    ivy::vector< ivy::ptr< ivy::expr::__t >,ivy::verb::__t > optypes;
    
}
// The predicates determine for a given verb what type inferences we can
// rely on when eliding type decorations:
//
// Verb is monomorphic:
namespace ivy
{
    ivy::vector< __bool,ivy::verb::__t > verb_mono;
    
}
// Input types determine output types:
namespace ivy
{
    ivy::vector< __bool,ivy::verb::__t > verb_in_to_out;
    
}
// Output type determines input types:
namespace ivy
{
    ivy::vector< __bool,ivy::verb::__t > verb_out_to_in;
    
}
// First input type determines all:
namespace ivy
{
    ivy::vector< __bool,ivy::verb::__t > verb_first_to_in;
    
}
namespace ivy
{
    void set_built_in_type  (const ivy::verb::__t &vrb,const str::__t &ty,const __bool &m,const
        __bool &io,const __bool &oi,const __bool &fi);
    
}
// Returns `true` if the type of a the first input of a given verb determines
// the type of the remaining inputs.
namespace ivy
{
    __bool verb_det_type  (const ivy::verb::__t &vrb);
    
}
namespace ivy
{
    namespace decost
    {
        namespace map
        {
            struct rec
            {
                __bool full;
                
                ivy::ptr< ivy::expr::__t > val;
                
                 rec () {}
                 rec  (long long value) {}
                 operator std::size_t () const {
                    return 0;
                }
                static bool __is_seq () {
                    return false;
                }
                ivy::native_bool operator ==  (const rec &other) const
                {
                    return full == other . full & val == other . val;
                }
                ivy::native_bool operator !=  (const rec &other) const {
                    return ! ((*this) == other);
                }
                bool __is_zero () const {
                    return full . __is_zero() & val . __is_zero();
                }
                struct __hash
                {
                    std::size_t operator ()  (const rec &x) const
                    {
                        return __bool::__hash() (x . full) +
                            ivy::ptr< ivy::expr::__t >::__hash() (x . val);
                    }
                };
                
            };
            
        }
        
    }
    
}
namespace ivy
{
    namespace decost
    {
        namespace map
        {
            struct __t
            {
                ivy::vector< ivy::decost::map::rec,ivy::ptr< ivy::ident::__t > > map;
                
                void set  (const ivy::ptr< ivy::ident::__t > &x,const ivy::ptr< ivy::expr::__t > &y);
                
                void get  (const ivy::ptr< ivy::ident::__t > &x,ivy::ptr< ivy::expr::__t > &y) const;
                
                __bool mem  (const ivy::ptr< ivy::ident::__t > &x) const;
                
                void remove  (const ivy::ptr< ivy::ident::__t > &x);
                
                ivy::ptr< ivy::expr::__t > value  (const ivy::ptr< ivy::ident::__t > &x) const;
                
                 __t () {}
                 __t  (long long value) {}
                 operator std::size_t () const {
                    return 0;
                }
                static bool __is_seq () {
                    return false;
                }
                ivy::native_bool operator ==  (const __t &other) const {
                    return map == other . map;
                }
                ivy::native_bool operator !=  (const __t &other) const {
                    return ! ((*this) == other);
                }
                bool __is_zero () const {
                    return map . __is_zero();
                }
                struct __hash
                {
                    std::size_t operator ()  (const __t &x) const
                    {
                        return
                            ivy::vector< ivy::decost::map::rec,ivy::ptr< ivy::ident::__t > >::__hash()
                                (x . map);
                    }
                };
                
            };
            
        }
        
    }
    
}
namespace ivy
{
    namespace decost
    {
        namespace map
        {
            ivy::decost::map::__t empty ();
            
        }
        
    }
    
}
namespace ivy
{
    namespace decost
    {
        struct __t
        {
            
            // A counter for creating type variables
            
            pos::__t counter;
            
            
            // Maps types and type variables to their representatives
            
            ivy::decost::map::__t m;
            
            
            // Maps identifiers of symbols to their types
            
            ivy::symeval::__t ty;
            
            
            // True if we are typing a member function
            
            __bool member;
            
            
            // False if there has been a type error
            
            __bool ok;
            
            
            // Types that we failed to unify
            
            vector__ivy__expr::__t failed;
            
            
            // Error has been reported
            
            __bool error_reported;
            
            
            // Make a new type variable
            
            void newvar  (const ivy::ptr< annot::__t > &ann,ivy::ptr< ivy::expr::__t > &res);
            
            
            // Find the representative of an expression. This has the
            // side effect of shortening the path to the representative
            // as in classic union/find.
            
            void find  (const ivy::ptr< ivy::expr::__t > &x,ivy::ptr< ivy::expr::__t > &res);
            
            
            // Record failure of type unification
            
            void unification_failed  (const ivy::ptr< ivy::expr::__t > &x,const ivy::ptr< ivy::expr::__t >
                &y);
            
            void unify  (const ivy::ptr< ivy::expr::__t > &x0,const ivy::ptr< ivy::expr::__t > &y0);
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return counter == other . counter & m == other . m & ty == other . ty & member ==
                    other . member & ok == other . ok & failed == other . failed & error_reported ==
                    other . error_reported;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const
            {
                return counter . __is_zero() & m . __is_zero() & ty . __is_zero() &
                    member . __is_zero() & ok . __is_zero() & failed . __is_zero() &
                    error_reported . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return pos::__t::__hash() (x . counter) +
                        ivy::decost::map::__t::__hash() (x . m) +
                        ivy::symeval::__t::__hash() (x . ty) + __bool::__hash() (x . member) +
                        __bool::__hash() (x . ok) + vector__ivy__expr::__t::__hash() (x . failed) +
                        __bool::__hash() (x . error_reported);
                }
            };
            
        };
        
    }
    
}
// Make a new type decorator state
namespace ivy
{
    namespace decost
    {
        ivy::decost::__t make ();
        
    }
    
}
namespace ivy
{
    namespace decost
    {
        void typeinf_show_str  (const str::__t &s);
        
    }
    
}
// Unify a pair of types. Sets ok to false if the types cannot
// be unified.
namespace ivy
{
    namespace decost
    {
        void show_unifying  (const str::__t &x,const str::__t &y);
        
    }
    
}
namespace ivy
{
    namespace decost
    {
        void show_ok  (const __bool &res);
        
    }
    
}
namespace ivy
{
    namespace elidest
    {
        namespace map
        {
            struct rec
            {
                __bool full;
                
                __bool val;
                
                 rec () {}
                 rec  (long long value) {}
                 operator std::size_t () const {
                    return 0;
                }
                static bool __is_seq () {
                    return false;
                }
                ivy::native_bool operator ==  (const rec &other) const
                {
                    return full == other . full & val == other . val;
                }
                ivy::native_bool operator !=  (const rec &other) const {
                    return ! ((*this) == other);
                }
                bool __is_zero () const {
                    return full . __is_zero() & val . __is_zero();
                }
                struct __hash
                {
                    std::size_t operator ()  (const rec &x) const
                    {
                        return __bool::__hash() (x . full) + __bool::__hash() (x . val);
                    }
                };
                
            };
            
        }
        
    }
    
}
namespace ivy
{
    namespace elidest
    {
        namespace map
        {
            struct __t
            {
                ivy::vector< ivy::elidest::map::rec,ivy::ptr< ivy::ident::__t > > map;
                
                void set  (const ivy::ptr< ivy::ident::__t > &x,const __bool &y);
                
                void get  (const ivy::ptr< ivy::ident::__t > &x,__bool &y) const;
                
                __bool mem  (const ivy::ptr< ivy::ident::__t > &x) const;
                
                void remove  (const ivy::ptr< ivy::ident::__t > &x);
                
                __bool value  (const ivy::ptr< ivy::ident::__t > &x) const;
                
                 __t () {}
                 __t  (long long value) {}
                 operator std::size_t () const {
                    return 0;
                }
                static bool __is_seq () {
                    return false;
                }
                ivy::native_bool operator ==  (const __t &other) const {
                    return map == other . map;
                }
                ivy::native_bool operator !=  (const __t &other) const {
                    return ! ((*this) == other);
                }
                bool __is_zero () const {
                    return map . __is_zero();
                }
                struct __hash
                {
                    std::size_t operator ()  (const __t &x) const
                    {
                        return
                            ivy::vector< ivy::elidest::map::rec,ivy::ptr< ivy::ident::__t > >::__hash()
                                (x . map);
                    }
                };
                
            };
            
        }
        
    }
    
}
namespace ivy
{
    namespace elidest
    {
        namespace map
        {
            ivy::elidest::map::__t empty ();
            
        }
        
    }
    
}
namespace ivy
{
    namespace elidest
    {
        struct __t
        {
            ivy::elidest::map::__t seen;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const {
                return seen == other . seen;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return seen . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return ivy::elidest::map::__t::__hash() (x . seen);
                }
            };
            
        };
        
    }
    
}
// Called in case of an error typing expression `e`. 
namespace ivy
{
    void type_error  (const ivy::ptr< ivy::expr::__t > &e,ivy::decost::__t &st);
    
}
namespace ivy
{
    void cannot_infer  (const ivy::ptr< ivy::expr::__t > &e,const ivy::ptr< ivy::expr::__t > &t);
    
}
namespace ivy
{
    void report_cannot_infer  (const str::__t &s1,const str::__t &s2);
    
}
// This takes a vector of expressions and a type context, returning
// the expressions with types inferred.
namespace ivy
{
    void type_infer_vec  (vector__ivy__expr::__t &es,const ivy::symeval::__t &tc);
    
}
namespace ivy
{
    void type_infer_known  (ivy::ptr< ivy::expr::__t > &e,const ivy::ptr< ivy::expr::__t > &ty,const
        ivy::symeval::__t &tc);
    
}
// Unify the types of two expressions
namespace ivy
{
    void type_unify_exprs  (ivy::ptr< ivy::expr::__t > &e1,ivy::ptr< ivy::expr::__t > &e2,const ivy::symeval::__t
        &tc);
    
}
namespace ivy
{
    void range_type  (ivy::ptr< ivy::expr::__t > &s);
    
}
namespace ivy
{
    namespace type_context
    {
        struct stack_entry
        {
            ivy::ptr< ivy::ident::__t > id;
            
            __bool any;
            
            ivy::ptr< ivy::expr::__t > val;
            
             stack_entry () {}
             stack_entry  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const stack_entry &other) const
            {
                return id == other . id & any == other . any & val == other . val;
            }
            ivy::native_bool operator !=  (const stack_entry &other) const
            {
                return ! ((*this) == other);
            }
            bool __is_zero () const
            {
                return id . __is_zero() & any . __is_zero() & val . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const stack_entry &x) const
                {
                    return ivy::ptr< ivy::ident::__t >::__hash() (x . id) +
                        __bool::__hash() (x . any) + ivy::ptr< ivy::expr::__t >::__hash() (x . val);
                }
            };
            
        };
        
    }
    
}
namespace vector__ivy__type_context__stack_entry
{
    namespace domain
    {
        struct __t : ivy::native_unsigned< size_t >
        {
            vector__ivy__type_context__stack_entry::domain::__t next () const;
            
            vector__ivy__type_context__stack_entry::domain::__t prev () const;
            
             __t () {}
             __t  (long long value) : ivy::native_unsigned< size_t > (value) {}
             __t  (const ivy::native_unsigned< size_t > &value) :
                ivy::native_unsigned< size_t > (value) {}
             operator ivy::native_unsigned< size_t > () const {
                return (*this);
            }
        };
        
    }
    
}
namespace vector__ivy__type_context__stack_entry
{
    struct __t
    {
        ivy::vector< ivy::type_context::stack_entry,vector__ivy__type_context__stack_entry::domain::__t >
            value;
        
        vector__ivy__type_context__stack_entry::domain::__t end;
        
        vector__ivy__type_context__stack_entry::domain::__t begin () const;
        
        void set  (const vector__ivy__type_context__stack_entry::domain::__t &i,const ivy::type_context::stack_entry
            &v);
        
        void append  (const ivy::type_context::stack_entry &c);
        
        void extend  (const vector__ivy__type_context__stack_entry::__t &x);
        
        void resize  (const vector__ivy__type_context__stack_entry::domain::__t &end);
        
        ivy::type_context::stack_entry back () const;
        
        void pop_back ();
        
        vector__ivy__type_context__stack_entry::__t segment  (const
            vector__ivy__type_context__stack_entry::domain::__t &beg,const
            vector__ivy__type_context__stack_entry::domain::__t &en) const;
        
        void reverse ();
        
         __t () {}
         __t  (long long value) {}
         operator std::size_t () const {
            return 0;
        }
        static bool __is_seq () {
            return false;
        }
        ivy::native_bool operator ==  (const __t &other) const
        {
            return value == other . value & end == other . end;
        }
        ivy::native_bool operator !=  (const __t &other) const {
            return ! ((*this) == other);
        }
        bool __is_zero () const {
            return value . __is_zero() & end . __is_zero();
        }
        struct __hash
        {
            std::size_t operator ()  (const __t &x) const
            {
                return
                    ivy::vector< ivy::type_context::stack_entry,vector__ivy__type_context__stack_entry::domain::__t >::__hash()
                        (x . value) +
                    vector__ivy__type_context__stack_entry::domain::__t::__hash() (x . end);
            }
        };
        
    };
    
}
namespace vector__ivy__type_context__stack_entry
{
    vector__ivy__type_context__stack_entry::__t empty ();
    
}
namespace ivy
{
    namespace type_context
    {
        struct __t
        {
            ivy::symeval::__t m;
            
            vector__ivy__type_context__stack_entry::__t stack;
            
            void set  (const ivy::ptr< ivy::expr::__t > &typing);
            
            void push  (const ivy::ptr< ivy::expr::__t > &typing);
            
            void pop ();
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return m == other . m & stack == other . stack;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return m . __is_zero() & stack . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return ivy::symeval::__t::__hash() (x . m) +
                        vector__ivy__type_context__stack_entry::__t::__hash() (x . stack);
                }
            };
            
        };
        
    }
    
}
namespace ivy
{
    namespace typeinferst
    {
        struct __t
        {
            
            // Type context
            
            ivy::type_context::__t tc;
            
            
            // The subtyping relation
            
            ivy::subtypes::__t subtype_rel;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return tc == other . tc & subtype_rel == other . subtype_rel;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return tc . __is_zero() & subtype_rel . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return ivy::type_context::__t::__hash() (x . tc) +
                        ivy::subtypes::__t::__hash() (x . subtype_rel);
                }
            };
            
        };
        
    }
    
}
// Bottom up type inference
namespace ivy
{
    void bottom_up_type  (ivy::ptr< ivy::expr::__t > &e,const ivy::typeinferst::__t &st,__bool &ok);
    
}
// Bottom-up type inference for a vector of arguments `es` of a
// function `func`.  If `func` has a type, then we upcast the
// arguments to their expected types.  We don't worry about whether
// `func` takes the expect number of arguments here.  If it
// doesn't, type inference will fail later.
namespace ivy
{
    void bottom_up_types  (vector__ivy__expr::__t &es,const ivy::ptr< ivy::expr::__t > &func,const
        ivy::typeinferst::__t &st,__bool &ok);
    
}
// Check if type `rhsty` is a subtype of `lhsty`.
namespace ivy
{
    __bool is_subtype  (const ivy::ptr< ivy::expr::__t > &rhsty,const ivy::ptr< ivy::expr::__t > &lhsty,const
        ivy::typeinferst::__t &st);
    
}
// Add an upcast operator to `rhs` if it is subtype of `lhs`. This is
// used for assignments, and argument passing. This has to work on tuples
// to handle multiple assignment. 
namespace ivy
{
    void make_cast  (const ivy::ptr< ivy::expr::__t > &lhsty,ivy::ptr< ivy::expr::__t > &rhs,const
        ivy::typeinferst::__t &st);
    
}
// After type inference, we can desugar assignments like `var x := y` to
// `var x : t; x := y`. This makes things a bit eassier on subsequent passes.
namespace ivy
{
    void desugar_asgn  (ivy::ptr< ivy::stmt::__t > &s,vector__ivy__stmt::__t &varsts);
    
}
namespace ivy
{
    void setup_formals  (const vector__ivy__expr::__t &es,const __bool &val,ivy::typeinferst::__t &st);
    
}
namespace ivy
{
    vector__ivy__expr::__t get_func_params  (const ivy::ptr< ivy::expr::__t > &typing);
    
}
namespace cpp
{
    namespace verb
    {
        
        enum __enum___t  {none,arrow,plus,times,colon,app,empty,dot,__new,numeral,fltnum,castv,boolv,truev,falsev,__and,__or,__not,iff,equals,notequals,lt,leq,gt,geq,minus,div,string,ite,comma,varv,logvar,isav};
        
        struct __t : ivy::native_enum< __enum___t >
        {
             __t () {}
             __t  (long long value) : ivy::native_enum< __enum___t > (value) {}
             __t  (const ivy::native_enum< __enum___t > &value) :
                ivy::native_enum< __enum___t > (value) {}
             operator ivy::native_enum< __enum___t > () const {
                return (*this);
            }
        };
        
    }
    
}
namespace cpp
{
    ivy::vector< cpp::verb::__t,str::__t > str_to_verb;
    
}
namespace cpp
{
    ivy::vector< str::__t,cpp::verb::__t > verb_to_str;
    
}
namespace cpp
{
    ivy::vector< priority::__t,cpp::verb::__t > verb_to_prio;
    
}
namespace cpp
{
    ivy::vector< pos::__t,cpp::verb::__t > verb_to_arity;
    
}
namespace cpp
{
    __bool is_logvar_name  (const str::__t &name);
    
}
namespace cpp
{
    cpp::verb::__t verb_from_name  (const str::__t &name);
    
}
namespace cpp
{
    namespace ident
    {
        struct __t
        {
            virtual void encode  (pretty::__t &b,const priority::__t &prio) const;
            
            virtual str::__t to_str () const;
            
            virtual ivy::ptr< cpp::ident::__t > get_namesp () const;
            
            virtual ivy::ptr< cpp::ident::__t > get_member () const;
            
            virtual vector__cpp__ident::__t get_subscripts () const;
            
            virtual ivy::ptr< cpp::ident::__t > prefix  (const ivy::ptr< cpp::ident::__t > &pref)
                const;
            
            virtual cpp::strident::__t get_last () const;
            
            virtual cpp::verb::__t get_verb () const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const {
                return true;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return true;
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const {
                    return 0;
                }
            };
            
            virtual ivy::ptr< __t > __upcast () const {
                return (*this);
            }
            virtual  ~__t () {}
        };
        
    }
    
}
namespace vector__cpp__ident
{
    namespace domain
    {
        struct __t : ivy::native_unsigned< size_t >
        {
            vector__cpp__ident::domain::__t next () const;
            
            vector__cpp__ident::domain::__t prev () const;
            
             __t () {}
             __t  (long long value) : ivy::native_unsigned< size_t > (value) {}
             __t  (const ivy::native_unsigned< size_t > &value) :
                ivy::native_unsigned< size_t > (value) {}
             operator ivy::native_unsigned< size_t > () const {
                return (*this);
            }
        };
        
    }
    
}
namespace vector__cpp__ident
{
    struct __t
    {
        ivy::vector< ivy::ptr< cpp::ident::__t >,vector__cpp__ident::domain::__t > value;
        
        vector__cpp__ident::domain::__t end;
        
        vector__cpp__ident::domain::__t begin () const;
        
        void set  (const vector__cpp__ident::domain::__t &i,const ivy::ptr< cpp::ident::__t > &v);
        
        void append  (const ivy::ptr< cpp::ident::__t > &c);
        
        void extend  (const vector__cpp__ident::__t &x);
        
        void resize  (const vector__cpp__ident::domain::__t &end);
        
        ivy::ptr< cpp::ident::__t > back () const;
        
        void pop_back ();
        
        vector__cpp__ident::__t segment  (const vector__cpp__ident::domain::__t &beg,const
            vector__cpp__ident::domain::__t &en) const;
        
        void reverse ();
        
         __t () {}
         __t  (long long value) {}
         operator std::size_t () const {
            return 0;
        }
        static bool __is_seq () {
            return false;
        }
        ivy::native_bool operator ==  (const __t &other) const
        {
            return value == other . value & end == other . end;
        }
        ivy::native_bool operator !=  (const __t &other) const {
            return ! ((*this) == other);
        }
        bool __is_zero () const {
            return value . __is_zero() & end . __is_zero();
        }
        struct __hash
        {
            std::size_t operator ()  (const __t &x) const
            {
                return
                    ivy::vector< ivy::ptr< cpp::ident::__t >,vector__cpp__ident::domain::__t >::__hash()
                        (x . value) + vector__cpp__ident::domain::__t::__hash() (x . end);
            }
        };
        
    };
    
}
namespace vector__cpp__ident
{
    vector__cpp__ident::__t empty ();
    
}
namespace cpp
{
    namespace strident
    {
        struct __t : cpp::ident::__t
        {
            str::__t val;
            
            vector__cpp__ident::__t subscrs;
            
            void encode  (pretty::__t &b,const priority::__t &prio) const;
            
            str::__t to_str () const;
            
            ivy::ptr< cpp::ident::__t > prefix  (const ivy::ptr< cpp::ident::__t > &pref) const;
            
            cpp::strident::__t get_last () const;
            
            cpp::verb::__t get_verb () const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return val == other . val & subscrs == other . subscrs;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return val . __is_zero() & subscrs . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return str::__t::__hash() (x . val) +
                        vector__cpp__ident::__t::__hash() (x . subscrs);
                }
            };
            
            virtual ivy::ptr< cpp::ident::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace cpp
{
    namespace strident
    {
        ivy::ptr< cpp::ident::__t > make  (const str::__t &val);
        
    }
    
}
namespace cpp
{
    namespace strident
    {
        ivy::ptr< cpp::ident::__t > make1  (const str::__t &val,const ivy::ptr< cpp::ident::__t > &arg);
        
    }
    
}
namespace cpp
{
    namespace strident
    {
        void parse  (pstate::__t &st,cpp::strident::__t &id);
        
    }
    
}
namespace cpp
{
    namespace numident
    {
        struct __t : cpp::ident::__t
        {
            pos::__t val;
            
            void encode  (pretty::__t &b,const priority::__t &prio) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const {
                return val == other . val;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return val . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const {
                    return pos::__t::__hash() (x . val);
                }
            };
            
            virtual ivy::ptr< cpp::ident::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace cpp
{
    namespace numident
    {
        ivy::ptr< cpp::ident::__t > make  (const pos::__t &val);
        
    }
    
}
namespace cpp
{
    namespace dotident
    {
        struct __t : cpp::ident::__t
        {
            ivy::ptr< cpp::ident::__t > namesp;
            
            cpp::strident::__t member;
            
            void encode  (pretty::__t &b,const priority::__t &prio) const;
            
            str::__t to_str () const;
            
            ivy::ptr< cpp::ident::__t > get_namesp () const;
            
            ivy::ptr< cpp::ident::__t > get_member () const;
            
            ivy::ptr< cpp::ident::__t > prefix  (const ivy::ptr< cpp::ident::__t > &pref) const;
            
            cpp::strident::__t get_last () const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return namesp == other . namesp & member == other . member;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return namesp . __is_zero() & member . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return ivy::ptr< cpp::ident::__t >::__hash() (x . namesp) +
                        cpp::strident::__t::__hash() (x . member);
                }
            };
            
            virtual ivy::ptr< cpp::ident::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace cpp
{
    namespace dotident
    {
        ivy::ptr< cpp::ident::__t > make  (const ivy::ptr< cpp::ident::__t > &namesp,const cpp::strident::__t
            &member);
        
    }
    
}
namespace cpp
{
    namespace expr
    {
        struct __t
        {
            virtual void encode  (pretty::__t &b,const priority::__t &prio) const;
            
            virtual str::__t enc () const;
            
            virtual cpp::verb::__t get_verb () const;
            
            virtual cpp::verb::__t get_verb_typed () const;
            
            virtual __bool is  (const cpp::verb::__t &vrb) const;
            
            virtual __bool is_typed  (const cpp::verb::__t &vrb) const;
            
            virtual ivy::ptr< cpp::expr::__t > get_arg  (const vector__cpp__expr::domain::__t &p)
                const;
            
            virtual ivy::ptr< cpp::ident::__t > get_name () const;
            
            virtual cpp::verb::__t app_verb () const;
            
            virtual ivy::ptr< annot::__t > get_ann () const;
            
            virtual ivy::ptr< cpp::expr::__t > get_func () const;
            
            virtual vector__cpp__expr::__t get_args () const;
            
            virtual ivy::ptr< cpp::expr::__t > prefix  (const ivy::ptr< cpp::ident::__t > &pref)
                const;
            
            virtual __bool eq  (const ivy::ptr< cpp::expr::__t > &e2) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const {
                return true;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return true;
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const {
                    return 0;
                }
            };
            
            virtual ivy::ptr< __t > __upcast () const {
                return (*this);
            }
            virtual  ~__t () {}
        };
        
    }
    
}
namespace cpp
{
    namespace expr
    {
        ivy::ptr< cpp::expr::__t > dec  (const str::__t &s);
        
    }
    
}
namespace cpp
{
    namespace expr
    {
        str::__t encdec  (const str::__t &s);
        
    }
    
}
namespace cpp
{
    namespace symbol
    {
        struct __t : cpp::expr::__t
        {
            ivy::ptr< cpp::ident::__t > name;
            
            cpp::verb::__t vrb;
            
            ivy::ptr< annot::__t > ann;
            
            void encode  (pretty::__t &b,const priority::__t &prio) const;
            
            cpp::verb::__t get_verb () const;
            
            ivy::ptr< cpp::ident::__t > get_name () const;
            
            ivy::ptr< annot::__t > get_ann () const;
            
            ivy::ptr< cpp::expr::__t > prefix  (const ivy::ptr< cpp::ident::__t > &pref) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return name == other . name & vrb == other . vrb & ann == other . ann;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const
            {
                return name . __is_zero() & vrb . __is_zero() & ann . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return ivy::ptr< cpp::ident::__t >::__hash() (x . name) +
                        cpp::verb::__t::__hash() (x . vrb) +
                        ivy::ptr< annot::__t >::__hash() (x . ann);
                }
            };
            
            virtual ivy::ptr< cpp::expr::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace cpp
{
    namespace symbol
    {
        ivy::ptr< cpp::expr::__t > make  (const ivy::ptr< cpp::ident::__t > &name,const ivy::ptr< annot::__t >
            &ann);
        
    }
    
}
namespace cpp
{
    namespace symbol
    {
        ivy::ptr< cpp::expr::__t > makestr  (const str::__t &name,const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace cpp
{
    namespace symbol
    {
        ivy::ptr< cpp::expr::__t > makestr1  (const str::__t &name,const ivy::ptr< cpp::ident::__t >
            &arg,const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace cpp
{
    namespace symbol
    {
        ivy::ptr< cpp::expr::__t > makenum  (const pos::__t &num,const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace cpp
{
    namespace symbol
    {
        void parse  (pstate::__t &st,ivy::ptr< cpp::expr::__t > &res);
        
    }
    
}
namespace vector__cpp__expr
{
    namespace domain
    {
        struct __t : ivy::native_unsigned< size_t >
        {
            vector__cpp__expr::domain::__t next () const;
            
            vector__cpp__expr::domain::__t prev () const;
            
             __t () {}
             __t  (long long value) : ivy::native_unsigned< size_t > (value) {}
             __t  (const ivy::native_unsigned< size_t > &value) :
                ivy::native_unsigned< size_t > (value) {}
             operator ivy::native_unsigned< size_t > () const {
                return (*this);
            }
        };
        
    }
    
}
namespace vector__cpp__expr
{
    struct __t
    {
        ivy::vector< ivy::ptr< cpp::expr::__t >,vector__cpp__expr::domain::__t > value;
        
        vector__cpp__expr::domain::__t end;
        
        vector__cpp__expr::domain::__t begin () const;
        
        void set  (const vector__cpp__expr::domain::__t &i,const ivy::ptr< cpp::expr::__t > &v);
        
        void append  (const ivy::ptr< cpp::expr::__t > &c);
        
        void extend  (const vector__cpp__expr::__t &x);
        
        void resize  (const vector__cpp__expr::domain::__t &end);
        
        ivy::ptr< cpp::expr::__t > back () const;
        
        void pop_back ();
        
        vector__cpp__expr::__t segment  (const vector__cpp__expr::domain::__t &beg,const
            vector__cpp__expr::domain::__t &en) const;
        
        void reverse ();
        
         __t () {}
         __t  (long long value) {}
         operator std::size_t () const {
            return 0;
        }
        static bool __is_seq () {
            return false;
        }
        ivy::native_bool operator ==  (const __t &other) const
        {
            return value == other . value & end == other . end;
        }
        ivy::native_bool operator !=  (const __t &other) const {
            return ! ((*this) == other);
        }
        bool __is_zero () const {
            return value . __is_zero() & end . __is_zero();
        }
        struct __hash
        {
            std::size_t operator ()  (const __t &x) const
            {
                return
                    ivy::vector< ivy::ptr< cpp::expr::__t >,vector__cpp__expr::domain::__t >::__hash()
                        (x . value) + vector__cpp__expr::domain::__t::__hash() (x . end);
            }
        };
        
    };
    
}
namespace vector__cpp__expr
{
    vector__cpp__expr::__t empty ();
    
}
namespace cpp
{
    namespace app
    {
        struct __t : cpp::expr::__t
        {
            ivy::ptr< cpp::expr::__t > func;
            
            vector__cpp__expr::__t args;
            
            ivy::ptr< annot::__t > ann;
            
            void encode  (pretty::__t &b,const priority::__t &prio) const;
            
            __bool is  (const cpp::verb::__t &vrb) const;
            
            __bool is_typed  (const cpp::verb::__t &vrb) const;
            
            cpp::verb::__t app_verb () const;
            
            ivy::ptr< cpp::expr::__t > get_func () const;
            
            vector__cpp__expr::__t get_args () const;
            
            ivy::ptr< cpp::expr::__t > get_arg  (const vector__cpp__expr::domain::__t &p) const;
            
            ivy::ptr< annot::__t > get_ann () const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return func == other . func & args == other . args & ann == other . ann;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const
            {
                return func . __is_zero() & args . __is_zero() & ann . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return ivy::ptr< cpp::expr::__t >::__hash() (x . func) +
                        vector__cpp__expr::__t::__hash() (x . args) +
                        ivy::ptr< annot::__t >::__hash() (x . ann);
                }
            };
            
            virtual ivy::ptr< cpp::expr::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace cpp
{
    namespace app
    {
        ivy::ptr< cpp::expr::__t > make  (const ivy::ptr< cpp::expr::__t > &func,const
            vector__cpp__expr::__t &args,const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace cpp
{
    namespace app
    {
        ivy::ptr< cpp::expr::__t > make1  (const ivy::ptr< cpp::expr::__t > &func,const ivy::ptr< cpp::expr::__t >
            &arg0,const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace cpp
{
    namespace app
    {
        ivy::ptr< cpp::expr::__t > make2  (const ivy::ptr< cpp::expr::__t > &func,const ivy::ptr< cpp::expr::__t >
            &arg0,const ivy::ptr< cpp::expr::__t > &arg1,const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace cpp
{
    namespace variable
    {
        struct __t : cpp::expr::__t
        {
            pos::__t idx;
            
            ivy::ptr< annot::__t > ann;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return idx == other . idx & ann == other . ann;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return idx . __is_zero() & ann . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return pos::__t::__hash() (x . idx) + ivy::ptr< annot::__t >::__hash() (x . ann);
                }
            };
            
            virtual ivy::ptr< cpp::expr::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace cpp
{
    namespace variable
    {
        ivy::ptr< cpp::expr::__t > make  (const pos::__t &idx);
        
    }
    
}
namespace cpp
{
    namespace pi
    {
        struct __t : cpp::expr::__t
        {
            vector__cpp__expr::__t vars;
            
            ivy::ptr< cpp::expr::__t > body;
            
            ivy::ptr< annot::__t > ann;
            
            void encode  (pretty::__t &b,const priority::__t &prio) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return vars == other . vars & body == other . body & ann == other . ann;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const
            {
                return vars . __is_zero() & body . __is_zero() & ann . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return vector__cpp__expr::__t::__hash() (x . vars) +
                        ivy::ptr< cpp::expr::__t >::__hash() (x . body) +
                        ivy::ptr< annot::__t >::__hash() (x . ann);
                }
            };
            
            virtual ivy::ptr< cpp::expr::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace cpp
{
    namespace pi
    {
        ivy::ptr< cpp::expr::__t > make  (const vector__cpp__expr::__t &vars,const ivy::ptr< cpp::expr::__t >
            &body,const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace cpp
{
    namespace iff
    {
        ivy::ptr< cpp::expr::__t > make  (const ivy::ptr< cpp::expr::__t > &lhs,const ivy::ptr< cpp::expr::__t >
            &rhs,const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace cpp
{
    namespace iff
    {
        ivy::ptr< cpp::expr::__t > fold_left  (const vector__cpp__expr::__t &args,const ivy::ptr< annot::__t >
            &ann);
        
    }
    
}
namespace cpp
{
    namespace iff
    {
        vector__cpp__expr::__t unfold_left  (const ivy::ptr< cpp::expr::__t > &s);
        
    }
    
}
namespace cpp
{
    namespace __or
    {
        ivy::ptr< cpp::expr::__t > make  (const ivy::ptr< cpp::expr::__t > &lhs,const ivy::ptr< cpp::expr::__t >
            &rhs,const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace cpp
{
    namespace __or
    {
        ivy::ptr< cpp::expr::__t > fold_left  (const vector__cpp__expr::__t &args,const ivy::ptr< annot::__t >
            &ann);
        
    }
    
}
namespace cpp
{
    namespace __or
    {
        vector__cpp__expr::__t unfold_left  (const ivy::ptr< cpp::expr::__t > &s);
        
    }
    
}
namespace cpp
{
    namespace __and
    {
        ivy::ptr< cpp::expr::__t > make  (const ivy::ptr< cpp::expr::__t > &lhs,const ivy::ptr< cpp::expr::__t >
            &rhs,const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace cpp
{
    namespace __and
    {
        ivy::ptr< cpp::expr::__t > fold_left  (const vector__cpp__expr::__t &args,const ivy::ptr< annot::__t >
            &ann);
        
    }
    
}
namespace cpp
{
    namespace __and
    {
        vector__cpp__expr::__t unfold_left  (const ivy::ptr< cpp::expr::__t > &s);
        
    }
    
}
namespace cpp
{
    namespace lt
    {
        ivy::ptr< cpp::expr::__t > make  (const ivy::ptr< cpp::expr::__t > &lhs,const ivy::ptr< cpp::expr::__t >
            &rhs,const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace cpp
{
    namespace lt
    {
        ivy::ptr< cpp::expr::__t > fold_left  (const vector__cpp__expr::__t &args,const ivy::ptr< annot::__t >
            &ann);
        
    }
    
}
namespace cpp
{
    namespace lt
    {
        vector__cpp__expr::__t unfold_left  (const ivy::ptr< cpp::expr::__t > &s);
        
    }
    
}
namespace cpp
{
    namespace leq
    {
        ivy::ptr< cpp::expr::__t > make  (const ivy::ptr< cpp::expr::__t > &lhs,const ivy::ptr< cpp::expr::__t >
            &rhs,const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace cpp
{
    namespace leq
    {
        ivy::ptr< cpp::expr::__t > fold_left  (const vector__cpp__expr::__t &args,const ivy::ptr< annot::__t >
            &ann);
        
    }
    
}
namespace cpp
{
    namespace leq
    {
        vector__cpp__expr::__t unfold_left  (const ivy::ptr< cpp::expr::__t > &s);
        
    }
    
}
namespace cpp
{
    namespace gt
    {
        ivy::ptr< cpp::expr::__t > make  (const ivy::ptr< cpp::expr::__t > &lhs,const ivy::ptr< cpp::expr::__t >
            &rhs,const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace cpp
{
    namespace gt
    {
        ivy::ptr< cpp::expr::__t > fold_left  (const vector__cpp__expr::__t &args,const ivy::ptr< annot::__t >
            &ann);
        
    }
    
}
namespace cpp
{
    namespace gt
    {
        vector__cpp__expr::__t unfold_left  (const ivy::ptr< cpp::expr::__t > &s);
        
    }
    
}
namespace cpp
{
    namespace geq
    {
        ivy::ptr< cpp::expr::__t > make  (const ivy::ptr< cpp::expr::__t > &lhs,const ivy::ptr< cpp::expr::__t >
            &rhs,const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace cpp
{
    namespace geq
    {
        ivy::ptr< cpp::expr::__t > fold_left  (const vector__cpp__expr::__t &args,const ivy::ptr< annot::__t >
            &ann);
        
    }
    
}
namespace cpp
{
    namespace geq
    {
        vector__cpp__expr::__t unfold_left  (const ivy::ptr< cpp::expr::__t > &s);
        
    }
    
}
namespace cpp
{
    namespace plus
    {
        ivy::ptr< cpp::expr::__t > make  (const ivy::ptr< cpp::expr::__t > &lhs,const ivy::ptr< cpp::expr::__t >
            &rhs,const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace cpp
{
    namespace plus
    {
        ivy::ptr< cpp::expr::__t > fold_left  (const vector__cpp__expr::__t &args,const ivy::ptr< annot::__t >
            &ann);
        
    }
    
}
namespace cpp
{
    namespace plus
    {
        vector__cpp__expr::__t unfold_left  (const ivy::ptr< cpp::expr::__t > &s);
        
    }
    
}
namespace cpp
{
    namespace minus
    {
        ivy::ptr< cpp::expr::__t > make  (const ivy::ptr< cpp::expr::__t > &lhs,const ivy::ptr< cpp::expr::__t >
            &rhs,const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace cpp
{
    namespace minus
    {
        ivy::ptr< cpp::expr::__t > fold_left  (const vector__cpp__expr::__t &args,const ivy::ptr< annot::__t >
            &ann);
        
    }
    
}
namespace cpp
{
    namespace minus
    {
        vector__cpp__expr::__t unfold_left  (const ivy::ptr< cpp::expr::__t > &s);
        
    }
    
}
namespace cpp
{
    namespace times
    {
        ivy::ptr< cpp::expr::__t > make  (const ivy::ptr< cpp::expr::__t > &lhs,const ivy::ptr< cpp::expr::__t >
            &rhs,const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace cpp
{
    namespace times
    {
        ivy::ptr< cpp::expr::__t > fold_left  (const vector__cpp__expr::__t &args,const ivy::ptr< annot::__t >
            &ann);
        
    }
    
}
namespace cpp
{
    namespace times
    {
        vector__cpp__expr::__t unfold_left  (const ivy::ptr< cpp::expr::__t > &s);
        
    }
    
}
namespace cpp
{
    namespace div
    {
        ivy::ptr< cpp::expr::__t > make  (const ivy::ptr< cpp::expr::__t > &lhs,const ivy::ptr< cpp::expr::__t >
            &rhs,const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace cpp
{
    namespace div
    {
        ivy::ptr< cpp::expr::__t > fold_left  (const vector__cpp__expr::__t &args,const ivy::ptr< annot::__t >
            &ann);
        
    }
    
}
namespace cpp
{
    namespace div
    {
        vector__cpp__expr::__t unfold_left  (const ivy::ptr< cpp::expr::__t > &s);
        
    }
    
}
namespace cpp
{
    namespace empty
    {
        ivy::ptr< cpp::expr::__t > make  (const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace cpp
{
    namespace boolv
    {
        ivy::ptr< cpp::expr::__t > make  (const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace cpp
{
    namespace truev
    {
        ivy::ptr< cpp::expr::__t > make  (const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace cpp
{
    namespace falsev
    {
        ivy::ptr< cpp::expr::__t > make  (const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace cpp
{
    namespace comma
    {
        ivy::ptr< cpp::expr::__t > make  (const ivy::ptr< cpp::expr::__t > &lhs,const ivy::ptr< cpp::expr::__t >
            &rhs,const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace cpp
{
    namespace comma
    {
        ivy::ptr< cpp::expr::__t > fold_left  (const vector__cpp__expr::__t &args,const ivy::ptr< annot::__t >
            &ann);
        
    }
    
}
namespace cpp
{
    namespace comma
    {
        vector__cpp__expr::__t unfold_left  (const ivy::ptr< cpp::expr::__t > &s);
        
    }
    
}
namespace cpp
{
    namespace dot
    {
        ivy::ptr< cpp::expr::__t > make  (const ivy::ptr< cpp::expr::__t > &lhs,const ivy::ptr< cpp::expr::__t >
            &rhs,const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace cpp
{
    namespace dot
    {
        ivy::ptr< cpp::expr::__t > fold_left  (const vector__cpp__expr::__t &args,const ivy::ptr< annot::__t >
            &ann);
        
    }
    
}
namespace cpp
{
    namespace dot
    {
        vector__cpp__expr::__t unfold_left  (const ivy::ptr< cpp::expr::__t > &s);
        
    }
    
}
namespace cpp
{
    namespace expr
    {
        vector__cpp__expr::__t foo;
        
    }
    
}
namespace cpp
{
    namespace expr
    {
        void parse  (pstate::__t &st,const priority::__t &prio,ivy::ptr< cpp::expr::__t > &res);
        
    }
    
}
namespace cpp
{
    namespace expr
    {
        namespace tup
        {
            void encode  (const vector__cpp__expr::__t &s,pretty::__t &b,const priority::__t &prio);
            
        }
        
    }
    
}
namespace cpp
{
    namespace expr
    {
        namespace tup
        {
            void parse  (pstate::__t &st,const priority::__t &prio,vector__cpp__expr::__t &res);
            
        }
        
    }
    
}
namespace cpp
{
    namespace stmt
    {
        struct __t
        {
            virtual void encode  (pretty::__t &b,const priority::__t &prio) const;
            
            virtual str::__t enc () const;
            
            virtual ivy::ptr< cpp::expr::__t > get_expr () const;
            
            virtual ivy::ptr< cpp::expr::__t > get_lhs () const;
            
            virtual ivy::ptr< cpp::expr::__t > get_rhs () const;
            
            virtual ivy::ptr< annot::__t > get_ann () const;
            
            virtual void fix_borrow  (ivy::tocppst::__t &st,ivy::ptr< cpp::stmt::__t > &res) const;
            
            virtual void setup_fix_borrow  (ivy::tocppst::__t &st,__bool &ok) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const {
                return true;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return true;
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const {
                    return 0;
                }
            };
            
            virtual ivy::ptr< __t > __upcast () const {
                return (*this);
            }
            virtual  ~__t () {}
        };
        
    }
    
}
namespace cpp
{
    namespace stmt
    {
        ivy::ptr< cpp::stmt::__t > dec  (const str::__t &s);
        
    }
    
}
namespace cpp
{
    namespace stmt
    {
        str::__t encdec  (const str::__t &s);
        
    }
    
}
namespace cpp
{
    namespace asgn
    {
        struct __t : cpp::stmt::__t
        {
            ivy::ptr< cpp::expr::__t > lhs;
            
            ivy::ptr< cpp::expr::__t > rhs;
            
            ivy::ptr< annot::__t > ann;
            
            void encode  (pretty::__t &b,const priority::__t &prio) const;
            
            void encode_int  (pretty::__t &b,const priority::__t &prio) const;
            
            ivy::ptr< cpp::expr::__t > get_lhs () const;
            
            ivy::ptr< cpp::expr::__t > get_rhs () const;
            
            ivy::ptr< annot::__t > get_ann () const;
            
            void fix_borrow  (ivy::tocppst::__t &st,ivy::ptr< cpp::stmt::__t > &res) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return lhs == other . lhs & rhs == other . rhs & ann == other . ann;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const
            {
                return lhs . __is_zero() & rhs . __is_zero() & ann . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return ivy::ptr< cpp::expr::__t >::__hash() (x . lhs) +
                        ivy::ptr< cpp::expr::__t >::__hash() (x . rhs) +
                        ivy::ptr< annot::__t >::__hash() (x . ann);
                }
            };
            
            virtual ivy::ptr< cpp::stmt::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace cpp
{
    namespace asgn
    {
        ivy::ptr< cpp::stmt::__t > make  (const ivy::ptr< cpp::expr::__t > &x,const ivy::ptr< cpp::expr::__t >
            &y,const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace cpp
{
    namespace sequence
    {
        struct __t : cpp::stmt::__t
        {
            ivy::ptr< cpp::stmt::__t > lhs;
            
            ivy::ptr< cpp::stmt::__t > rhs;
            
            ivy::ptr< annot::__t > ann;
            
            void encode  (pretty::__t &b,const priority::__t &prio) const;
            
            void encode_int  (pretty::__t &b,const priority::__t &prio) const;
            
            ivy::ptr< annot::__t > get_ann () const;
            
            void fix_borrow  (ivy::tocppst::__t &st,ivy::ptr< cpp::stmt::__t > &resd) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return lhs == other . lhs & rhs == other . rhs & ann == other . ann;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const
            {
                return lhs . __is_zero() & rhs . __is_zero() & ann . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return ivy::ptr< cpp::stmt::__t >::__hash() (x . lhs) +
                        ivy::ptr< cpp::stmt::__t >::__hash() (x . rhs) +
                        ivy::ptr< annot::__t >::__hash() (x . ann);
                }
            };
            
            virtual ivy::ptr< cpp::stmt::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace cpp
{
    namespace sequence
    {
        ivy::ptr< cpp::stmt::__t > make  (const ivy::ptr< cpp::stmt::__t > &x,const ivy::ptr< cpp::stmt::__t >
            &y,const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace vector__cpp__stmt
{
    namespace domain
    {
        struct __t : ivy::native_unsigned< size_t >
        {
            vector__cpp__stmt::domain::__t next () const;
            
            vector__cpp__stmt::domain::__t prev () const;
            
             __t () {}
             __t  (long long value) : ivy::native_unsigned< size_t > (value) {}
             __t  (const ivy::native_unsigned< size_t > &value) :
                ivy::native_unsigned< size_t > (value) {}
             operator ivy::native_unsigned< size_t > () const {
                return (*this);
            }
        };
        
    }
    
}
namespace vector__cpp__stmt
{
    struct __t
    {
        ivy::vector< ivy::ptr< cpp::stmt::__t >,vector__cpp__stmt::domain::__t > value;
        
        vector__cpp__stmt::domain::__t end;
        
        vector__cpp__stmt::domain::__t begin () const;
        
        void set  (const vector__cpp__stmt::domain::__t &i,const ivy::ptr< cpp::stmt::__t > &v);
        
        void append  (const ivy::ptr< cpp::stmt::__t > &c);
        
        void extend  (const vector__cpp__stmt::__t &x);
        
        void resize  (const vector__cpp__stmt::domain::__t &end);
        
        ivy::ptr< cpp::stmt::__t > back () const;
        
        void pop_back ();
        
        vector__cpp__stmt::__t segment  (const vector__cpp__stmt::domain::__t &beg,const
            vector__cpp__stmt::domain::__t &en) const;
        
        void reverse ();
        
         __t () {}
         __t  (long long value) {}
         operator std::size_t () const {
            return 0;
        }
        static bool __is_seq () {
            return false;
        }
        ivy::native_bool operator ==  (const __t &other) const
        {
            return value == other . value & end == other . end;
        }
        ivy::native_bool operator !=  (const __t &other) const {
            return ! ((*this) == other);
        }
        bool __is_zero () const {
            return value . __is_zero() & end . __is_zero();
        }
        struct __hash
        {
            std::size_t operator ()  (const __t &x) const
            {
                return
                    ivy::vector< ivy::ptr< cpp::stmt::__t >,vector__cpp__stmt::domain::__t >::__hash()
                        (x . value) + vector__cpp__stmt::domain::__t::__hash() (x . end);
            }
        };
        
    };
    
}
namespace vector__cpp__stmt
{
    vector__cpp__stmt::__t empty ();
    
}
namespace cpp
{
    namespace sequence
    {
        vector__cpp__stmt::__t dummy;
        
    }
    
}
namespace cpp
{
    namespace sequence
    {
        ivy::ptr< cpp::stmt::__t > fold_right  (const vector__cpp__stmt::__t &args,const ivy::ptr< annot::__t >
            &ann);
        
    }
    
}
namespace cpp
{
    namespace skipst
    {
        struct __t : cpp::stmt::__t
        {
            ivy::ptr< annot::__t > ann;
            
            void encode  (pretty::__t &b,const priority::__t &prio) const;
            
            ivy::ptr< annot::__t > get_ann () const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const {
                return ann == other . ann;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return ann . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return ivy::ptr< annot::__t >::__hash() (x . ann);
                }
            };
            
            virtual ivy::ptr< cpp::stmt::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace cpp
{
    namespace skipst
    {
        ivy::ptr< cpp::stmt::__t > make  (const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace cpp
{
    namespace ifst
    {
        struct __t : cpp::stmt::__t
        {
            ivy::ptr< cpp::expr::__t > cond;
            
            ivy::ptr< cpp::stmt::__t > thenst;
            
            ivy::ptr< cpp::stmt::__t > elsest;
            
            ivy::ptr< annot::__t > ann;
            
            void encode  (pretty::__t &b,const priority::__t &prio) const;
            
            void encode_int  (pretty::__t &b,const priority::__t &prio) const;
            
            ivy::ptr< annot::__t > get_ann () const;
            
            void fix_borrow  (ivy::tocppst::__t &st,ivy::ptr< cpp::stmt::__t > &resd) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return cond == other . cond & thenst == other . thenst & elsest == other . elsest &
                    ann == other . ann;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const
            {
                return cond . __is_zero() & thenst . __is_zero() & elsest . __is_zero() &
                    ann . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return ivy::ptr< cpp::expr::__t >::__hash() (x . cond) +
                        ivy::ptr< cpp::stmt::__t >::__hash() (x . thenst) +
                        ivy::ptr< cpp::stmt::__t >::__hash() (x . elsest) +
                        ivy::ptr< annot::__t >::__hash() (x . ann);
                }
            };
            
            virtual ivy::ptr< cpp::stmt::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace cpp
{
    namespace ifst
    {
        ivy::ptr< cpp::stmt::__t > make  (const ivy::ptr< cpp::expr::__t > &cond,const ivy::ptr< cpp::stmt::__t >
            &thenst,const ivy::ptr< cpp::stmt::__t > &elsest,const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace cpp
{
    namespace whilest
    {
        struct __t : cpp::stmt::__t
        {
            ivy::ptr< cpp::expr::__t > cond;
            
            ivy::ptr< cpp::stmt::__t > body;
            
            ivy::ptr< annot::__t > ann;
            
            void encode  (pretty::__t &b,const priority::__t &prio) const;
            
            void encode_int  (pretty::__t &b,const priority::__t &prio) const;
            
            ivy::ptr< annot::__t > get_ann () const;
            
            void fix_borrow  (ivy::tocppst::__t &st,ivy::ptr< cpp::stmt::__t > &resd) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return cond == other . cond & body == other . body & ann == other . ann;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const
            {
                return cond . __is_zero() & body . __is_zero() & ann . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return ivy::ptr< cpp::expr::__t >::__hash() (x . cond) +
                        ivy::ptr< cpp::stmt::__t >::__hash() (x . body) +
                        ivy::ptr< annot::__t >::__hash() (x . ann);
                }
            };
            
            virtual ivy::ptr< cpp::stmt::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace cpp
{
    namespace whilest
    {
        ivy::ptr< cpp::stmt::__t > make  (const ivy::ptr< cpp::expr::__t > &cond,const ivy::ptr< cpp::stmt::__t >
            &body,const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace cpp
{
    namespace breakst
    {
        struct __t : cpp::stmt::__t
        {
            ivy::ptr< annot::__t > ann;
            
            void encode  (pretty::__t &b,const priority::__t &prio) const;
            
            void encode_int  (pretty::__t &b,const priority::__t &prio) const;
            
            ivy::ptr< annot::__t > get_ann () const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const {
                return ann == other . ann;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return ann . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return ivy::ptr< annot::__t >::__hash() (x . ann);
                }
            };
            
            virtual ivy::ptr< cpp::stmt::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace cpp
{
    namespace breakst
    {
        ivy::ptr< cpp::stmt::__t > make  (const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace cpp
{
    namespace stmt
    {
        void parse  (pstate::__t &st,const priority::__t &prio,ivy::ptr< cpp::stmt::__t > &res);
        
    }
    
}
namespace cpp
{
    namespace __new
    {
        ivy::ptr< cpp::expr::__t > make  (const ivy::ptr< cpp::expr::__t > &arg,const ivy::ptr< annot::__t >
            &ann);
        
    }
    
}
namespace cpp
{
    namespace arrow
    {
        ivy::ptr< cpp::expr::__t > make  (const ivy::ptr< cpp::expr::__t > &lhs,const ivy::ptr< cpp::expr::__t >
            &rhs,const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace cpp
{
    namespace arrow
    {
        ivy::ptr< cpp::expr::__t > fold_left  (const vector__cpp__expr::__t &args,const ivy::ptr< annot::__t >
            &ann);
        
    }
    
}
namespace cpp
{
    namespace arrow
    {
        vector__cpp__expr::__t unfold_left  (const ivy::ptr< cpp::expr::__t > &s);
        
    }
    
}
namespace cpp
{
    namespace equals
    {
        ivy::ptr< cpp::expr::__t > make  (const ivy::ptr< cpp::expr::__t > &lhs,const ivy::ptr< cpp::expr::__t >
            &rhs,const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace cpp
{
    namespace equals
    {
        ivy::ptr< cpp::expr::__t > fold_left  (const vector__cpp__expr::__t &args,const ivy::ptr< annot::__t >
            &ann);
        
    }
    
}
namespace cpp
{
    namespace equals
    {
        vector__cpp__expr::__t unfold_left  (const ivy::ptr< cpp::expr::__t > &s);
        
    }
    
}
namespace cpp
{
    namespace notequals
    {
        ivy::ptr< cpp::expr::__t > make  (const ivy::ptr< cpp::expr::__t > &lhs,const ivy::ptr< cpp::expr::__t >
            &rhs,const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace cpp
{
    namespace notequals
    {
        ivy::ptr< cpp::expr::__t > fold_left  (const vector__cpp__expr::__t &args,const ivy::ptr< annot::__t >
            &ann);
        
    }
    
}
namespace cpp
{
    namespace notequals
    {
        vector__cpp__expr::__t unfold_left  (const ivy::ptr< cpp::expr::__t > &s);
        
    }
    
}
namespace cpp
{
    namespace __not
    {
        ivy::ptr< cpp::expr::__t > make  (const ivy::ptr< cpp::expr::__t > &arg,const ivy::ptr< annot::__t >
            &ann);
        
    }
    
}
namespace cpp
{
    namespace ite
    {
        ivy::ptr< cpp::expr::__t > make  (const ivy::ptr< cpp::expr::__t > &arg0,const ivy::ptr< cpp::expr::__t >
            &arg1,const ivy::ptr< cpp::expr::__t > &arg2,const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace cpp
{
    namespace app
    {
        ivy::ptr< cpp::expr::__t > make0  (const ivy::ptr< cpp::expr::__t > &func,const ivy::ptr< annot::__t >
            &ann);
        
    }
    
}
namespace cpp
{
    namespace simpletype
    {
        struct __t
        {
            ivy::ptr< cpp::expr::__t > _type;
            
            ivy::ptr< cpp::expr::__t > name;
            
            __bool is_const;
            
            __bool is_ref;
            
            __bool is_rvalue;
            
            __bool is_borrow;
            
            void encode  (pretty::__t &b,const priority::__t &prio) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return _type == other . _type & name == other . name & is_const == other . is_const
                    & is_ref == other . is_ref & is_rvalue == other . is_rvalue & is_borrow == other
                    . is_borrow;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const
            {
                return _type . __is_zero() & name . __is_zero() & is_const . __is_zero() &
                    is_ref . __is_zero() & is_rvalue . __is_zero() & is_borrow . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return ivy::ptr< cpp::expr::__t >::__hash() (x . _type) +
                        ivy::ptr< cpp::expr::__t >::__hash() (x . name) +
                        __bool::__hash() (x . is_const) + __bool::__hash() (x . is_ref) +
                        __bool::__hash() (x . is_rvalue) + __bool::__hash() (x . is_borrow);
                }
            };
            
        };
        
    }
    
}
namespace cpp
{
    namespace simpletype
    {
        namespace tup
        {
            void encode  (const vector__cpp__simpletype::__t &s,pretty::__t &b,const priority::__t &prio);
            
        }
        
    }
    
}
namespace cpp
{
    namespace simpletype
    {
        namespace tup
        {
            void parse  (pstate::__t &st,const priority::__t &prio,vector__cpp__simpletype::__t &res);
            
        }
        
    }
    
}
namespace cpp
{
    namespace simpletype
    {
        void parse  (pstate::__t &st,const priority::__t &prio,cpp::simpletype::__t &res);
        
    }
    
}
namespace vector__cpp__simpletype
{
    namespace domain
    {
        struct __t : ivy::native_unsigned< size_t >
        {
            vector__cpp__simpletype::domain::__t next () const;
            
            vector__cpp__simpletype::domain::__t prev () const;
            
             __t () {}
             __t  (long long value) : ivy::native_unsigned< size_t > (value) {}
             __t  (const ivy::native_unsigned< size_t > &value) :
                ivy::native_unsigned< size_t > (value) {}
             operator ivy::native_unsigned< size_t > () const {
                return (*this);
            }
        };
        
    }
    
}
namespace vector__cpp__simpletype
{
    struct __t
    {
        ivy::vector< cpp::simpletype::__t,vector__cpp__simpletype::domain::__t > value;
        
        vector__cpp__simpletype::domain::__t end;
        
        vector__cpp__simpletype::domain::__t begin () const;
        
        void set  (const vector__cpp__simpletype::domain::__t &i,const cpp::simpletype::__t &v);
        
        void append  (const cpp::simpletype::__t &c);
        
        void extend  (const vector__cpp__simpletype::__t &x);
        
        void resize  (const vector__cpp__simpletype::domain::__t &end);
        
        cpp::simpletype::__t back () const;
        
        void pop_back ();
        
        vector__cpp__simpletype::__t segment  (const vector__cpp__simpletype::domain::__t &beg,const
            vector__cpp__simpletype::domain::__t &en) const;
        
        void reverse ();
        
         __t () {}
         __t  (long long value) {}
         operator std::size_t () const {
            return 0;
        }
        static bool __is_seq () {
            return false;
        }
        ivy::native_bool operator ==  (const __t &other) const
        {
            return value == other . value & end == other . end;
        }
        ivy::native_bool operator !=  (const __t &other) const {
            return ! ((*this) == other);
        }
        bool __is_zero () const {
            return value . __is_zero() & end . __is_zero();
        }
        struct __hash
        {
            std::size_t operator ()  (const __t &x) const
            {
                return
                    ivy::vector< cpp::simpletype::__t,vector__cpp__simpletype::domain::__t >::__hash()
                        (x . value) + vector__cpp__simpletype::domain::__t::__hash() (x . end);
            }
        };
        
    };
    
}
namespace vector__cpp__simpletype
{
    vector__cpp__simpletype::__t empty ();
    
}
namespace cpp
{
    namespace functype
    {
        struct __t
        {
            cpp::simpletype::__t base;
            
            vector__cpp__simpletype::__t args;
            
            __bool is_const;
            
            __bool has_initializer;
            
            ivy::ptr< cpp::expr::__t > initializer;
            
            void encode  (pretty::__t &b,const priority::__t &prio) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return base == other . base & args == other . args & is_const == other . is_const &
                    has_initializer == other . has_initializer & initializer == other . initializer;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const
            {
                return base . __is_zero() & args . __is_zero() & is_const . __is_zero() &
                    has_initializer . __is_zero() & initializer . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return cpp::simpletype::__t::__hash() (x . base) +
                        vector__cpp__simpletype::__t::__hash() (x . args) +
                        __bool::__hash() (x . is_const) + __bool::__hash() (x . has_initializer) +
                        ivy::ptr< cpp::expr::__t >::__hash() (x . initializer);
                }
            };
            
        };
        
    }
    
}
namespace cpp
{
    namespace functype
    {
        void parse  (pstate::__t &st,const cpp::simpletype::__t &base,const priority::__t &prio,cpp::functype::__t
            &res);
        
    }
    
}
namespace cpp
{
    namespace varst
    {
        struct __t : cpp::stmt::__t
        {
            cpp::simpletype::__t vtype;
            
            __bool has_initval;
            
            ivy::ptr< cpp::expr::__t > initval;
            
            ivy::ptr< annot::__t > ann;
            
            void encode  (pretty::__t &b,const priority::__t &prio) const;
            
            void encode_int  (pretty::__t &b,const priority::__t &prio) const;
            
            void setup_fix_borrow  (ivy::tocppst::__t &st,__bool &ok) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return vtype == other . vtype & has_initval == other . has_initval & initval ==
                    other . initval & ann == other . ann;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const
            {
                return vtype . __is_zero() & has_initval . __is_zero() & initval . __is_zero() &
                    ann . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return cpp::simpletype::__t::__hash() (x . vtype) +
                        __bool::__hash() (x . has_initval) +
                        ivy::ptr< cpp::expr::__t >::__hash() (x . initval) +
                        ivy::ptr< annot::__t >::__hash() (x . ann);
                }
            };
            
            virtual ivy::ptr< cpp::stmt::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace cpp
{
    namespace varst
    {
        ivy::ptr< cpp::stmt::__t > make  (const ivy::ptr< cpp::expr::__t > &_type,const ivy::ptr< cpp::expr::__t >
            &name,const ivy::ptr< annot::__t > &ann);
        
    }
    
}
namespace cpp
{
    namespace retst
    {
        struct __t : cpp::stmt::__t
        {
            ivy::ptr< cpp::expr::__t > val;
            
            ivy::ptr< annot::__t > ann;
            
            void encode  (pretty::__t &b,const priority::__t &prio) const;
            
            void encode_int  (pretty::__t &b,const priority::__t &prio) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return val == other . val & ann == other . ann;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return val . __is_zero() & ann . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return ivy::ptr< cpp::expr::__t >::__hash() (x . val) +
                        ivy::ptr< annot::__t >::__hash() (x . ann);
                }
            };
            
            virtual ivy::ptr< cpp::stmt::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace cpp
{
    namespace retst
    {
        ivy::ptr< cpp::stmt::__t > make  (const ivy::ptr< cpp::expr::__t > &val,const ivy::ptr< annot::__t >
            &ann);
        
    }
    
}
namespace cpp
{
    namespace stmt
    {
        void parse_lang_stmt  (pstate::__t &st,const priority::__t &prio,ivy::ptr< cpp::stmt::__t >
            &res);
        
    }
    
}
namespace cpp
{
    namespace decl
    {
        struct __t
        {
            virtual void encode  (pretty::__t &b,const priority::__t &prio) const;
            
            virtual str::__t enc () const;
            
            virtual ivy::ptr< annot::__t > get_ann () const;
            
            virtual ivy::ptr< cpp::expr::__t > get_name () const;
            
            virtual ivy::ptr< cpp::expr::__t > get_type () const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const {
                return true;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return true;
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const {
                    return 0;
                }
            };
            
            virtual ivy::ptr< __t > __upcast () const {
                return (*this);
            }
            virtual  ~__t () {}
        };
        
    }
    
}
namespace cpp
{
    namespace decl
    {
        ivy::ptr< cpp::decl::__t > dec  (const str::__t &s);
        
    }
    
}
namespace cpp
{
    namespace decl
    {
        str::__t encdec  (const str::__t &s);
        
    }
    
}
namespace cpp
{
    namespace header
    {
        struct __t : cpp::decl::__t
        {
            str::__t filename;
            
            ivy::ptr< annot::__t > ann;
            
            void encode  (pretty::__t &b,const priority::__t &prio) const;
            
            ivy::ptr< annot::__t > get_ann () const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return filename == other . filename & ann == other . ann;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return filename . __is_zero() & ann . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return str::__t::__hash() (x . filename) +
                        ivy::ptr< annot::__t >::__hash() (x . ann);
                }
            };
            
            virtual ivy::ptr< cpp::decl::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace cpp
{
    namespace header
    {
        ivy::ptr< cpp::decl::__t > make  (const str::__t &filename);
        
    }
    
}
namespace cpp
{
    namespace typedecl
    {
        struct __t : cpp::decl::__t
        {
            cpp::simpletype::__t ttype;
            
            ivy::ptr< annot::__t > ann;
            
            void encode  (pretty::__t &b,const priority::__t &prio) const;
            
            ivy::ptr< annot::__t > get_ann () const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return ttype == other . ttype & ann == other . ann;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return ttype . __is_zero() & ann . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return cpp::simpletype::__t::__hash() (x . ttype) +
                        ivy::ptr< annot::__t >::__hash() (x . ann);
                }
            };
            
            virtual ivy::ptr< cpp::decl::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace cpp
{
    namespace curly_tup
    {
        void encode  (const vector__cpp__expr::__t &s,pretty::__t &b,const priority::__t &prio);
        
    }
    
}
namespace cpp
{
    namespace curly_tup
    {
        void parse  (pstate::__t &st,const priority::__t &prio,vector__cpp__expr::__t &res);
        
    }
    
}
namespace cpp
{
    namespace enumdecl
    {
        struct __t : cpp::decl::__t
        {
            ivy::ptr< cpp::expr::__t > name;
            
            vector__cpp__expr::__t elems;
            
            ivy::ptr< annot::__t > ann;
            
            void encode  (pretty::__t &b,const priority::__t &prio) const;
            
            ivy::ptr< annot::__t > get_ann () const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return name == other . name & elems == other . elems & ann == other . ann;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const
            {
                return name . __is_zero() & elems . __is_zero() & ann . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return ivy::ptr< cpp::expr::__t >::__hash() (x . name) +
                        vector__cpp__expr::__t::__hash() (x . elems) +
                        ivy::ptr< annot::__t >::__hash() (x . ann);
                }
            };
            
            virtual ivy::ptr< cpp::decl::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace cpp
{
    namespace vardecl
    {
        struct __t : cpp::decl::__t
        {
            cpp::simpletype::__t vtype;
            
            __bool has_initval;
            
            ivy::ptr< cpp::expr::__t > initval;
            
            ivy::ptr< annot::__t > ann;
            
            void encode  (pretty::__t &b,const priority::__t &prio) const;
            
            ivy::ptr< annot::__t > get_ann () const;
            
            ivy::ptr< cpp::expr::__t > get_name () const;
            
            ivy::ptr< cpp::expr::__t > get_type () const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return vtype == other . vtype & has_initval == other . has_initval & initval ==
                    other . initval & ann == other . ann;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const
            {
                return vtype . __is_zero() & has_initval . __is_zero() & initval . __is_zero() &
                    ann . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return cpp::simpletype::__t::__hash() (x . vtype) +
                        __bool::__hash() (x . has_initval) +
                        ivy::ptr< cpp::expr::__t >::__hash() (x . initval) +
                        ivy::ptr< annot::__t >::__hash() (x . ann);
                }
            };
            
            virtual ivy::ptr< cpp::decl::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace cpp
{
    namespace funcdecl
    {
        struct __t : cpp::decl::__t
        {
            cpp::functype::__t ftype;
            
            __bool has_body;
            
            ivy::ptr< cpp::stmt::__t > body;
            
            __bool is_static;
            
            __bool is_virtual;
            
            __bool is_default;
            
            ivy::ptr< annot::__t > ann;
            
            void encode  (pretty::__t &b,const priority::__t &prio) const;
            
            ivy::ptr< annot::__t > get_ann () const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return ftype == other . ftype & has_body == other . has_body & body == other . body
                    & is_static == other . is_static & is_virtual == other . is_virtual & is_default
                    == other . is_default & ann == other . ann;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const
            {
                return ftype . __is_zero() & has_body . __is_zero() & body . __is_zero() &
                    is_static . __is_zero() & is_virtual . __is_zero() & is_default . __is_zero() &
                    ann . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return cpp::functype::__t::__hash() (x . ftype) +
                        __bool::__hash() (x . has_body) +
                        ivy::ptr< cpp::stmt::__t >::__hash() (x . body) +
                        __bool::__hash() (x . is_static) + __bool::__hash() (x . is_virtual) +
                        __bool::__hash() (x . is_default) +
                        ivy::ptr< annot::__t >::__hash() (x . ann);
                }
            };
            
            virtual ivy::ptr< cpp::decl::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace vector__cpp__decl
{
    namespace domain
    {
        struct __t : ivy::native_unsigned< size_t >
        {
            vector__cpp__decl::domain::__t next () const;
            
            vector__cpp__decl::domain::__t prev () const;
            
             __t () {}
             __t  (long long value) : ivy::native_unsigned< size_t > (value) {}
             __t  (const ivy::native_unsigned< size_t > &value) :
                ivy::native_unsigned< size_t > (value) {}
             operator ivy::native_unsigned< size_t > () const {
                return (*this);
            }
        };
        
    }
    
}
namespace vector__cpp__decl
{
    struct __t
    {
        ivy::vector< ivy::ptr< cpp::decl::__t >,vector__cpp__decl::domain::__t > value;
        
        vector__cpp__decl::domain::__t end;
        
        vector__cpp__decl::domain::__t begin () const;
        
        void set  (const vector__cpp__decl::domain::__t &i,const ivy::ptr< cpp::decl::__t > &v);
        
        void append  (const ivy::ptr< cpp::decl::__t > &c);
        
        void extend  (const vector__cpp__decl::__t &x);
        
        void resize  (const vector__cpp__decl::domain::__t &end);
        
        ivy::ptr< cpp::decl::__t > back () const;
        
        void pop_back ();
        
        vector__cpp__decl::__t segment  (const vector__cpp__decl::domain::__t &beg,const
            vector__cpp__decl::domain::__t &en) const;
        
        void reverse ();
        
         __t () {}
         __t  (long long value) {}
         operator std::size_t () const {
            return 0;
        }
        static bool __is_seq () {
            return false;
        }
        ivy::native_bool operator ==  (const __t &other) const
        {
            return value == other . value & end == other . end;
        }
        ivy::native_bool operator !=  (const __t &other) const {
            return ! ((*this) == other);
        }
        bool __is_zero () const {
            return value . __is_zero() & end . __is_zero();
        }
        struct __hash
        {
            std::size_t operator ()  (const __t &x) const
            {
                return
                    ivy::vector< ivy::ptr< cpp::decl::__t >,vector__cpp__decl::domain::__t >::__hash()
                        (x . value) + vector__cpp__decl::domain::__t::__hash() (x . end);
            }
        };
        
    };
    
}
namespace vector__cpp__decl
{
    vector__cpp__decl::__t empty ();
    
}
namespace cpp
{
    namespace structdecl
    {
        struct __t : cpp::decl::__t
        {
            ivy::ptr< cpp::expr::__t > name;
            
            __bool has_super;
            
            ivy::ptr< cpp::expr::__t > super;
            
            __bool has_members;
            
            vector__cpp__decl::__t members;
            
            ivy::ptr< annot::__t > ann;
            
            void encode  (pretty::__t &b,const priority::__t &prio) const;
            
            ivy::ptr< annot::__t > get_ann () const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return name == other . name & has_super == other . has_super & super == other .
                    super & has_members == other . has_members & members == other . members & ann ==
                    other . ann;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const
            {
                return name . __is_zero() & has_super . __is_zero() & super . __is_zero() &
                    has_members . __is_zero() & members . __is_zero() & ann . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return ivy::ptr< cpp::expr::__t >::__hash() (x . name) +
                        __bool::__hash() (x . has_super) +
                        ivy::ptr< cpp::expr::__t >::__hash() (x . super) +
                        __bool::__hash() (x . has_members) +
                        vector__cpp__decl::__t::__hash() (x . members) +
                        ivy::ptr< annot::__t >::__hash() (x . ann);
                }
            };
            
            virtual ivy::ptr< cpp::decl::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace cpp
{
    namespace namespacedecl
    {
        struct __t : cpp::decl::__t
        {
            ivy::ptr< cpp::expr::__t > name;
            
            vector__cpp__decl::__t members;
            
            ivy::ptr< annot::__t > ann;
            
            void encode  (pretty::__t &b,const priority::__t &prio) const;
            
            ivy::ptr< annot::__t > get_ann () const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return name == other . name & members == other . members & ann == other . ann;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const
            {
                return name . __is_zero() & members . __is_zero() & ann . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return ivy::ptr< cpp::expr::__t >::__hash() (x . name) +
                        vector__cpp__decl::__t::__hash() (x . members) +
                        ivy::ptr< annot::__t >::__hash() (x . ann);
                }
            };
            
            virtual ivy::ptr< cpp::decl::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace cpp
{
    namespace groupdc
    {
        struct __t : cpp::decl::__t
        {
            vector__cpp__decl::__t decls;
            
            ivy::ptr< annot::__t > ann;
            
            void encode  (pretty::__t &b,const priority::__t &prio) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return decls == other . decls & ann == other . ann;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return decls . __is_zero() & ann . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return vector__cpp__decl::__t::__hash() (x . decls) +
                        ivy::ptr< annot::__t >::__hash() (x . ann);
                }
            };
            
            virtual ivy::ptr< cpp::decl::__t > __upcast () const {
                return (*this);
            }
        };
        
    }
    
}
namespace cpp
{
    namespace decl
    {
        void parse  (pstate::__t &st,const priority::__t &prio,ivy::ptr< cpp::decl::__t > &res);
        
    }
    
}
namespace cpp
{
    namespace decl
    {
        vector__cpp__decl::__t foo;
        
    }
    
}
// workaround
namespace cpp
{
    namespace decl
    {
        void parse_list  (pstate::__t &st,const priority::__t &prio,vector__cpp__decl::__t &res);
        
    }
    
}
namespace cpp
{
    namespace version
    {
        struct __t
        {
            vector__pos::__t nums;
            
            void encode  (pretty::__t &b) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const {
                return nums == other . nums;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return nums . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return vector__pos::__t::__hash() (x . nums);
                }
            };
            
        };
        
    }
    
}
namespace cpp
{
    namespace version
    {
        void parse  (pstate::__t &st,const priority::__t &prio,cpp::version::__t &res);
        
    }
    
}
namespace cpp
{
    namespace prog
    {
        struct __t
        {
            cpp::version::__t vers;
            
            vector__cpp__decl::__t decls;
            
            str::__t enc () const;
            
            void encode  (pretty::__t &b,const priority::__t &prio) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return vers == other . vers & decls == other . decls;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return vers . __is_zero() & decls . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return cpp::version::__t::__hash() (x . vers) +
                        vector__cpp__decl::__t::__hash() (x . decls);
                }
            };
            
        };
        
    }
    
}
namespace cpp
{
    namespace prog
    {
        cpp::prog::__t dec  (const str::__t &s);
        
    }
    
}
namespace cpp
{
    namespace prog
    {
        str::__t encdec  (const str::__t &s);
        
    }
    
}
namespace cpp
{
    namespace prog
    {
        cpp::prog::__t make  (const vector__cpp__decl::__t &decls);
        
    }
    
}
namespace cpp
{
    namespace prog
    {
        void parse_to  (pstate::__t &st,const priority::__t &prio,cpp::prog::__t &res);
        
    }
    
}
namespace cpp
{
    namespace prog
    {
        void parse  (pstate::__t &st,const priority::__t &prio,cpp::prog::__t &res);
        
    }
    
}
namespace cpp
{
    ivy::ptr< cpp::expr::__t > namedtype  (const ivy::ptr< cpp::ident::__t > &name,const ivy::ptr< annot::__t >
        &ann);
    
}
namespace cpp
{
    ivy::ptr< cpp::expr::__t > inttype  (const ivy::ptr< annot::__t > &ann);
    
}
namespace cpp
{
    ivy::ptr< cpp::expr::__t > voidtype  (const ivy::ptr< annot::__t > &ann);
    
}
// The set of names reserved by C++. Ivy names that clash with these
// have to be changed.
namespace ivy
{
    ivy::vector< __bool,str::__t > cpp_reserved_word;
    
}
namespace ivy
{
    namespace access_path
    {
        struct __t
        {
            vector__ivy__ident::__t elems;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const {
                return elems == other . elems;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return elems . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return vector__ivy__ident::__t::__hash() (x . elems);
                }
            };
            
        };
        
    }
    
}
// Two paths may alias if one is a prefix of the other
namespace ivy
{
    __bool path_may_alias  (const ivy::access_path::__t &v,const ivy::access_path::__t &w);
    
}
namespace ivy
{
    struct lvalue_count
    {
        ivy::ptr< cpp::expr::__t > lvalue;
        
        ivy::access_path::__t path;
        
        pos::__t cnt;
        
         lvalue_count () {}
         lvalue_count  (long long value) {}
         operator std::size_t () const {
            return 0;
        }
        static bool __is_seq () {
            return false;
        }
        ivy::native_bool operator ==  (const lvalue_count &other) const
        {
            return lvalue == other . lvalue & path == other . path & cnt == other . cnt;
        }
        ivy::native_bool operator !=  (const lvalue_count &other) const
        {
            return ! ((*this) == other);
        }
        bool __is_zero () const
        {
            return lvalue . __is_zero() & path . __is_zero() & cnt . __is_zero();
        }
        struct __hash
        {
            std::size_t operator ()  (const lvalue_count &x) const
            {
                return ivy::ptr< cpp::expr::__t >::__hash() (x . lvalue) +
                    ivy::access_path::__t::__hash() (x . path) + pos::__t::__hash() (x . cnt);
            }
        };
        
    };
    
}
namespace ivy
{
    namespace path_tree
    {
        namespace elem
        {
            struct __t
            {
                __bool present;
                
                vector__ivy__ident::__t children;
                
                vector__ivy__ident::__t leaves;
                
                 __t () {}
                 __t  (long long value) {}
                 operator std::size_t () const {
                    return 0;
                }
                static bool __is_seq () {
                    return false;
                }
                ivy::native_bool operator ==  (const __t &other) const
                {
                    return present == other . present & children == other . children & leaves ==
                        other . leaves;
                }
                ivy::native_bool operator !=  (const __t &other) const {
                    return ! ((*this) == other);
                }
                bool __is_zero () const
                {
                    return present . __is_zero() & children . __is_zero() & leaves . __is_zero();
                }
                struct __hash
                {
                    std::size_t operator ()  (const __t &x) const
                    {
                        return __bool::__hash() (x . present) +
                            vector__ivy__ident::__t::__hash() (x . children) +
                            vector__ivy__ident::__t::__hash() (x . leaves);
                    }
                };
                
            };
            
        }
        
    }
    
}
namespace ivy
{
    namespace path_tree
    {
        namespace undo_rec
        {
            struct __t
            {
                vector__ivy__ident::__t children;
                
                ivy::ptr< ivy::ident::__t > leaf;
                
                 __t () {}
                 __t  (long long value) {}
                 operator std::size_t () const {
                    return 0;
                }
                static bool __is_seq () {
                    return false;
                }
                ivy::native_bool operator ==  (const __t &other) const
                {
                    return children == other . children & leaf == other . leaf;
                }
                ivy::native_bool operator !=  (const __t &other) const {
                    return ! ((*this) == other);
                }
                bool __is_zero () const {
                    return children . __is_zero() & leaf . __is_zero();
                }
                struct __hash
                {
                    std::size_t operator ()  (const __t &x) const
                    {
                        return vector__ivy__ident::__t::__hash() (x . children) +
                            ivy::ptr< ivy::ident::__t >::__hash() (x . leaf);
                    }
                };
                
            };
            
        }
        
    }
    
}
namespace vector__ivy__path_tree__undo_rec
{
    namespace domain
    {
        struct __t : ivy::native_unsigned< size_t >
        {
            vector__ivy__path_tree__undo_rec::domain::__t next () const;
            
            vector__ivy__path_tree__undo_rec::domain::__t prev () const;
            
             __t () {}
             __t  (long long value) : ivy::native_unsigned< size_t > (value) {}
             __t  (const ivy::native_unsigned< size_t > &value) :
                ivy::native_unsigned< size_t > (value) {}
             operator ivy::native_unsigned< size_t > () const {
                return (*this);
            }
        };
        
    }
    
}
namespace vector__ivy__path_tree__undo_rec
{
    struct __t
    {
        ivy::vector< ivy::path_tree::undo_rec::__t,vector__ivy__path_tree__undo_rec::domain::__t >
            value;
        
        vector__ivy__path_tree__undo_rec::domain::__t end;
        
        vector__ivy__path_tree__undo_rec::domain::__t begin () const;
        
        void set  (const vector__ivy__path_tree__undo_rec::domain::__t &i,const ivy::path_tree::undo_rec::__t
            &v);
        
        void append  (const ivy::path_tree::undo_rec::__t &c);
        
        void extend  (const vector__ivy__path_tree__undo_rec::__t &x);
        
        void resize  (const vector__ivy__path_tree__undo_rec::domain::__t &end);
        
        ivy::path_tree::undo_rec::__t back () const;
        
        void pop_back ();
        
        vector__ivy__path_tree__undo_rec::__t segment  (const vector__ivy__path_tree__undo_rec::domain::__t
            &beg,const vector__ivy__path_tree__undo_rec::domain::__t &en) const;
        
        void reverse ();
        
         __t () {}
         __t  (long long value) {}
         operator std::size_t () const {
            return 0;
        }
        static bool __is_seq () {
            return false;
        }
        ivy::native_bool operator ==  (const __t &other) const
        {
            return value == other . value & end == other . end;
        }
        ivy::native_bool operator !=  (const __t &other) const {
            return ! ((*this) == other);
        }
        bool __is_zero () const {
            return value . __is_zero() & end . __is_zero();
        }
        struct __hash
        {
            std::size_t operator ()  (const __t &x) const
            {
                return
                    ivy::vector< ivy::path_tree::undo_rec::__t,vector__ivy__path_tree__undo_rec::domain::__t >::__hash()
                        (x . value) +
                    vector__ivy__path_tree__undo_rec::domain::__t::__hash() (x . end);
            }
        };
        
    };
    
}
namespace vector__ivy__path_tree__undo_rec
{
    vector__ivy__path_tree__undo_rec::__t empty ();
    
}
namespace ivy
{
    namespace path_tree
    {
        vector__ivy__path_tree__undo_rec::__t v;
        
    }
    
}
namespace ivy
{
    namespace path_tree
    {
        struct __t
        {
            ivy::vector< ivy::path_tree::elem::__t,ivy::ptr< ivy::ident::__t > > value;
            
            vector__ivy__path_tree__undo_rec::__t undos;
            
            
            // Add an item to the list for a given path
            
            void add  (const ivy::access_path::__t &path,const ivy::ptr< ivy::ident::__t > &item);
            
            
            // Undo the last addition of an item
            
            void undo ();
            
            
            // Collect a list of all items for paths that may alias with the given path.
            
            vector__ivy__ident::__t collect  (const ivy::access_path::__t &path) const;
            
            void collect_rec  (const ivy::ptr< ivy::ident::__t > &id,vector__ivy__ident::__t &res)
                const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return value == other . value & undos == other . undos;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return value . __is_zero() & undos . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return
                        ivy::vector< ivy::path_tree::elem::__t,ivy::ptr< ivy::ident::__t > >::__hash()
                            (x . value) +
                        vector__ivy__path_tree__undo_rec::__t::__hash() (x . undos);
                }
            };
            
        };
        
    }
    
}
namespace vector__ivy__access_path
{
    namespace domain
    {
        struct __t : ivy::native_unsigned< size_t >
        {
            vector__ivy__access_path::domain::__t next () const;
            
            vector__ivy__access_path::domain::__t prev () const;
            
             __t () {}
             __t  (long long value) : ivy::native_unsigned< size_t > (value) {}
             __t  (const ivy::native_unsigned< size_t > &value) :
                ivy::native_unsigned< size_t > (value) {}
             operator ivy::native_unsigned< size_t > () const {
                return (*this);
            }
        };
        
    }
    
}
namespace vector__ivy__access_path
{
    struct __t
    {
        ivy::vector< ivy::access_path::__t,vector__ivy__access_path::domain::__t > value;
        
        vector__ivy__access_path::domain::__t end;
        
        vector__ivy__access_path::domain::__t begin () const;
        
        void set  (const vector__ivy__access_path::domain::__t &i,const ivy::access_path::__t &v);
        
        void append  (const ivy::access_path::__t &c);
        
        void extend  (const vector__ivy__access_path::__t &x);
        
        void resize  (const vector__ivy__access_path::domain::__t &end);
        
        ivy::access_path::__t back () const;
        
        void pop_back ();
        
        vector__ivy__access_path::__t segment  (const vector__ivy__access_path::domain::__t &beg,const
            vector__ivy__access_path::domain::__t &en) const;
        
        void reverse ();
        
         __t () {}
         __t  (long long value) {}
         operator std::size_t () const {
            return 0;
        }
        static bool __is_seq () {
            return false;
        }
        ivy::native_bool operator ==  (const __t &other) const
        {
            return value == other . value & end == other . end;
        }
        ivy::native_bool operator !=  (const __t &other) const {
            return ! ((*this) == other);
        }
        bool __is_zero () const {
            return value . __is_zero() & end . __is_zero();
        }
        struct __hash
        {
            std::size_t operator ()  (const __t &x) const
            {
                return
                    ivy::vector< ivy::access_path::__t,vector__ivy__access_path::domain::__t >::__hash()
                        (x . value) + vector__ivy__access_path::domain::__t::__hash() (x . end);
            }
        };
        
    };
    
}
namespace vector__ivy__access_path
{
    vector__ivy__access_path::__t empty ();
    
}
namespace ivy
{
    namespace borrowing
    {
        struct __t
        {
            ivy::ptr< ivy::expr::__t > lvalue;
            
            vector__ivy__access_path::domain::__t num_paths;
            
            __bool returned;
            
            __bool saw_ref;
            
            __bool saw_mod;
            
            __bool cancel_const;
            
            __bool cancel_non_const;
            
            pos::__t cond_nesting;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return lvalue == other . lvalue & num_paths == other . num_paths & returned == other
                    . returned & saw_ref == other . saw_ref & saw_mod == other . saw_mod &
                    cancel_const == other . cancel_const & cancel_non_const == other .
                    cancel_non_const & cond_nesting == other . cond_nesting;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const
            {
                return lvalue . __is_zero() & num_paths . __is_zero() & returned . __is_zero() &
                    saw_ref . __is_zero() & saw_mod . __is_zero() & cancel_const . __is_zero() &
                    cancel_non_const . __is_zero() & cond_nesting . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return ivy::ptr< ivy::expr::__t >::__hash() (x . lvalue) +
                        vector__ivy__access_path::domain::__t::__hash() (x . num_paths) +
                        __bool::__hash() (x . returned) + __bool::__hash() (x . saw_ref) +
                        __bool::__hash() (x . saw_mod) + __bool::__hash() (x . cancel_const) +
                        __bool::__hash() (x . cancel_non_const) +
                        pos::__t::__hash() (x . cond_nesting);
                }
            };
            
        };
        
    }
    
}
namespace ivy
{
    namespace ident_to_declvec
    {
        struct rec
        {
            __bool full;
            
            vector__ivy__decl::__t val;
            
             rec () {}
             rec  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const rec &other) const
            {
                return full == other . full & val == other . val;
            }
            ivy::native_bool operator !=  (const rec &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return full . __is_zero() & val . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const rec &x) const
                {
                    return __bool::__hash() (x . full) + vector__ivy__decl::__t::__hash() (x . val);
                }
            };
            
        };
        
    }
    
}
namespace ivy
{
    namespace ident_to_declvec
    {
        struct __t
        {
            ivy::vector< ivy::ident_to_declvec::rec,ivy::ptr< ivy::ident::__t > > map;
            
            void set  (const ivy::ptr< ivy::ident::__t > &x,const vector__ivy__decl::__t &y);
            
            void get  (const ivy::ptr< ivy::ident::__t > &x,vector__ivy__decl::__t &y) const;
            
            __bool mem  (const ivy::ptr< ivy::ident::__t > &x) const;
            
            void remove  (const ivy::ptr< ivy::ident::__t > &x);
            
            vector__ivy__decl::__t value  (const ivy::ptr< ivy::ident::__t > &x) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const {
                return map == other . map;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return map . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return
                        ivy::vector< ivy::ident_to_declvec::rec,ivy::ptr< ivy::ident::__t > >::__hash()
                            (x . map);
                }
            };
            
        };
        
    }
    
}
namespace ivy
{
    namespace ident_to_declvec
    {
        ivy::ident_to_declvec::__t empty ();
        
    }
    
}
namespace ivy
{
    namespace ident_to_cppclass
    {
        struct rec
        {
            __bool full;
            
            ivy::ptr< ivy::expr::__t > val;
            
             rec () {}
             rec  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const rec &other) const
            {
                return full == other . full & val == other . val;
            }
            ivy::native_bool operator !=  (const rec &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return full . __is_zero() & val . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const rec &x) const
                {
                    return __bool::__hash() (x . full) +
                        ivy::ptr< ivy::expr::__t >::__hash() (x . val);
                }
            };
            
        };
        
    }
    
}
namespace ivy
{
    namespace ident_to_cppclass
    {
        struct __t
        {
            ivy::vector< ivy::ident_to_cppclass::rec,ivy::ptr< ivy::ident::__t > > map;
            
            void set  (const ivy::ptr< ivy::ident::__t > &x,const ivy::ptr< ivy::expr::__t > &y);
            
            void get  (const ivy::ptr< ivy::ident::__t > &x,ivy::ptr< ivy::expr::__t > &y) const;
            
            __bool mem  (const ivy::ptr< ivy::ident::__t > &x) const;
            
            void remove  (const ivy::ptr< ivy::ident::__t > &x);
            
            ivy::ptr< ivy::expr::__t > value  (const ivy::ptr< ivy::ident::__t > &x) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const {
                return map == other . map;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return map . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return
                        ivy::vector< ivy::ident_to_cppclass::rec,ivy::ptr< ivy::ident::__t > >::__hash()
                            (x . map);
                }
            };
            
        };
        
    }
    
}
namespace ivy
{
    namespace ident_to_cppclass
    {
        ivy::ident_to_cppclass::__t empty ();
        
    }
    
}
namespace ivy
{
    namespace ident_to_prototype
    {
        struct rec
        {
            __bool full;
            
            ivy::prototype::__t val;
            
             rec () {}
             rec  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const rec &other) const
            {
                return full == other . full & val == other . val;
            }
            ivy::native_bool operator !=  (const rec &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return full . __is_zero() & val . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const rec &x) const
                {
                    return __bool::__hash() (x . full) + ivy::prototype::__t::__hash() (x . val);
                }
            };
            
        };
        
    }
    
}
namespace ivy
{
    namespace ident_to_prototype
    {
        struct __t
        {
            ivy::vector< ivy::ident_to_prototype::rec,ivy::ptr< ivy::ident::__t > > map;
            
            void set  (const ivy::ptr< ivy::ident::__t > &x,const ivy::prototype::__t &y);
            
            void get  (const ivy::ptr< ivy::ident::__t > &x,ivy::prototype::__t &y) const;
            
            __bool mem  (const ivy::ptr< ivy::ident::__t > &x) const;
            
            void remove  (const ivy::ptr< ivy::ident::__t > &x);
            
            ivy::prototype::__t value  (const ivy::ptr< ivy::ident::__t > &x) const;
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const {
                return map == other . map;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const {
                return map . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return
                        ivy::vector< ivy::ident_to_prototype::rec,ivy::ptr< ivy::ident::__t > >::__hash()
                            (x . map);
                }
            };
            
        };
        
    }
    
}
namespace ivy
{
    namespace ident_to_prototype
    {
        ivy::ident_to_prototype::__t empty ();
        
    }
    
}
namespace ivy
{
    namespace ident_to_borrowing
    {
        struct undo
        {
            ivy::ptr< ivy::ident::__t > id;
            
            __bool present;
            
            ivy::borrowing::__t value;
            
             undo () {}
             undo  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const undo &other) const
            {
                return id == other . id & present == other . present & value == other . value;
            }
            ivy::native_bool operator !=  (const undo &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const
            {
                return id . __is_zero() & present . __is_zero() & value . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const undo &x) const
                {
                    return ivy::ptr< ivy::ident::__t >::__hash() (x . id) +
                        __bool::__hash() (x . present) + ivy::borrowing::__t::__hash() (x . value);
                }
            };
            
        };
        
    }
    
}
namespace ivy
{
    namespace ident_to_borrowing
    {
        namespace map_t
        {
            struct rec
            {
                __bool full;
                
                ivy::borrowing::__t val;
                
                 rec () {}
                 rec  (long long value) {}
                 operator std::size_t () const {
                    return 0;
                }
                static bool __is_seq () {
                    return false;
                }
                ivy::native_bool operator ==  (const rec &other) const
                {
                    return full == other . full & val == other . val;
                }
                ivy::native_bool operator !=  (const rec &other) const {
                    return ! ((*this) == other);
                }
                bool __is_zero () const {
                    return full . __is_zero() & val . __is_zero();
                }
                struct __hash
                {
                    std::size_t operator ()  (const rec &x) const
                    {
                        return __bool::__hash() (x . full) + ivy::borrowing::__t::__hash() (x . val);
                    }
                };
                
            };
            
        }
        
    }
    
}
namespace ivy
{
    namespace ident_to_borrowing
    {
        namespace map_t
        {
            struct __t
            {
                ivy::vector< ivy::ident_to_borrowing::map_t::rec,ivy::ptr< ivy::ident::__t > > map;
                
                void set  (const ivy::ptr< ivy::ident::__t > &x,const ivy::borrowing::__t &y);
                
                void get  (const ivy::ptr< ivy::ident::__t > &x,ivy::borrowing::__t &y) const;
                
                __bool mem  (const ivy::ptr< ivy::ident::__t > &x) const;
                
                void remove  (const ivy::ptr< ivy::ident::__t > &x);
                
                ivy::borrowing::__t value  (const ivy::ptr< ivy::ident::__t > &x) const;
                
                 __t () {}
                 __t  (long long value) {}
                 operator std::size_t () const {
                    return 0;
                }
                static bool __is_seq () {
                    return false;
                }
                ivy::native_bool operator ==  (const __t &other) const {
                    return map == other . map;
                }
                ivy::native_bool operator !=  (const __t &other) const {
                    return ! ((*this) == other);
                }
                bool __is_zero () const {
                    return map . __is_zero();
                }
                struct __hash
                {
                    std::size_t operator ()  (const __t &x) const
                    {
                        return
                            ivy::vector< ivy::ident_to_borrowing::map_t::rec,ivy::ptr< ivy::ident::__t > >::__hash()
                                (x . map);
                    }
                };
                
            };
            
        }
        
    }
    
}
namespace ivy
{
    namespace ident_to_borrowing
    {
        namespace map_t
        {
            ivy::ident_to_borrowing::map_t::__t empty ();
            
        }
        
    }
    
}
namespace ivy
{
    namespace ident_to_borrowing
    {
        namespace vec_t
        {
            struct __t
            {
                ivy::vector< ivy::ident_to_borrowing::undo,pos::__t > value;
                
                pos::__t end;
                
                pos::__t begin () const;
                
                void set  (const pos::__t &i,const ivy::ident_to_borrowing::undo &v);
                
                void append  (const ivy::ident_to_borrowing::undo &c);
                
                void extend  (const ivy::ident_to_borrowing::vec_t::__t &x);
                
                void resize  (const pos::__t &end);
                
                ivy::ident_to_borrowing::undo back () const;
                
                void pop_back ();
                
                ivy::ident_to_borrowing::vec_t::__t segment  (const pos::__t &beg,const pos::__t &en)
                    const;
                
                void reverse ();
                
                 __t () {}
                 __t  (long long value) {}
                 operator std::size_t () const {
                    return 0;
                }
                static bool __is_seq () {
                    return false;
                }
                ivy::native_bool operator ==  (const __t &other) const
                {
                    return value == other . value & end == other . end;
                }
                ivy::native_bool operator !=  (const __t &other) const {
                    return ! ((*this) == other);
                }
                bool __is_zero () const {
                    return value . __is_zero() & end . __is_zero();
                }
                struct __hash
                {
                    std::size_t operator ()  (const __t &x) const
                    {
                        return
                            ivy::vector< ivy::ident_to_borrowing::undo,pos::__t >::__hash() (x .
                                value) + pos::__t::__hash() (x . end);
                    }
                };
                
            };
            
        }
        
    }
    
}
namespace ivy
{
    namespace ident_to_borrowing
    {
        namespace vec_t
        {
            ivy::ident_to_borrowing::vec_t::__t empty ();
            
        }
        
    }
    
}
namespace ivy
{
    namespace ident_to_borrowing
    {
        struct __t
        {
            ivy::ident_to_borrowing::map_t::__t map;
            
            ivy::ident_to_borrowing::vec_t::__t del;
            
            vector__pos::__t stack;
            
            void set  (const ivy::ptr< ivy::ident::__t > &id,const ivy::borrowing::__t &v);
            
            __bool mem  (const ivy::ptr< ivy::ident::__t > &id) const;
            
            ivy::borrowing::__t value  (const ivy::ptr< ivy::ident::__t > &id) const;
            
            void push ();
            
            void pop ();
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return map == other . map & del == other . del & stack == other . stack;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const
            {
                return map . __is_zero() & del . __is_zero() & stack . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return ivy::ident_to_borrowing::map_t::__t::__hash() (x . map) +
                        ivy::ident_to_borrowing::vec_t::__t::__hash() (x . del) +
                        vector__pos::__t::__hash() (x . stack);
                }
            };
            
        };
        
    }
    
}
namespace ivy
{
    namespace cppident_to_cppexpr
    {
        struct undo
        {
            ivy::ptr< cpp::ident::__t > id;
            
            __bool present;
            
            ivy::ptr< cpp::expr::__t > value;
            
             undo () {}
             undo  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const undo &other) const
            {
                return id == other . id & present == other . present & value == other . value;
            }
            ivy::native_bool operator !=  (const undo &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const
            {
                return id . __is_zero() & present . __is_zero() & value . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const undo &x) const
                {
                    return ivy::ptr< cpp::ident::__t >::__hash() (x . id) +
                        __bool::__hash() (x . present) +
                        ivy::ptr< cpp::expr::__t >::__hash() (x . value);
                }
            };
            
        };
        
    }
    
}
namespace ivy
{
    namespace cppident_to_cppexpr
    {
        namespace map_t
        {
            struct rec
            {
                __bool full;
                
                ivy::ptr< cpp::expr::__t > val;
                
                 rec () {}
                 rec  (long long value) {}
                 operator std::size_t () const {
                    return 0;
                }
                static bool __is_seq () {
                    return false;
                }
                ivy::native_bool operator ==  (const rec &other) const
                {
                    return full == other . full & val == other . val;
                }
                ivy::native_bool operator !=  (const rec &other) const {
                    return ! ((*this) == other);
                }
                bool __is_zero () const {
                    return full . __is_zero() & val . __is_zero();
                }
                struct __hash
                {
                    std::size_t operator ()  (const rec &x) const
                    {
                        return __bool::__hash() (x . full) +
                            ivy::ptr< cpp::expr::__t >::__hash() (x . val);
                    }
                };
                
            };
            
        }
        
    }
    
}
namespace ivy
{
    namespace cppident_to_cppexpr
    {
        namespace map_t
        {
            struct __t
            {
                ivy::vector< ivy::cppident_to_cppexpr::map_t::rec,ivy::ptr< cpp::ident::__t > > map;
                
                void set  (const ivy::ptr< cpp::ident::__t > &x,const ivy::ptr< cpp::expr::__t > &y);
                
                void get  (const ivy::ptr< cpp::ident::__t > &x,ivy::ptr< cpp::expr::__t > &y) const;
                
                __bool mem  (const ivy::ptr< cpp::ident::__t > &x) const;
                
                void remove  (const ivy::ptr< cpp::ident::__t > &x);
                
                ivy::ptr< cpp::expr::__t > value  (const ivy::ptr< cpp::ident::__t > &x) const;
                
                 __t () {}
                 __t  (long long value) {}
                 operator std::size_t () const {
                    return 0;
                }
                static bool __is_seq () {
                    return false;
                }
                ivy::native_bool operator ==  (const __t &other) const {
                    return map == other . map;
                }
                ivy::native_bool operator !=  (const __t &other) const {
                    return ! ((*this) == other);
                }
                bool __is_zero () const {
                    return map . __is_zero();
                }
                struct __hash
                {
                    std::size_t operator ()  (const __t &x) const
                    {
                        return
                            ivy::vector< ivy::cppident_to_cppexpr::map_t::rec,ivy::ptr< cpp::ident::__t > >::__hash()
                                (x . map);
                    }
                };
                
            };
            
        }
        
    }
    
}
namespace ivy
{
    namespace cppident_to_cppexpr
    {
        namespace map_t
        {
            ivy::cppident_to_cppexpr::map_t::__t empty ();
            
        }
        
    }
    
}
namespace ivy
{
    namespace cppident_to_cppexpr
    {
        namespace vec_t
        {
            struct __t
            {
                ivy::vector< ivy::cppident_to_cppexpr::undo,pos::__t > value;
                
                pos::__t end;
                
                pos::__t begin () const;
                
                void set  (const pos::__t &i,const ivy::cppident_to_cppexpr::undo &v);
                
                void append  (const ivy::cppident_to_cppexpr::undo &c);
                
                void extend  (const ivy::cppident_to_cppexpr::vec_t::__t &x);
                
                void resize  (const pos::__t &end);
                
                ivy::cppident_to_cppexpr::undo back () const;
                
                void pop_back ();
                
                ivy::cppident_to_cppexpr::vec_t::__t segment  (const pos::__t &beg,const pos::__t &en)
                    const;
                
                void reverse ();
                
                 __t () {}
                 __t  (long long value) {}
                 operator std::size_t () const {
                    return 0;
                }
                static bool __is_seq () {
                    return false;
                }
                ivy::native_bool operator ==  (const __t &other) const
                {
                    return value == other . value & end == other . end;
                }
                ivy::native_bool operator !=  (const __t &other) const {
                    return ! ((*this) == other);
                }
                bool __is_zero () const {
                    return value . __is_zero() & end . __is_zero();
                }
                struct __hash
                {
                    std::size_t operator ()  (const __t &x) const
                    {
                        return
                            ivy::vector< ivy::cppident_to_cppexpr::undo,pos::__t >::__hash() (x .
                                value) + pos::__t::__hash() (x . end);
                    }
                };
                
            };
            
        }
        
    }
    
}
namespace ivy
{
    namespace cppident_to_cppexpr
    {
        namespace vec_t
        {
            ivy::cppident_to_cppexpr::vec_t::__t empty ();
            
        }
        
    }
    
}
namespace ivy
{
    namespace cppident_to_cppexpr
    {
        struct __t
        {
            ivy::cppident_to_cppexpr::map_t::__t map;
            
            ivy::cppident_to_cppexpr::vec_t::__t del;
            
            vector__pos::__t stack;
            
            void set  (const ivy::ptr< cpp::ident::__t > &id,const ivy::ptr< cpp::expr::__t > &v);
            
            __bool mem  (const ivy::ptr< cpp::ident::__t > &id) const;
            
            ivy::ptr< cpp::expr::__t > value  (const ivy::ptr< cpp::ident::__t > &id) const;
            
            void push ();
            
            void pop ();
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return map == other . map & del == other . del & stack == other . stack;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const
            {
                return map . __is_zero() & del . __is_zero() & stack . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return ivy::cppident_to_cppexpr::map_t::__t::__hash() (x . map) +
                        ivy::cppident_to_cppexpr::vec_t::__t::__hash() (x . del) +
                        vector__pos::__t::__hash() (x . stack);
                }
            };
            
        };
        
    }
    
}
namespace vector__ivy__lvalue_count
{
    namespace domain
    {
        struct __t : ivy::native_unsigned< size_t >
        {
            vector__ivy__lvalue_count::domain::__t next () const;
            
            vector__ivy__lvalue_count::domain::__t prev () const;
            
             __t () {}
             __t  (long long value) : ivy::native_unsigned< size_t > (value) {}
             __t  (const ivy::native_unsigned< size_t > &value) :
                ivy::native_unsigned< size_t > (value) {}
             operator ivy::native_unsigned< size_t > () const {
                return (*this);
            }
        };
        
    }
    
}
namespace vector__ivy__lvalue_count
{
    struct __t
    {
        ivy::vector< ivy::lvalue_count,vector__ivy__lvalue_count::domain::__t > value;
        
        vector__ivy__lvalue_count::domain::__t end;
        
        vector__ivy__lvalue_count::domain::__t begin () const;
        
        void set  (const vector__ivy__lvalue_count::domain::__t &i,const ivy::lvalue_count &v);
        
        void append  (const ivy::lvalue_count &c);
        
        void extend  (const vector__ivy__lvalue_count::__t &x);
        
        void resize  (const vector__ivy__lvalue_count::domain::__t &end);
        
        ivy::lvalue_count back () const;
        
        void pop_back ();
        
        vector__ivy__lvalue_count::__t segment  (const vector__ivy__lvalue_count::domain::__t &beg,const
            vector__ivy__lvalue_count::domain::__t &en) const;
        
        void reverse ();
        
         __t () {}
         __t  (long long value) {}
         operator std::size_t () const {
            return 0;
        }
        static bool __is_seq () {
            return false;
        }
        ivy::native_bool operator ==  (const __t &other) const
        {
            return value == other . value & end == other . end;
        }
        ivy::native_bool operator !=  (const __t &other) const {
            return ! ((*this) == other);
        }
        bool __is_zero () const {
            return value . __is_zero() & end . __is_zero();
        }
        struct __hash
        {
            std::size_t operator ()  (const __t &x) const
            {
                return
                    ivy::vector< ivy::lvalue_count,vector__ivy__lvalue_count::domain::__t >::__hash()
                        (x . value) + vector__ivy__lvalue_count::domain::__t::__hash() (x . end);
            }
        };
        
    };
    
}
namespace vector__ivy__lvalue_count
{
    vector__ivy__lvalue_count::__t empty ();
    
}
namespace ivy
{
    namespace tocppst
    {
        struct __t
        {
            
            // Maps types to their members, which includes destructors and
            // member actions.
            
            ivy::ident_to_declvec::__t members;
            
            
            // Maps types to their C++ superclasses
            
            ivy::ident_to_cppclass::__t cppclasses;
            
            
            // Identifiers of all objects
            
            ivy::ident_set::__t objects;
            
            
            // Types of global actions and variables
            
            ivy::global_types::__t globals;
            
            
            // True if we are emitting a member action
            
            __bool is_member;
            
            
            // The name of the "this" parameter in a member
            
            ivy::ptr< ivy::ident::__t > this_ident;
            
            
            // True if we are in a class declaration
            
            __bool in_class;
            
            
            // True if we are only emitting prototypes
            
            __bool proto_only;
            
            
            // The subtyping relation
            
            ivy::subtypes::__t subtype_rel;
            
            
            // True if we are emitting a native C++ name
            
            __bool native;
            
            
            // True if we are emitting forward declarations
            
            __bool forward;
            
            
            // Current outputs (lvalues to which expression value will be assigned).
            
            vector__ivy__expr::__t outputs;
            
            
            // Code to be emitted before the current statement
            
            vector__cpp__stmt::__t code;
            
            
            // Counter for temporary variables
            
            pos::__t counter;
            
            
            // Map from action names to action prototypes
            
            ivy::ident_to_prototype::__t protos;
            
            
            // The dead list of the current context. If an lvalue is on
            // this list, then any occurrence is the last reference to
            // the value.
            
            vector__ivy__lvalue_count::__t dead;
            
            
            // Tracks the local variables in scope
            
            ivy::local_tracker::__t locals;
            
            
            // The set of constructor functions
            
            ivy::ident_set::__t constructors;
            
            
            // True is compiling rhs of a dot operator
            
            __bool dot_rhs;
            
            
            // Path tree giving path conflicts
            
            ivy::path_tree::__t conflicts;
            
            
            // States of each current borrowing
            
            ivy::ident_to_borrowing::__t borrowings;
            
            
            // Number of borrowins in above
            
            pos::__t num_borrowings;
            
            
            // Map from local variables to borrowed lvalues
            
            ivy::cppident_to_cppexpr::__t fix_borrow_map;
            
            
            // Depth of nesting of conditionals
            
            pos::__t cond_nesting;
            
            
            // Depth of nesting of loops
            
            pos::__t loop_nesting;
            
            
            // Annotation of current assignment
            
            ivy::ptr< annot::__t > asgn_ann;
            
            
            // Depth of nesting of "inbounds" pragma
            
            pos::__t inbounds_nesting;
            
            void add_member  (const ivy::ptr< ivy::ident::__t > &namesp,const ivy::ptr< ivy::decl::__t >
                &member);
            
            void add_stmt  (const ivy::ptr< cpp::stmt::__t > &code);
            
            
            // Get the added code and clear it.
            
            void get_code  (const ivy::ptr< annot::__t > &ann,ivy::ptr< cpp::stmt::__t > &res);
            
            
            // This adds a statement to the end of the current code, clears
            // the code and returns the result.
            
            void wrap_stmt  (const ivy::ptr< cpp::stmt::__t > &code,const ivy::ptr< annot::__t > &ann,ivy::ptr< cpp::stmt::__t >
                &res);
            
             __t () {}
             __t  (long long value) {}
             operator std::size_t () const {
                return 0;
            }
            static bool __is_seq () {
                return false;
            }
            ivy::native_bool operator ==  (const __t &other) const
            {
                return members == other . members & cppclasses == other . cppclasses & objects ==
                    other . objects & globals == other . globals & is_member == other . is_member &
                    this_ident == other . this_ident & in_class == other . in_class & proto_only ==
                    other . proto_only & subtype_rel == other . subtype_rel & native == other .
                    native & forward == other . forward & outputs == other . outputs & code == other
                    . code & counter == other . counter & protos == other . protos & dead == other .
                    dead & locals == other . locals & constructors == other . constructors & dot_rhs
                    == other . dot_rhs & conflicts == other . conflicts & borrowings == other .
                    borrowings & num_borrowings == other . num_borrowings & fix_borrow_map == other
                    . fix_borrow_map & cond_nesting == other . cond_nesting & loop_nesting == other
                    . loop_nesting & asgn_ann == other . asgn_ann & inbounds_nesting == other .
                    inbounds_nesting;
            }
            ivy::native_bool operator !=  (const __t &other) const {
                return ! ((*this) == other);
            }
            bool __is_zero () const
            {
                return members . __is_zero() & cppclasses . __is_zero() & objects . __is_zero() &
                    globals . __is_zero() & is_member . __is_zero() & this_ident . __is_zero() &
                    in_class . __is_zero() & proto_only . __is_zero() & subtype_rel . __is_zero() &
                    native . __is_zero() & forward . __is_zero() & outputs . __is_zero() &
                    code . __is_zero() & counter . __is_zero() & protos . __is_zero() &
                    dead . __is_zero() & locals . __is_zero() & constructors . __is_zero() &
                    dot_rhs . __is_zero() & conflicts . __is_zero() & borrowings . __is_zero() &
                    num_borrowings . __is_zero() & fix_borrow_map . __is_zero() &
                    cond_nesting . __is_zero() & loop_nesting . __is_zero() & asgn_ann . __is_zero()
                    & inbounds_nesting . __is_zero();
            }
            struct __hash
            {
                std::size_t operator ()  (const __t &x) const
                {
                    return ivy::ident_to_declvec::__t::__hash() (x . members) +
                        ivy::ident_to_cppclass::__t::__hash() (x . cppclasses) +
                        ivy::ident_set::__t::__hash() (x . objects) +
                        ivy::global_types::__t::__hash() (x . globals) +
                        __bool::__hash() (x . is_member) +
                        ivy::ptr< ivy::ident::__t >::__hash() (x . this_ident) +
                        __bool::__hash() (x . in_class) + __bool::__hash() (x . proto_only) +
                        ivy::subtypes::__t::__hash() (x . subtype_rel) +
                        __bool::__hash() (x . native) + __bool::__hash() (x . forward) +
                        vector__ivy__expr::__t::__hash() (x . outputs) +
                        vector__cpp__stmt::__t::__hash() (x . code) +
                        pos::__t::__hash() (x . counter) +
                        ivy::ident_to_prototype::__t::__hash() (x . protos) +
                        vector__ivy__lvalue_count::__t::__hash() (x . dead) +
                        ivy::local_tracker::__t::__hash() (x . locals) +
                        ivy::ident_set::__t::__hash() (x . constructors) +
                        __bool::__hash() (x . dot_rhs) +
                        ivy::path_tree::__t::__hash() (x . conflicts) +
                        ivy::ident_to_borrowing::__t::__hash() (x . borrowings) +
                        pos::__t::__hash() (x . num_borrowings) +
                        ivy::cppident_to_cppexpr::__t::__hash() (x . fix_borrow_map) +
                        pos::__t::__hash() (x . cond_nesting) +
                        pos::__t::__hash() (x . loop_nesting) +
                        ivy::ptr< annot::__t >::__hash() (x . asgn_ann) +
                        pos::__t::__hash() (x . inbounds_nesting);
                }
            };
            
        };
        
    }
    
}
// Generate a temporay symbol name
namespace ivy
{
    void temp_sym  (ivy::tocppst::__t &s,const ivy::ptr< annot::__t > &ann,ivy::ptr< cpp::expr::__t >
        &res);
    
}
// This declares a temporary variable in the current code
// context and returns it.
namespace ivy
{
    void make_temp  (ivy::tocppst::__t &s,const ivy::ptr< ivy::expr::__t > &ty,const ivy::ptr< annot::__t >
        &ann,ivy::ptr< cpp::expr::__t > &res);
    
}
// Given a C++ lvalue, this returns its "path". The path is an identifier
// that gives the name of the variable, with a sequence of field references
// appended. For example the path of `f.a(x).b(y)` is `f.(a.b)`. The path of
// a.b(x,y) is `a.b`. On the other hand, `(x+y).a` is not an lvalue and does
// not have a path. For such cases, we return `ok = false`.
namespace ivy
{
    void lvalue_path  (const ivy::ptr< ivy::expr::__t > &s,ivy::access_path::__t &path,__bool &ok);
    
}
// Workaround
namespace ivy
{
    vector__ivy__access_path::__t dummy_vector_access_path;
    
}
// Get a list of all of the lvalue paths occurring in a C++
// expression. The boolean parameters are:
//
// - ao : arguments only
// - ro : roots only
namespace ivy
{
    void lvalue_paths  (const ivy::ptr< ivy::expr::__t > &s,vector__ivy__access_path::__t &paths,const
        __bool &ao,const __bool &ro);
    
}
// This determines whether a C++ lvalue is dead in current context
namespace ivy
{
    __bool is_dead  (const ivy::ptr< cpp::expr::__t > &e,const ivy::tocppst::__t &st,const pos::__t
        &cnt);
    
}
// In context of class declarations, identifiers are declared
// without their namespaces.
namespace ivy
{
    void name_in_context  (ivy::ptr< ivy::expr::__t > &name,const ivy::tocppst::__t &st);
    
}
// Mangle a C++ identifier. This turns `x::y` into `x__y`, which is
// needed for name subscripts to make legal C++ identifiers.
namespace ivy
{
    str::__t mangle  (const ivy::ptr< cpp::ident::__t > &s);
    
}
// In translating Ivy names to C++, we have to avoid clashes with C++
// reserved words like "char" and "bool". We do this by prepending "__".
// C++ names beginning with "__" are reserved for the compiler. If the
// `native` argument is true, we treate the identifier as a native C++
// name and do not perform this translation. Also non-native names with
// subscripts need to be mangled. For example, `x[t]` becomes `x__t`.
namespace ivy
{
    cpp::strident::__t strident_to_cpp  (const ivy::strident::__t &s,const __bool &native);
    
}
// When translating symbols to C++, we need to take care of name clashes between
// namespaces (Ivy objects) and classes (Ivy types). If a type has the same identifier as
// an object, we append `.__t` to the identifier of the type.
namespace ivy
{
    void fix_object_clash  (ivy::ptr< ivy::ident::__t > &id,const ivy::tocppst::__t &st);
    
}
namespace ivy
{
    void make_vector_type  (ivy::ptr< ivy::expr::__t > &ty);
    
}
namespace ivy
{
    void fix_tpl_param  (const ivy::ptr< ivy::expr::__t > &s,ivy::tocppst::__t &st,ivy::ptr< cpp::expr::__t >
        &res);
    
}
namespace ivy
{
    void make_md_vector_type  (const vector__ivy__expr::__t &dom,const ivy::ptr< ivy::expr::__t > &rng,ivy::tocppst::__t
        &st,ivy::ptr< cpp::expr::__t > &res);
    
}
// Function types are handled specially, using C++ templates in the
// standard header. For now we have only a dense representation
// using `std::vector`. This works only when the domain types are
// convertible to `size_t`. We also need at least a hash table type
// here for sparse data.
namespace ivy
{
    void function_type  (const ivy::ptr< ivy::expr::__t > &ty,ivy::tocppst::__t &st,ivy::ptr< cpp::expr::__t >
        &res);
    
}
// Make a C++ expression of the form `ivy::from_str<ty>(arg)`
namespace ivy
{
    ivy::ptr< cpp::expr::__t > make_from_string  (const ivy::ptr< cpp::expr::__t > &ty,const ivy::ptr< cpp::expr::__t >
        &arg,const ivy::ptr< annot::__t > &ann);
    
}
// Make a C++ expression of the form `ivy::from_flt<ty>(arg)`
namespace ivy
{
    ivy::ptr< cpp::expr::__t > make_from_float  (const ivy::ptr< cpp::expr::__t > &ty,const ivy::ptr< cpp::expr::__t >
        &arg,const ivy::ptr< annot::__t > &ann);
    
}
// Returns true if the C++ express is `*this`. This case requires special
// handling for indirect calls. 
namespace ivy
{
    __bool is_cpp_this  (const ivy::ptr< cpp::expr::__t > &s);
    
}
// Make a C++ function call. There are four cases here:
//
// Ordinary function call: `prefix.f(a0..an)`
// Method call: `a0.f(a1..an)`
// Indirect const method call: `a0->f(a1..an)`
// Indirect non-const method call: `a0.get().f(a1..an)`
//
// The last two cases are used if `f : (t * ... -> u)` is a member function where
// type `t` is a variant type. However, if the first argument is `(*this)` we
// do *not* use this form, as `this` is a normal C++ pointer, not a special
// Ivy variant pointer. 
namespace ivy
{
    void make_cpp_call  (const ivy::ptr< ivy::expr::__t > &func,const vector__cpp__expr::__t &args,const
        ivy::ptr< annot::__t > &ann,ivy::tocppst::__t &st,const ivy::prototype::__t &proto,ivy::ptr< cpp::expr::__t >
        &res);
    
}
// After executing a function call, the call gives up ownership of
// its arguments, possibly allowing the arguments to be
// side-effected by future calls. A good example is this:
//
//     a := a.resize(size(a) - 1);
//
// Here, the call to `size` has ownership over `a` which would
// prevent `resize` from side-effecting `a`. However, since the
// call to `size` executes first, it gives up its ownership before
// `resize` executes, so `resize` can side-effect `a`.
namespace ivy
{
    void unown_func_args  (const vector__ivy__expr::__t &args,ivy::tocppst::__t &st);
    
}
// A dead lvalue can be converted to an rvalue, which may allow the
// C++ compiler to use a move rather than a copy.
namespace ivy
{
    void make_rvalue_if_dead  (const ivy::tocppst::__t &st,ivy::ptr< cpp::expr::__t > &inp);
    
}
// Translate an action call to C++. This is complicated, because we have
// to apply the action prototype and deal with call-by-reference.
//
// In-place optimization. There are two cases when a call can modify
// an argument in-place:
//
// (1) Borrowing. This is an in/out parameter given an lvalue that
// is returned by the expression and has exactly one remaining
// alias in the expression.
//
// (2) Return by reference. This is an out parameter given an
// lvalue that is returned by the expression and has no aliases in
// the expression.
//
// In both of these cases, we simply pass the lvalue by non-const
// reference. Any other non-const reference parameter is copied
// to/from a temporary to preserve value semantics.
//
// If the call is return-by-value, then we return the translated
// function call. If return-by-reference, we emit the function call
// and return the lvalue passed to the output parameter, which may
// be a temporary. If the call is the expression root and it
// is return-by-value, then we we assign the outputs as a side
// effect, by copying any temporaries back to the original lvalues,
// and we return ().
//
// Note that any remaining inputs may be either by const ref or by value.
// We need not make this distinction here, however, as call-by-value is
// the same as call-by-const-ref with an internal copy operation.
namespace ivy
{
    void call_to_cpp  (const ivy::ptr< ivy::expr::__t > &func,const vector__ivy__expr::__t &inputs,const
        ivy::ptr< annot::__t > &ann,ivy::tocppst::__t &st,ivy::ptr< cpp::expr::__t > &res);
    
}
namespace ivy
{
    void make_cast_to_bool  (ivy::ptr< cpp::expr::__t > &s);
    
}
namespace ivy
{
    void make_isa  (ivy::ptr< cpp::expr::__t > &s,const ivy::ptr< cpp::expr::__t > &ty);
    
}
namespace ivy
{
    void upcast  (const ivy::ptr< ivy::expr::__t > &lhsty,const ivy::ptr< ivy::expr::__t > &rhs,ivy::tocppst::__t
        &st,ivy::ptr< cpp::expr::__t > &res);
    
}
namespace ivy
{
    void unown_path  (const ivy::access_path::__t &path,ivy::tocppst::__t &st);
    
}
namespace ivy
{
    void kill_lvalue  (const ivy::ptr< ivy::expr::__t > &e,ivy::tocppst::__t &st,const
        vector__ivy__access_path::__t &paths);
    
}
// Here, we find all of the lvalues that are dead after evaluation
// of an expression that references a given list of access paths.  The
// paramer `es` lists the lvalues that are assigned after
// evaluation (and thus are dead even if they are globals). We add
// to this all of the locals that are referenced in the expression
// and known to be dead because they are not subsequently referenced.
//
// For each dead lvalue, we store a count in `st.dead` of the
// the number of path references in the expression that may alias with
// the lvalue. When compiling the expression, this count allows us to determine when
// the last possible reference that may alias with the dead lvalue as been reached.
// At this point the lvalue may be passed by non-const reference or moved, since
// its value is no longer needed.
//
// Note: any local that is referenced inside a loop but declared outside the
// loop is considered live (i.e., it may be referenced in the next loop iteration, and
// we do not keep track of this).
namespace ivy
{
    void kill_lvalues  (const vector__ivy__expr::__t &es,ivy::tocppst::__t &st,const
        vector__ivy__access_path::__t &paths);
    
}
// If the "this" argument of a member function is assign to a
// variable or passed as an argument, and if "this" is of a
// supertype, then we have to use the virtual `__upcast` method of
// the object to get a C-o-W pointer to the object. Otherwise C++
// will slice the object.
namespace ivy
{
    void fix_variant_arg  (const ivy::ptr< ivy::expr::__t > &s,ivy::ptr< cpp::expr::__t > &rhs,const
        ivy::tocppst::__t &st);
    
}
// Given a list of referenced paths, update the live locals.
namespace ivy
{
    void update_live  (const vector__ivy__access_path::__t &paths,ivy::tocppst::__t &st);
    
}
// When borrowing, we sometimes need to strip off "std::move", indicating
// that an expression should be treated as an lvalue.
namespace ivy
{
    void strip_move  (ivy::ptr< cpp::expr::__t > &s);
    
}
// Set up to borrow an lvalue. A potential borrowing is an
// assignment of the form `x := y`, where `x` is a local and `y` is
// an lvalue, provided `x` is dead at then end of the current scope
// and no action calls occur in `y`. A const borrowing is allowed
// if no lvalue occurring in the term `y` is modified
// before the last occurrence of `x`. A non-const borrowing is
// allowed if no lvalue occurring in `y` is referenced before
// the `x` is returned. A return of `x` is an assignment
// `y := x`.
//
// To set up a potential borrowing, we add entry to `st.borrowings` for `local`.
// We also the item `x` in the conflict map to every access path in `y`. This
// allows us mark failed borrowings in subsequent code.
//
// Returns `ok=true` if a borrowing was set up.
//
// Note: a variable referenced in a loop but declared outside the loop is
// considered to be live outside the current scope, since it may be live
// at the beginning of the next iteration and we do not track this. It might actually
// be dead (i.e., if the first reference in the loop is always a full assignment)
// but in this case the programmer can be punished for not declaring the variable
// inside the loop. 
namespace ivy
{
    void setup_borrowing  (const ivy::ptr< ivy::stmt::__t > &s,ivy::tocppst::__t &st,__bool &ok,ivy::ptr< ivy::ident::__t >
        &id);
    
}
// This undoes the effect of `setup_borrowing`, where `id` is the identifier returned
// by `setup_borrowing`.
namespace ivy
{
    void unsetup_borrowing  (const ivy::ptr< ivy::ident::__t > &id,ivy::tocppst::__t &st);
    
}
// Whenver we access paths, we update the state of any conflicting
// borrowings.  We note in the state of any conficting borrowings
// whether we've see a mod or a ref. Note, a mod is any modification of a conflicting
// path, while a ref is only a ref of the value of the path. Further, if a borrow variable is
// assigned, we note this in the borrowing state and cancel
// const reference. Any reference to the borrow variable after a modification
// of a conflicting path cancels all borrowing. Any reference to the value of
// the borrowed lvalue after the variable assigned cancels all borrowing.
namespace ivy
{
    void update_borrowings  (const vector__ivy__access_path::__t &paths,const __bool &is_mod,ivy::tocppst::__t
        &st);
    
}
// When we see an assignment `y := x`, we look to see if `x` is
// borrowing `y`. If so, we mark `x` unassigned. This means that
// `x` and `y` are now semantically equal again, so is is safe to
// reference 'y'. In this case, we return `ok = true`, meaning that
// the assignment should be skipped, as the lhs and rhs are the same
// lvalue.
namespace ivy
{
    void check_borrowing_return  (const ivy::asgn::__t &s,ivy::tocppst::__t &st);
    
}
// Turn a local assignment into a reference
namespace ivy
{
    void make_local_ref  (const ivy::ptr< ivy::expr::__t > &typing,const ivy::ptr< cpp::stmt::__t >
        &lhs,const __bool &is_const,ivy::tocppst::__t &st,ivy::ptr< cpp::stmt::__t > &res);
    
}
// Open or close scope of a pragma. Pragmas:
//
// - inbounds: promises array references in the following code are within
//      the allocated bounds, turns of bounds checking
namespace ivy
{
    void pragma_stmt  (const ivy::ptr< ivy::stmt::__t > &s,const __bool &start,ivy::tocppst::__t &st);
    
}
// The full name of a C++ function depends on whether it is a member function.
// If so, we find take the full name of the class and append the member name.
// The full name of the class can differ from the name of Ivy type because of
// object name clashes.
namespace ivy
{
    void full_action_name  (const ivy::ptr< ivy::expr::__t > &name,const __bool &is_member,ivy::tocppst::__t
        &st,ivy::ptr< cpp::expr::__t > &res);
    
}
namespace ivy
{
    __bool is_input_param  (const ivy::actdc::__t &s,const ivy::ptr< ivy::expr::__t > &p);
    
}
// Make a variable declaration with an initializer
namespace ivy
{
    void make_initializer  (const ivy::ptr< ivy::expr::__t > &typing,const ivy::ptr< cpp::expr::__t >
        &initval,ivy::tocppst::__t &st,ivy::ptr< cpp::stmt::__t > &res);
    
}
namespace ivy
{
    void add_namespaces_rec  (ivy::ptr< cpp::decl::__t > &d,const ivy::ptr< ivy::ident::__t > &id);
    
}
namespace ivy
{
    void add_namespaces  (ivy::ptr< cpp::decl::__t > &d,const ivy::ptr< ivy::ident::__t > &id);
    
}
namespace ivy
{
    void member_name  (ivy::ptr< cpp::expr::__t > &s);
    
}
// Instantiate a standard template. This produces a type name of
// the form `ivy.tpl[ty]`.
namespace ivy
{
    ivy::ptr< cpp::expr::__t > make_std_tpl  (const str::__t &tpl,const str::__t &ty,const ivy::ptr< annot::__t >
        &ann);
    
}
// Make the name of the C++ enum that corresponds to an Ivy enumerated
// type. The name is `__enum_name` where `name is the Ivy name.
namespace ivy
{
    str::__t enum_name  (const ivy::ptr< cpp::expr::__t > &name);
    
}
// Unfortunately, enumerated types can't be classes in C++.  To
// represent one an enumerated type `t`, we declared a C++ enum
// named `__enum_t`. We then instantiate a template
// `ivy::native_enum<__enum_t>` defined in the standard header.
// This wraps the enum in a class with the necessary standard
// traits.  The form of an enum type `name` in the C++ code is:
//
//     enum __enum_name  {elem1,...elemN};
//
//     struct name : ivy::native_enum< __enum_name > {
//         name() : ivy::native_enum< __enum_name >() {}
//         name(long long value) : 
//         name(__enum_name value) : ivy::native_enum< __enum_name >(value) {}
//     };
//
// Note we have to promote the constructors of the base class to
// the derived class. The parameter `sd` is the struct declaration.
// This action prepends the C++ enum declaration.
namespace ivy
{
    void enum_to_cpp  (const ivy::ptr< cpp::expr::__t > &name,const ivy::ptr< ivy::typespec::__t > &spec,const
        ivy::ptr< cpp::decl::__t > &sd,ivy::tocppst::__t &st,ivy::ptr< cpp::decl::__t > &res);
    
}
// All the delcared classes have to have certain standard traits.
// These are:
//
// (1) A default constructor
// (1a) A default copy constructor
// (1b) A default move constructor
// (2) A constructor from (signed or unsigned) long long.
// (3) A conversion to size_t
// (4) A static predicate __is_seq
// (5) A == overload
// (6) A != overload
// (7) A predicate __is_zero
// (8) A class __hash of hashers
//
// Here, we add the standard traits to a C++ structure.
// Make a C++ constructor for a struct
// Default constructor does nothing:
//     name() {};
namespace ivy
{
    cpp::funcdecl::__t make_cpp_cons  (const cpp::structdecl::__t &t);
    
}
namespace ivy
{
    cpp::funcdecl::__t make_virt_destr  (const cpp::structdecl::__t &t);
    
}
namespace ivy
{
    cpp::funcdecl::__t make_upcast_method  (const cpp::structdecl::__t &t);
    
}
// Add a default constructor to a class. The default constructor looks
// like this:
//
//     name([const] name & [&]) = default;
namespace ivy
{
    void add_default_cons  (cpp::structdecl::__t &s,const __bool &is_const,const __bool &is_rvalue);
    
}
// Add a default assignment operator to a class. The default operator looks
// like this:
//
//     name & operator = ([const] name & [&]) = default;
namespace ivy
{
    void add_default_asgn  (cpp::structdecl::__t &s,const __bool &is_const,const __bool &is_rvalue);
    
}
// Numeric constructor does nothing (so that 0 gives default value):
//     name(long long) {};
namespace ivy
{
    void add_numeric_cons  (cpp::structdecl::__t &s);
    
}
// Conversion to size_t returns zero:
//     operator size_t() const { return 0; }
namespace ivy
{
    void add_sizet_conv  (cpp::structdecl::__t &s);
    
}
// __is_seq returns zero:
//     static bool __is_seq() {return false;}
namespace ivy
{
    void add_is_seq_pred  (cpp::structdecl::__t &s);
    
}
// Equality comparison yields member-wise equality: 
//     bool operator==(const name &other) const { return f1==other.f1 & ...; }
namespace ivy
{
    void add_eq_pred  (cpp::structdecl::__t &s);
    
}
// Disequality is just negation of equality
//     bool operator!=(const name &other) const { return !((*this)==other); }
namespace ivy
{
    void add_diseq_pred  (cpp::structdecl::__t &s);
    
}
// __is_zero is conjunction of __is_zero for members.
//    bool __is_zero() const { return f1.is_zero() & ...; }
namespace ivy
{
    void add_is_zero_pred  (cpp::structdecl::__t &s);
    
}
namespace ivy
{
    void add_hasher  (cpp::structdecl::__t &s);
    
}
// Add the standard traits to a struct.
namespace ivy
{
    void add_standard_traits  (cpp::structdecl::__t &s);
    
}
// Add a virtual upcast and destructor to a base class.
namespace ivy
{
    void add_virtual_destructor  (cpp::structdecl::__t &s);
    
}
// Add an virtual upcast derived class.
namespace ivy
{
    void add_upcast_method  (cpp::structdecl::__t &s);
    
}
// Add a constructor that uses the base class constructor.
//
//     derived(t value) : base(value) {}
//     derived(const t& value) : base(value) {}
//
// The latter is produced if the `constref` parameter is true
namespace ivy
{
    void add_derived_cons  (cpp::structdecl::__t &s,const ivy::ptr< cpp::expr::__t > &t,const __bool
        &constref);
    
}
// Add a conversion of a derived struct to its base struct
//
//     operator base () const { return (*this); }
//
namespace ivy
{
    void add_base_conversion  (cpp::structdecl::__t &s);
    
}
// Subclasses of native c++ classes inherit the standard traits from those classes.
// In order to allow them to use the overloads of the native classes, we add this
// boilerplate to the class:
//
// struct ivytype : cpptype {
//    ivytype(long long value) : cpptype(value) {}
//    ivytype(const cpptype &x) : cpptype(x) {}
//    operator cpptype() { return (*this); }
//  };
//
// That is, we provide a constructor from the base class and a conversion to the
// base class. THe latte is used by the C++ compiler when interpreting an expression
// like `x+y`, where `x` and `y` are of the derived class. Since the only available
// conversion is to the base class, the `+` operator of the base class is used. On
// assignment, the constructor is used.
namespace ivy
{
    void add_derived_traits  (cpp::structdecl::__t &s);
    
}
// Native types occur on the right-hand side of `interpret` declarations.
// They need special processing, because we do *not* want to avoid clashes
// with C++ reserved words.
namespace ivy
{
    void native_type_to_cpp  (const ivy::ptr< ivy::expr::__t > &ty,ivy::tocppst::__t &st,ivy::ptr< cpp::expr::__t >
        &res);
    
}
// Here, we register the constructors of enumerated types
namespace ivy
{
    namespace typedc
    {
        void tocpp_show_str  (const str::__t &s);
        
    }
    
}
namespace ivy
{
    __bool is_variant_type  (const ivy::ptr< ivy::expr::__t > &t,const ivy::tocppst::__t &st);
    
}
// When storing values of variant types we use smart pointers. That is,
// type `t` becomes `ivy.ptr<t>`.
namespace ivy
{
    void fix_variant_type  (const ivy::ptr< ivy::expr::__t > &t,ivy::tocppst::__t &st,ivy::ptr< cpp::expr::__t >
        &res);
    
}
namespace ivy
{
    namespace prog
    {
        void show_prog  (const str::__t &s);
        
    }
    
}
namespace ivy
{
    namespace prog
    {
        void file_to_cpp  (const str::__t &name);
        
    }
    
}
namespace argv
{
    pos::__t end ();
    
}
namespace argv
{
    str::__t value  (const pos::__t &idx);
    
}
namespace pid
{
    struct __t : ivy::native_int< int >
    {
         __t () {}
         __t  (long long value) : ivy::native_int< int > (value) {}
         __t  (const ivy::native_int< int > &value) : ivy::native_int< int > (value) {}
         operator ivy::native_int< int > () const {
            return (*this);
        }
    };
    
}
namespace retcode
{
    struct __t : ivy::native_int< int >
    {
         __t () {}
         __t  (long long value) : ivy::native_int< int > (value) {}
         __t  (const ivy::native_int< int > &value) : ivy::native_int< int > (value) {}
         operator ivy::native_int< int > () const {
            return (*this);
        }
    };
    
}
namespace cmd
{
    pid::__t command  (const vector__str::__t &s);
    
}
namespace cmd
{
    retcode::__t wait  (const pid::__t &s);
    
}
namespace ivy
{
    void show_expr  (const ivy::ptr< ivy::expr::__t > &e);
    
}
namespace ivy
{
    void show_ident  (const ivy::ptr< ivy::ident::__t > &id);
    
}
namespace cpp
{
    void show_expr  (const ivy::ptr< cpp::expr::__t > &e);
    
}
void usage ();
__bool __char::__t::is_alphanum () const
{
    __bool __out;
    __out = __char::__t (48) <= (*this) & (*this) < __char::__t (58) | __char::__t (65) <= (*this) &
        (*this) < __char::__t (91) | __char::__t (97) <= (*this) & (*this) < __char::__t (123) |
        (*this) == __char::__t (95);
    return __out;
}
__bool __char::__t::is_bracket () const
{
    __bool __out;
    __out = (*this) == __char::__t (40) | (*this) == __char::__t (41) | (*this) == __char::__t (91)
        | (*this) == __char::__t (93) | (*this) == __char::__t (123) | (*this) == __char::__t (125)
        | (*this) == __char::__t (59) | (*this) == __char::__t (44);
    return __out;
}
__bool __char::__t::is_white () const
{
    __bool __out;
    __out = (*this) == __char::__t (9) | (*this) == __char::__t (10) | (*this) == __char::__t (13) |
        (*this) == __char::__t (32);
    return __out;
}
__char::kinds __char::__t::kind () const
{
    __char::kinds __out;
    __out = (*this) . is_alphanum() ? __char::kinds (__char::alphanum) :
        ((*this) . is_bracket() ? __char::kinds (__char::bracket) : __char::kinds (__char::punct));
    return __out;
}
__bool __char::__t::non_printing () const
{
    __bool __out;
    __out = (*this) < __char::__t (32) | (*this) == __char::__t (127);
    return __out;
}
__bool __char::__t::is_digit () const
{
    __bool __out;
    __out = __char::__t (48) <= (*this) & (*this) < __char::__t (58);
    return __out;
}
__bool __char::__t::is_hex () const
{
    __bool __out;
    __out = (*this) . is_digit() | __char::__t (65) <= (*this) & (*this) < __char::__t (71) |
        __char::__t (97) <= (*this) & (*this) < __char::__t (103);
    return __out;
}
__bool __char::__t::is_capital () const
{
    __bool __out;
    __out = __char::__t (65) <= (*this) & (*this) < __char::__t (91);
    return __out;
}
__char::__t __char::__t::downcase () const
{
    __char::__t __out;
    __out = (*this) . is_capital() ? (*this) + __char::__t (32) : (*this);
    return __out;
}
pos::__t pos::__t::next () const {
    pos::__t y;
    y = (*this) + pos::__t (1);
    return y;
}
pos::__t pos::__t::prev () const {
    pos::__t y;
    y = (*this) - pos::__t (1);
    return y;
}
pos::__t str::__t::begin () const {
    pos::__t res;
    res = pos::__t (0);
    return res;
}
str::__t str::empty () {
    str::__t res;
    {}
    return res;
}
void str::__t::set  (const pos::__t &i,const __char::__t &v) {
    (*this) . value (i) = v;
}
void str::__t::append  (const __char::__t &c)
{
    (*this) . value ((*this) . end) = c;
    (*this) . end = (*this) . end . next();
}
void str::__t::extend  (const str::__t &x)
{
    pos::__t idx;
    idx = x . begin();
    while (idx < x . end) {
        (*this) . append (x . value (idx));
        idx = idx . next();
    }
}
void str::__t::resize  (const pos::__t &end) {
    ivy::resize ((*this) . value,end);
    (*this) . end = end;
}
__char::__t str::__t::back () const
{
    __char::__t y;
    if ((*this) . end > pos::__t (0)) {
        y = (*this) . value ((*this) . end . prev());
    }
    return y;
}
void str::__t::pop_back ()
{
    if ((*this) . end > pos::__t (0))
    {
        pos::__t size;
        size = (*this) . end . prev();
        (*this) . resize (size);
    }
}
str::__t str::__t::segment  (const pos::__t &beg,const pos::__t &en) const
{
    str::__t res;
    {
        pos::__t idx;
        idx = beg;
        while (idx < en & idx < (*this) . end)
        {
            res . append ((*this) . value (idx));
            idx = idx . next();
        }
    }
    return res;
}
void str::__t::reverse ()
{
    pos::__t idx;
    idx = (*this) . begin();
    pos::__t jdx;
    jdx = (*this) . end . prev();
    while (idx < jdx)
    {
        __char::__t tmp;
        tmp = (*this) . value (idx);
        (*this) . value (idx) = (*this) . value (jdx);
        (*this) . value (jdx) = tmp;
        jdx = jdx . prev();
        idx = idx . next();
    }
}
vector__pretty__token::domain::__t vector__pretty__token::domain::__t::next () const
{
    vector__pretty__token::domain::__t y;
    y = (*this) + vector__pretty__token::domain::__t (1);
    return y;
}
vector__pretty__token::domain::__t vector__pretty__token::domain::__t::prev () const
{
    vector__pretty__token::domain::__t y;
    y = (*this) - vector__pretty__token::domain::__t (1);
    return y;
}
vector__pretty__token::domain::__t vector__pretty__token::__t::begin () const
{
    vector__pretty__token::domain::__t res;
    res = vector__pretty__token::domain::__t (0);
    return res;
}
vector__pretty__token::__t vector__pretty__token::empty ()
{
    vector__pretty__token::__t res;
    {}
    return res;
}
void vector__pretty__token::__t::set  (const vector__pretty__token::domain::__t &i,const pretty::token
    &v) {
    (*this) . value (i) = v;
}
void vector__pretty__token::__t::append  (const pretty::token &c)
{
    (*this) . value ((*this) . end) = c;
    (*this) . end = (*this) . end . next();
}
void vector__pretty__token::__t::extend  (const vector__pretty__token::__t &x)
{
    vector__pretty__token::domain::__t idx;
    idx = x . begin();
    while (idx < x . end) {
        (*this) . append (x . value (idx));
        idx = idx . next();
    }
}
void vector__pretty__token::__t::resize  (const vector__pretty__token::domain::__t &end)
{
    ivy::resize ((*this) . value,end);
    (*this) . end = end;
}
pretty::token vector__pretty__token::__t::back () const
{
    pretty::token y;
    if ((*this) . end > vector__pretty__token::domain::__t (0))
    {
        y = (*this) . value ((*this) . end . prev());
    }
    return y;
}
void vector__pretty__token::__t::pop_back ()
{
    if ((*this) . end > vector__pretty__token::domain::__t (0))
    {
        vector__pretty__token::domain::__t size;
        size = (*this) . end . prev();
        (*this) . resize (size);
    }
}
vector__pretty__token::__t vector__pretty__token::__t::segment  (const vector__pretty__token::domain::__t
    &beg,const vector__pretty__token::domain::__t &en) const
{
    vector__pretty__token::__t res;
    {
        vector__pretty__token::domain::__t idx;
        idx = beg;
        while (idx < en & idx < (*this) . end)
        {
            res . append ((*this) . value (idx));
            idx = idx . next();
        }
    }
    return res;
}
void vector__pretty__token::__t::reverse ()
{
    vector__pretty__token::domain::__t idx;
    idx = (*this) . begin();
    vector__pretty__token::domain::__t jdx;
    jdx = (*this) . end . prev();
    while (idx < jdx)
    {
        pretty::token tmp;
        tmp = (*this) . value (idx);
        (*this) . value (idx) = (*this) . value (jdx);
        (*this) . value (jdx) = tmp;
        jdx = jdx . prev();
        idx = idx . next();
    }
}
vector__pretty__state::domain::__t vector__pretty__state::domain::__t::next () const
{
    vector__pretty__state::domain::__t y;
    y = (*this) + vector__pretty__state::domain::__t (1);
    return y;
}
vector__pretty__state::domain::__t vector__pretty__state::domain::__t::prev () const
{
    vector__pretty__state::domain::__t y;
    y = (*this) - vector__pretty__state::domain::__t (1);
    return y;
}
vector__pretty__state::domain::__t vector__pretty__state::__t::begin () const
{
    vector__pretty__state::domain::__t res;
    res = vector__pretty__state::domain::__t (0);
    return res;
}
vector__pretty__state::__t vector__pretty__state::empty ()
{
    vector__pretty__state::__t res;
    {}
    return res;
}
void vector__pretty__state::__t::set  (const vector__pretty__state::domain::__t &i,const pretty::state
    &v) {
    (*this) . value (i) = v;
}
void vector__pretty__state::__t::append  (const pretty::state &c)
{
    (*this) . value ((*this) . end) = c;
    (*this) . end = (*this) . end . next();
}
void vector__pretty__state::__t::extend  (const vector__pretty__state::__t &x)
{
    vector__pretty__state::domain::__t idx;
    idx = x . begin();
    while (idx < x . end) {
        (*this) . append (x . value (idx));
        idx = idx . next();
    }
}
void vector__pretty__state::__t::resize  (const vector__pretty__state::domain::__t &end)
{
    ivy::resize ((*this) . value,end);
    (*this) . end = end;
}
pretty::state vector__pretty__state::__t::back () const
{
    pretty::state y;
    if ((*this) . end > vector__pretty__state::domain::__t (0))
    {
        y = (*this) . value ((*this) . end . prev());
    }
    return y;
}
void vector__pretty__state::__t::pop_back ()
{
    if ((*this) . end > vector__pretty__state::domain::__t (0))
    {
        vector__pretty__state::domain::__t size;
        size = (*this) . end . prev();
        (*this) . resize (size);
    }
}
vector__pretty__state::__t vector__pretty__state::__t::segment  (const vector__pretty__state::domain::__t
    &beg,const vector__pretty__state::domain::__t &en) const
{
    vector__pretty__state::__t res;
    {
        vector__pretty__state::domain::__t idx;
        idx = beg;
        while (idx < en & idx < (*this) . end)
        {
            res . append ((*this) . value (idx));
            idx = idx . next();
        }
    }
    return res;
}
void vector__pretty__state::__t::reverse ()
{
    vector__pretty__state::domain::__t idx;
    idx = (*this) . begin();
    vector__pretty__state::domain::__t jdx;
    jdx = (*this) . end . prev();
    while (idx < jdx)
    {
        pretty::state tmp;
        tmp = (*this) . value (idx);
        (*this) . value (idx) = (*this) . value (jdx);
        (*this) . value (jdx) = tmp;
        jdx = jdx . prev();
        idx = idx . next();
    }
}
vector__pos::domain::__t vector__pos::domain::__t::next () const
{
    vector__pos::domain::__t y;
    y = (*this) + vector__pos::domain::__t (1);
    return y;
}
vector__pos::domain::__t vector__pos::domain::__t::prev () const
{
    vector__pos::domain::__t y;
    y = (*this) - vector__pos::domain::__t (1);
    return y;
}
vector__pos::domain::__t vector__pos::__t::begin () const
{
    vector__pos::domain::__t res;
    res = vector__pos::domain::__t (0);
    return res;
}
vector__pos::__t vector__pos::empty () {
    vector__pos::__t res;
    {}
    return res;
}
void vector__pos::__t::set  (const vector__pos::domain::__t &i,const pos::__t &v)
{
    (*this) . value (i) = v;
}
void vector__pos::__t::append  (const pos::__t &c)
{
    (*this) . value ((*this) . end) = c;
    (*this) . end = (*this) . end . next();
}
void vector__pos::__t::extend  (const vector__pos::__t &x)
{
    vector__pos::domain::__t idx;
    idx = x . begin();
    while (idx < x . end) {
        (*this) . append (x . value (idx));
        idx = idx . next();
    }
}
void vector__pos::__t::resize  (const vector__pos::domain::__t &end)
{
    ivy::resize ((*this) . value,end);
    (*this) . end = end;
}
pos::__t vector__pos::__t::back () const
{
    pos::__t y;
    if ((*this) . end > vector__pos::domain::__t (0)) {
        y = (*this) . value ((*this) . end . prev());
    }
    return y;
}
void vector__pos::__t::pop_back ()
{
    if ((*this) . end > vector__pos::domain::__t (0))
    {
        vector__pos::domain::__t size;
        size = (*this) . end . prev();
        (*this) . resize (size);
    }
}
vector__pos::__t vector__pos::__t::segment  (const vector__pos::domain::__t &beg,const vector__pos::domain::__t
    &en) const
{
    vector__pos::__t res;
    {
        vector__pos::domain::__t idx;
        idx = beg;
        while (idx < en & idx < (*this) . end)
        {
            res . append ((*this) . value (idx));
            idx = idx . next();
        }
    }
    return res;
}
void vector__pos::__t::reverse ()
{
    vector__pos::domain::__t idx;
    idx = (*this) . begin();
    vector__pos::domain::__t jdx;
    jdx = (*this) . end . prev();
    while (idx < jdx)
    {
        pos::__t tmp;
        tmp = (*this) . value (idx);
        (*this) . value (idx) = (*this) . value (jdx);
        (*this) . value (jdx) = tmp;
        jdx = jdx . prev();
        idx = idx . next();
    }
}
pretty::__t pretty::make  (const pos::__t &maxline,const pos::__t &indent)
{
    pretty::__t res;
    {
        res . maxline = maxline;
        res . indent = indent;
        res . whitespace = ivy::from_str< str::__t > (" ");
        res . space = maxline;
        res . stack . append (maxline);
    }
    return res;
}
void pretty::__t::do_indent ()
{
    (*this) . output . append (__char::__t (10));
    
    // newline
    
    pos::__t idx;
    idx = (*this) . maxline - (*this) . space;
    while (idx > pos::__t (0))
    {
        (*this) . output . append (__char::__t (32));
        
        // space
        
        idx = idx . prev();
    }
}
void pretty::__t::print  (const pretty::token &tok)
{
    if (tok . pair)
    {
        if (tok . second <= (*this) . space | (*this) . space == (*this) . maxline)
        {
            (*this) . output . extend (tok . first);
            (*this) . space = (*this) . space - tok . first . end;
        } else
        {
            (*this) . space = (*this) . maxline - tok . tdepth * (*this) . indent;
            (*this) . do_indent();
        }
    } else
    {
        (*this) . output . extend (tok . first);
        (*this) . space = (*this) . space - tok . first . end;
    }
}
void pretty::__t::flush ()
{
    vector__pretty__token::domain::__t idx;
    idx = (*this) . tokens . begin();
    while (idx < (*this) . tokens . end)
    {
        (*this) . print ((*this) . tokens . value (idx));
        idx = idx . next();
    }
    (*this) . tokens = vector__pretty__token::empty();
}
void pretty::__t::add_length  (const pos::__t &len,const vector__pretty__token::domain::__t &at)
{
    if (at > (*this) . st . begin)
    {
        pretty::token prev;
        prev = (*this) . tokens . value (at . prev());
        if (prev . pair)
        {
            pretty::token newtok;
            newtok = prev;
            newtok . second = newtok . second + len;
            (*this) . tokens . set (at . prev(),newtok);
        }
    }
    {}
}
void pretty::__t::extend  (const str::__t &string)
{
    pretty::token tok;
    tok . pair = ivy::native_bool (false);
    tok . tdepth = (*this) . depth;
    tok . first = string;
    if (ivy::native_bool (true) & string == (*this) . whitespace)
    {
        
        // true = breakable
        
        tok . pair = ivy::native_bool (true);
        tok . second = string . end;
    } else {
        (*this) . add_length (string . end,(*this) . tokens . end);
    }
    (*this) . tokens . append (tok);
    (*this) . st . total = (*this) . st . total + string . end;
}
void pretty::__t::newline ()
{
    pretty::token tok;
    tok . pair = ivy::native_bool (true);
    tok . tdepth = (*this) . depth;
    tok . second = (*this) . maxline + pos::__t (1);
    (*this) . tokens . append (tok);
}
void pretty::__t::nest ()
{
    (*this) . stack . append ((*this) . space);
    (*this) . states . append ((*this) . st);
    (*this) . st . total = pos::__t (0);
    (*this) . st . begin = (*this) . tokens . end;
    (*this) . depth = (*this) . depth + pos::__t (1);
}
void pretty::__t::unnest ()
{
    pretty::state oldst;
    oldst = (*this) . st;
    (*this) . stack . pop_back();
    (*this) . st = (*this) . states . back();
    (*this) . states . pop_back();
    (*this) . add_length (oldst . total,oldst . begin);
    (*this) . st . total = (*this) . st . total + oldst . total;
    (*this) . depth = (*this) . depth - pos::__t (1);
}
void str::__t::encode  (pretty::__t &b) const {
    b . extend ((*this));
}
void annot::__t::encode  (pretty::__t &b) const {}
ivy::ptr< annot::__t > annot::__t::strip () const {
    ivy::ptr< annot::__t > res;
    {}
    return res;
}
str::__t annot::__t::to_str () const {
    str::__t res;
    {}
    return res;
}
vector__str::domain::__t vector__str::domain::__t::next () const
{
    vector__str::domain::__t y;
    y = (*this) + vector__str::domain::__t (1);
    return y;
}
vector__str::domain::__t vector__str::domain::__t::prev () const
{
    vector__str::domain::__t y;
    y = (*this) - vector__str::domain::__t (1);
    return y;
}
vector__str::domain::__t vector__str::__t::begin () const
{
    vector__str::domain::__t res;
    res = vector__str::domain::__t (0);
    return res;
}
vector__str::__t vector__str::empty () {
    vector__str::__t res;
    {}
    return res;
}
void vector__str::__t::set  (const vector__str::domain::__t &i,const str::__t &v)
{
    (*this) . value (i) = v;
}
void vector__str::__t::append  (const str::__t &c)
{
    (*this) . value ((*this) . end) = c;
    (*this) . end = (*this) . end . next();
}
void vector__str::__t::extend  (const vector__str::__t &x)
{
    vector__str::domain::__t idx;
    idx = x . begin();
    while (idx < x . end) {
        (*this) . append (x . value (idx));
        idx = idx . next();
    }
}
void vector__str::__t::resize  (const vector__str::domain::__t &end)
{
    ivy::resize ((*this) . value,end);
    (*this) . end = end;
}
str::__t vector__str::__t::back () const
{
    str::__t y;
    if ((*this) . end > vector__str::domain::__t (0)) {
        y = (*this) . value ((*this) . end . prev());
    }
    return y;
}
void vector__str::__t::pop_back ()
{
    if ((*this) . end > vector__str::domain::__t (0))
    {
        vector__str::domain::__t size;
        size = (*this) . end . prev();
        (*this) . resize (size);
    }
}
vector__str::__t vector__str::__t::segment  (const vector__str::domain::__t &beg,const vector__str::domain::__t
    &en) const
{
    vector__str::__t res;
    {
        vector__str::domain::__t idx;
        idx = beg;
        while (idx < en & idx < (*this) . end)
        {
            res . append ((*this) . value (idx));
            idx = idx . next();
        }
    }
    return res;
}
void vector__str::__t::reverse ()
{
    vector__str::domain::__t idx;
    idx = (*this) . begin();
    vector__str::domain::__t jdx;
    jdx = (*this) . end . prev();
    while (idx < jdx)
    {
        str::__t tmp;
        tmp = (*this) . value (idx);
        (*this) . value (idx) = (*this) . value (jdx);
        (*this) . value (jdx) = tmp;
        jdx = jdx . prev();
        idx = idx . next();
    }
}
void annot_i::__t::encode  (pretty::__t &b) const
{
    if (vector__str::domain::__t (0) < (*this) . comments . end)
    {
        if (! b . annots ((*this) . file,(*this) . line))
        {
            b . newline();
            vector__str::domain::__t idx;
            idx = (*this) . comments . begin();
            while (idx < (*this) . comments . end)
            {
                b . extend (b . cppstyle ? ivy::from_str< str::__t > ("//") :
                        ivy::from_str< str::__t > ("#"));
                b . extend ((*this) . comments . value (idx));
                b . newline();
                idx = idx . next();
            }
            b . newline();
            b . annots ((*this) . file,(*this) . line) = ivy::native_bool (true);
        }
    }
}
ivy::ptr< annot::__t > annot_i::__t::strip () const
{
    ivy::ptr< annot::__t > res;
    {
        annot_i::__t news;
        news = (*this);
        news . comments = vector__str::empty();
        res = news;
    }
    return res;
}
str::__t annot_i::__t::to_str () const
{
    str::__t res;
    {
        res = (*this) . file;
        res . extend (ivy::from_str< str::__t > (": line "));
        res . extend ((*this) . line . next() . to_str());
    }
    return res;
}
void pstate::__t::consume () {
    lex ((*this));
}
pstate::__t pstate::make  (const str::__t &s)
{
    pstate::__t st;
    {
        st . b = s;
        st . p = s . begin();
        st . ok = ivy::native_bool (true);
        st . consume();
    }
    return st;
}
void pstate::__t::get_ann  (ivy::ptr< annot::__t > &ann)
{
    ann = (*this) . ann;
    (*this) . ann . comments = vector__str::empty();
}
void skip_space  (pstate::__t &st) 
// Skip space, tab, carriage return and newline characters
{
    while (st . p < st . b . end & st . b . value (st . p) . is_white())
    {
        if (st . b . value (st . p) == __char::__t (10))
        {
            st . ann . line = st . ann . line . next();
        }
        st . p = st . p . next();
    }
}
void get_line  (pstate::__t &st,str::__t &line) 
// Read until a newline or end of input.
{
    pos::__t start;
    start = st . p;
    while (st . p < st . b . end & st . b . value (st . p) != __char::__t (10)) 
    // newline
    
    {
        st . p = st . p . next();
    }
    line = st . b . segment (start,st . p);
    if (st . p < st . b . end) {
        st . ann . line = st . ann . line . next();
        st . p = st . p . next();
    }
    {}
}
void get_annot  (pstate::__t &st)
{
    skip_space (st);
    while (st . p < st . b . end & st . b . value (st . p) == __char::__t (35))
    {
        
        // hash sign
        
        st . p = st . p . next();
        
        // skip the hash sign
        
        str::__t comment;
        get_line (st,comment);
        st . ann . comments . append (comment);
        skip_space (st);
    }
}
void read_string_literal  (pstate::__t &st)
{
    st . tok = ivy::from_str< str::__t > ("");
    st . tok . append (__char::__t (34));
    
    // workaround
    
    st . p = st . p . next();
    while (st . ok & st . p < st . b . end & st . b . value (st . p) != __char::__t (34))
    {
        __char::__t chr;
        chr = st . b . value (st . p);
        if (chr == __char::__t (92))
        {
            st . tok . append (__char::__t (92));
            st . p = st . p . next();
            if (st . p < st . b . end)
            {
                chr = st . b . value (st . p);
                if (! chr . non_printing())
                {
                    st . tok . append (chr);
                    
                    // newline
                    
                    st . p = st . p . next();
                } else {
                    st . ok = ivy::native_bool (false);
                }
                {}
            } else {
                st . ok = ivy::native_bool (false);
            }
        } else
        {
            if (! chr . non_printing()) {
                st . tok . append (chr);
                st . p = st . p . next();
            } else {
                st . ok = ivy::native_bool (false);
            }
        }
    }
    if (st . ok & st . p < st . b . end)
    {
        st . tok . append (__char::__t (34));
        
        // double quote
        
        st . p = st . p . next();
    } else {
        st . ok = ivy::native_bool (false);
    }
}
void decimals::read  (pstate::__t &st)
{
    if (st . ok & st . p < st . b . end & st . b . value (st . p) . is_digit())
    {
        while (st . ok & st . p < st . b . end & st . b . value (st . p) . is_digit())
        {
            st . tok . append (st . b . value (st . p));
            st . p = st . p . next();
        }
    } else {
        st . ok = ivy::native_bool (false);
    }
}
void hexes::read  (pstate::__t &st)
{
    if (st . ok & st . p < st . b . end & st . b . value (st . p) . is_hex())
    {
        while (st . ok & st . p < st . b . end & st . b . value (st . p) . is_hex())
        {
            st . tok . append (st . b . value (st . p));
            st . p = st . p . next();
        }
    } else {
        st . ok = ivy::native_bool (false);
    }
}
void read_numeric_literal  (pstate::__t &st)
{
    st . tok = ivy::from_str< str::__t > ("");
    if (st . p . next() < st . b . end & st . b . value (st . p) == __char::__t (48) &
    st . b . value (st . p . next()) . downcase() == __char::__t (120))
    {
        st . tok . append (__char::__t (48));
        st . tok . append (__char::__t (120));
        st . p = st . p . next() . next();
        hexes::read (st);
    } else
    {
        decimals::read (st);
        if (st . ok & st . p < st . b . end & st . b . value (st . p) == __char::__t (46))
        {
            st . tok . append (__char::__t (46));
            st . p = st . p . next();
            decimals::read (st);
            if (st . ok & st . p < st . b . end & st . b . value (st . p) . downcase() ==
            __char::__t (101))
            {
                st . tok . append (__char::__t (101));
                st . p = st . p . next();
                if (st . p < st . b . end &
                (st . b . value (st . p) == __char::__t (45) | st . b . value (st . p) ==
                    __char::__t (43)))
                {
                    st . tok . append (st . b . value (st . p));
                    st . p = st . p . next();
                }
                decimals::read (st);
            }
        }
    }
}
void lex  (pstate::__t &st)
{
    get_annot (st);
    pos::__t start;
    start = st . p;
    if (st . p < st . b . end & st . b . value (st . p) == __char::__t (34))
    {
        read_string_literal (st);
    } else
    {
        if (st . b . value (st . p) . is_digit()) {
            read_numeric_literal (st);
        } else
        {
            __char::__t last;
            last = __char::__t (32);
            while (st . p < st . b . end & ! st . b . value (st . p) . is_white() &
            (last == __char::__t (32) | st . b . value (st . p) . kind() == last . kind()) &
            last . kind() != __char::kinds (__char::bracket))
            {
                last = st . b . value (st . p);
                if (last . non_printing()) {
                    st . ok = ivy::native_bool (false);
                }
                st . p = st . p . next();
            }
            st . tok = st . b . segment (start,st . p);
        }
    }
}
str::__t pos::__t::to_str () const
{
    str::__t res;
    {
        pos::__t x;
        x = (*this);
        if (x < pos::__t (0)) {
            res . extend (ivy::from_str< str::__t > ("-"));
            x = pos::__t (0) - x;
        }
        if (x == pos::__t (0)) {
            res . extend (ivy::from_str< str::__t > ("0"));
        } else
        {
            str::__t tmp;
            while (x > pos::__t (0))
            {
                pos::__t y;
                y = x - x / pos::__t (10) * pos::__t (10);
                
                // workaround: v1.7 compiler can't cast between numeric types
                
                __char::__t digit;
                digit = __char::__t (48);
                while (y > pos::__t (0)) {
                    y = y - pos::__t (1);
                    digit = digit + __char::__t (1);
                }
                tmp . append (digit);
                x = x / pos::__t (10);
            }
            pos::__t idx;
            idx = tmp . end;
            while (idx > tmp . begin()) {
                idx = idx . prev();
                res . append (tmp . value (idx));
            }
        }
    }
    return res;
}
pos::__t pos::from_str  (const str::__t &x)
{
    pos::__t res;
    {
        pos::__t idx;
        idx = x . begin();
        __bool neg;
        neg = ivy::native_bool (false);
        if (idx < x . end & x . value (idx) == __char::__t (45))
        {
            neg = ivy::native_bool (true);
            idx = idx . next();
        }
        while (idx < x . end)
        {
            res = res * pos::__t (10);
            __char::__t digit;
            digit = x . value (idx);
            
            // workaround: v1.7 compiler can't cast between numeric types
            
            while (digit > __char::__t (48))
            {
                digit = digit - __char::__t (1);
                res = res + pos::__t (1);
            }
            idx = idx . next();
        }
    }
    return res;
}
void stdio::write  (const str::__t &s)
{
    pos::__t idx;
    idx = s . begin();
    while (idx < s . end) {
        ivy::put (s . value (idx));
        idx = idx + pos::__t (1);
    }
}
void stdio::writeln  (const str::__t &s) {
    stdio::write (s);
    ivy::put (ivy::cint (10));
}
str::__t stdio::read ()
{
    str::__t s;
    {
        __char::__t c;
        c = ivy::get();
        while (c >= __char::__t (0)) {
            s . append (c);
            c = ivy::get();
        }
    }
    return s;
}
str::__t stdio::readln ()
{
    str::__t s;
    {
        __char::__t c;
        c = ivy::get();
        while (c >= __char::__t (0) & c != __char::__t (10)) {
            s . append (c);
            c = ivy::get();
        }
    }
    return s;
}
void parse_error  (const pos::__t &p,const str::__t &tok) {}
__bool ivy::is_logvar_name  (const str::__t &name)
{
    __bool res;
    if (name . value (pos::__t (0)) . is_capital())
    {
        res = ivy::native_bool (true);
        pos::__t idx;
        idx = name . begin() . next();
        while (res & idx < name . end) {
            res = name . value (idx) . is_digit();
        }
        idx = idx . next();
    }
    return res;
}
ivy::verb::__t ivy::verb_from_name  (const str::__t &name)
{
    ivy::verb::__t vrb;
    if (name . value (pos::__t (0)) . is_digit())
    {
        vrb = ivy::verb::__t (ivy::verb::numeral);
        pos::__t idx;
        idx = name . begin();
        while (idx < name . end)
        {
            if (name . value (idx) == __char::__t (46)) {
                vrb = ivy::verb::__t (ivy::verb::fltnum);
            }
            idx = idx . next();
        }
    } else
    {
        if (name . value (pos::__t (0)) == __char::__t (34)) 
        // double quote character
        
        {
            vrb = ivy::verb::__t (ivy::verb::string);
        } else
        {
            if (ivy::is_logvar_name (name)) {
                vrb = ivy::verb::__t (ivy::verb::logvar);
            } else {
                vrb = ivy::str_to_verb (name);
            }
        }
    }
    return vrb;
}
void ivy::ident::__t::encode  (pretty::__t &b,const priority::__t &prio) const {}
str::__t ivy::ident::__t::to_str () const {
    str::__t res;
    {}
    return res;
}
ivy::ptr< ivy::ident::__t > ivy::ident::__t::get_namesp () const
{
    ivy::ptr< ivy::ident::__t > res;
    {}
    return res;
}
ivy::ptr< ivy::ident::__t > ivy::ident::__t::get_member () const
{
    ivy::ptr< ivy::ident::__t > res;
    {}
    return res;
}
vector__ivy__ident::__t ivy::ident::__t::get_subscripts () const
{
    vector__ivy__ident::__t res;
    {}
    return res;
}
ivy::ptr< ivy::ident::__t > ivy::ident::__t::prefix  (const ivy::ptr< ivy::ident::__t > &pref) const
{
    ivy::ptr< ivy::ident::__t > res;
    res = (*this) . __upcast();
    return res;
}
ivy::strident::__t ivy::ident::__t::get_last () const {
    ivy::strident::__t res;
    {}
    return res;
}
ivy::verb::__t ivy::ident::__t::get_verb () const
{
    ivy::verb::__t vrb;
    vrb = ivy::verb::__t (ivy::verb::none);
    return vrb;
}
vector__ivy__ident::domain::__t vector__ivy__ident::domain::__t::next () const
{
    vector__ivy__ident::domain::__t y;
    y = (*this) + vector__ivy__ident::domain::__t (1);
    return y;
}
vector__ivy__ident::domain::__t vector__ivy__ident::domain::__t::prev () const
{
    vector__ivy__ident::domain::__t y;
    y = (*this) - vector__ivy__ident::domain::__t (1);
    return y;
}
vector__ivy__ident::domain::__t vector__ivy__ident::__t::begin () const
{
    vector__ivy__ident::domain::__t res;
    res = vector__ivy__ident::domain::__t (0);
    return res;
}
vector__ivy__ident::__t vector__ivy__ident::empty () {
    vector__ivy__ident::__t res;
    {}
    return res;
}
void vector__ivy__ident::__t::set  (const vector__ivy__ident::domain::__t &i,const ivy::ptr< ivy::ident::__t >
    &v) {
    (*this) . value (i) = v;
}
void vector__ivy__ident::__t::append  (const ivy::ptr< ivy::ident::__t > &c)
{
    (*this) . value ((*this) . end) = c;
    (*this) . end = (*this) . end . next();
}
void vector__ivy__ident::__t::extend  (const vector__ivy__ident::__t &x)
{
    vector__ivy__ident::domain::__t idx;
    idx = x . begin();
    while (idx < x . end) {
        (*this) . append (x . value (idx));
        idx = idx . next();
    }
}
void vector__ivy__ident::__t::resize  (const vector__ivy__ident::domain::__t &end)
{
    ivy::resize ((*this) . value,end);
    (*this) . end = end;
}
ivy::ptr< ivy::ident::__t > vector__ivy__ident::__t::back () const
{
    ivy::ptr< ivy::ident::__t > y;
    if ((*this) . end > vector__ivy__ident::domain::__t (0))
    {
        y = (*this) . value ((*this) . end . prev());
    }
    return y;
}
void vector__ivy__ident::__t::pop_back ()
{
    if ((*this) . end > vector__ivy__ident::domain::__t (0))
    {
        vector__ivy__ident::domain::__t size;
        size = (*this) . end . prev();
        (*this) . resize (size);
    }
}
vector__ivy__ident::__t vector__ivy__ident::__t::segment  (const vector__ivy__ident::domain::__t &beg,const
    vector__ivy__ident::domain::__t &en) const
{
    vector__ivy__ident::__t res;
    {
        vector__ivy__ident::domain::__t idx;
        idx = beg;
        while (idx < en & idx < (*this) . end)
        {
            res . append ((*this) . value (idx));
            idx = idx . next();
        }
    }
    return res;
}
void vector__ivy__ident::__t::reverse ()
{
    vector__ivy__ident::domain::__t idx;
    idx = (*this) . begin();
    vector__ivy__ident::domain::__t jdx;
    jdx = (*this) . end . prev();
    while (idx < jdx)
    {
        ivy::ptr< ivy::ident::__t > tmp;
        tmp = (*this) . value (idx);
        (*this) . value (idx) = (*this) . value (jdx);
        (*this) . value (jdx) = tmp;
        jdx = jdx . prev();
        idx = idx . next();
    }
}
void ivy::strident::__t::encode  (pretty::__t &b,const priority::__t &prio) const
{
    b . extend ((*this) . val);
    if (ivy::native_bool (false))
    {
        if ((*this) . subscrs . end > vector__ivy__ident::domain::__t (0))
        {
            b . extend (ivy::from_str< str::__t > ("< "));
            vector__ivy__ident::domain::__t idx;
            idx = (*this) . subscrs . begin();
            while (idx < (*this) . subscrs . end)
            {
                if (idx > vector__ivy__ident::domain::__t (0))
                {
                    b . extend (ivy::from_str< str::__t > (","));
                }
                (*this) . subscrs . value (idx) -> encode (b,priority::__t (0));
                idx = idx . next();
            }
            b . extend (ivy::from_str< str::__t > (" >"));
        }
    } else
    {
        vector__ivy__ident::domain::__t idx;
        idx = (*this) . subscrs . begin();
        while (idx < (*this) . subscrs . end)
        {
            b . extend (ivy::from_str< str::__t > ("["));
            (*this) . subscrs . value (idx) -> encode (b,priority::__t (0));
            b . extend (ivy::from_str< str::__t > ("]"));
            idx = idx . next();
        }
    }
}
ivy::ptr< ivy::ident::__t > ivy::strident::make  (const str::__t &val)
{
    ivy::ptr< ivy::ident::__t > res;
    {
        ivy::strident::__t s;
        s . val = val;
        res = s;
    }
    return res;
}
ivy::ptr< ivy::ident::__t > ivy::strident::make1  (const str::__t &val,const ivy::ptr< ivy::ident::__t >
    &arg)
{
    ivy::ptr< ivy::ident::__t > res;
    {
        ivy::strident::__t s;
        s . val = val;
        s . subscrs . append (arg);
        res = s;
    }
    return res;
}
str::__t ivy::strident::__t::to_str () const
{
    str::__t b;
    {
        b = (*this) . val;
        if (ivy::native_bool (false))
        {
            if ((*this) . subscrs . end > vector__ivy__ident::domain::__t (0))
            {
                b . extend (ivy::from_str< str::__t > ("< "));
                vector__ivy__ident::domain::__t idx;
                idx = (*this) . subscrs . begin();
                while (idx < (*this) . subscrs . end)
                {
                    if (idx > vector__ivy__ident::domain::__t (0))
                    {
                        b . extend (ivy::from_str< str::__t > (","));
                    }
                    b . extend ((*this) . subscrs . value (idx) -> to_str());
                    idx = idx . next();
                }
                b . extend (ivy::from_str< str::__t > (" >"));
            }
        } else
        {
            vector__ivy__ident::domain::__t idx;
            idx = (*this) . subscrs . begin();
            while (idx < (*this) . subscrs . end)
            {
                b . extend (ivy::from_str< str::__t > ("["));
                b . extend ((*this) . subscrs . value (idx) -> to_str());
                b . extend (ivy::from_str< str::__t > ("]"));
                idx = idx . next();
            }
        }
    }
    return b;
}
ivy::ptr< ivy::ident::__t > ivy::strident::__t::prefix  (const ivy::ptr< ivy::ident::__t > &pref)
    const {
    ivy::ptr< ivy::ident::__t > res;
    res = ivy::dotident::make (pref,(*this));
    return res;
}
void ivy::strident::parse  (pstate::__t &st,ivy::strident::__t &id)
{
    if (st . ok & st . tok . end != pos::__t (0))
    {
        id . val = st . tok;
        st . consume();
        while (st . ok & st . tok == ivy::from_str< str::__t > ("["))
        {
            st . consume();
            ivy::strident::__t mid;
            ivy::strident::parse (st,mid);
            ivy::ptr< ivy::ident::__t > sid;
            sid = mid;
            while (st . ok & st . tok == ivy::from_str< str::__t > ("."))
            {
                st . consume();
                ivy::strident::parse (st,mid);
                sid = ivy::dotident::make (sid,mid);
            }
            if (st . ok & st . tok == ivy::from_str< str::__t > ("]"))
            {
                st . consume();
                id . subscrs . append (sid);
            } else {
                st . ok = ivy::native_bool (false);
            }
        }
    } else {
        st . ok = ivy::native_bool (false);
    }
}
ivy::strident::__t ivy::strident::__t::get_last () const
{
    ivy::strident::__t res;
    res = (*this);
    return res;
}
ivy::verb::__t ivy::strident::__t::get_verb () const
{
    ivy::verb::__t vrb;
    vrb = ivy::verb_from_name ((*this) . val);
    return vrb;
}
void ivy::numident::__t::encode  (pretty::__t &b,const priority::__t &prio) const
{
    b . extend (ivy::from_str< str::__t > ("["));
    b . extend ((*this) . val . to_str());
    b . extend (ivy::from_str< str::__t > ("]"));
}
ivy::ptr< ivy::ident::__t > ivy::numident::make  (const pos::__t &val)
{
    ivy::ptr< ivy::ident::__t > res;
    {
        ivy::numident::__t s;
        s . val = val;
        res = s;
    }
    return res;
}
void ivy::dotident::__t::encode  (pretty::__t &b,const priority::__t &prio) const
{
    (*this) . namesp -> encode (b,priority::__t (0));
    b . extend (ivy::native_bool (false) ? ivy::from_str< str::__t > ("::") :
            ivy::from_str< str::__t > ("."));
    (*this) . member . encode (b,priority::__t (0));
}
ivy::ptr< ivy::ident::__t > ivy::dotident::make  (const ivy::ptr< ivy::ident::__t > &namesp,const
    ivy::strident::__t &member)
{
    ivy::ptr< ivy::ident::__t > res;
    {
        ivy::dotident::__t s;
        s . namesp = namesp;
        s . member = member;
        res = s;
    }
    return res;
}
str::__t ivy::dotident::__t::to_str () const
{
    str::__t res;
    {
        res = (*this) . namesp -> to_str();
        res . extend (ivy::native_bool (false) ? ivy::from_str< str::__t > ("::") :
                ivy::from_str< str::__t > ("."));
        res . extend ((*this) . member . to_str());
    }
    return res;
}
ivy::ptr< ivy::ident::__t > ivy::dotident::__t::get_namesp () const
{
    ivy::ptr< ivy::ident::__t > res;
    res = (*this) . namesp;
    return res;
}
ivy::ptr< ivy::ident::__t > ivy::dotident::__t::get_member () const
{
    ivy::ptr< ivy::ident::__t > res;
    res = (*this) . member;
    return res;
}
ivy::ptr< ivy::ident::__t > ivy::dotident::__t::prefix  (const ivy::ptr< ivy::ident::__t > &pref)
    const
{
    ivy::ptr< ivy::ident::__t > res;
    res = ivy::dotident::make ((*this) . namesp -> prefix (pref),(*this) . member);
    return res;
}
ivy::strident::__t ivy::dotident::__t::get_last () const
{
    ivy::strident::__t res;
    res = (*this) . member;
    return res;
}
void ivy::expr::__t::encode  (pretty::__t &b,const priority::__t &prio) const {}
str::__t ivy::expr::__t::enc () const
{
    str::__t s;
    {
        pretty::__t p;
        p = pretty::make (pos::__t (100),pos::__t (4));
        p . cppstyle = ivy::native_bool (false);
        (*this) . encode (p,priority::__t (0));
        p . flush();
        s = p . output;
    }
    return s;
}
ivy::ptr< ivy::expr::__t > ivy::expr::dec  (const str::__t &s)
{
    ivy::ptr< ivy::expr::__t > e;
    {
        pstate::__t st;
        st = pstate::make (s);
        ivy::expr::parse (st,priority::__t (0),e);
        if (! st . ok | st . tok . end != pos::__t (0)) {
            parse_error (st . ann . line,st . tok);
        }
    }
    return e;
}
str::__t ivy::expr::encdec  (const str::__t &s)
{
    str::__t res;
    {
        ivy::ptr< ivy::expr::__t > e;
        e = ivy::expr::dec (s);
        res = e -> enc();
    }
    return res;
}
ivy::verb::__t ivy::expr::__t::get_verb () const
{
    ivy::verb::__t vrb;
    vrb = ivy::verb::__t (ivy::verb::none);
    return vrb;
}
ivy::verb::__t ivy::expr::__t::get_verb_typed () const
{
    ivy::verb::__t vrb;
    if ((*this) . is (ivy::verb::__t (ivy::verb::colon)))
    {
        vrb = (*this) . get_arg (vector__ivy__expr::domain::__t (0)) -> get_verb();
    } else {
        vrb = (*this) . get_verb();
    }
    return vrb;
}
__bool ivy::expr::__t::is  (const ivy::verb::__t &vrb) const
{
    __bool res;
    res = ivy::native_bool (false);
    return res;
}
__bool ivy::expr::__t::is_typed  (const ivy::verb::__t &vrb) const
{
    __bool res;
    res = ivy::native_bool (false);
    return res;
}
ivy::ptr< ivy::expr::__t > ivy::expr::__t::get_arg  (const vector__ivy__expr::domain::__t &p) const
{
    ivy::ptr< ivy::expr::__t > res;
    {}
    return res;
}
ivy::ptr< ivy::ident::__t > ivy::expr::__t::get_name () const
{
    ivy::ptr< ivy::ident::__t > res;
    {}
    return res;
}
ivy::verb::__t ivy::expr::__t::app_verb () const {
    ivy::verb::__t res;
    {}
    return res;
}
ivy::ptr< annot::__t > ivy::expr::__t::get_ann () const {
    ivy::ptr< annot::__t > res;
    {}
    return res;
}
ivy::ptr< ivy::expr::__t > ivy::expr::__t::get_func () const
{
    ivy::ptr< ivy::expr::__t > res;
    {}
    return res;
}
vector__ivy__expr::__t ivy::expr::__t::get_args () const {
    vector__ivy__expr::__t res;
    {}
    return res;
}
ivy::ptr< ivy::expr::__t > ivy::expr::__t::prefix  (const ivy::ptr< ivy::ident::__t > &pref) const
{
    ivy::ptr< ivy::expr::__t > res;
    {}
    return res;
}
__bool ivy::expr::__t::eq  (const ivy::ptr< ivy::expr::__t > &e2) const
{
    __bool res;
    if (ivy::isa< ivy::symbol::__t > ((*this)))
    {
        if (e2 . isa< ivy::symbol::__t >()) {
            res = (*this) . get_name() == e2 -> get_name();
        }
    } else
    {
        if (ivy::isa< ivy::app::__t > ((*this)))
        {
            if ((*this) . get_func() -> eq (e2 -> get_func()))
            {
                vector__ivy__expr::__t args1;
                args1 = (*this) . get_args();
                vector__ivy__expr::__t args2;
                args2 = e2 -> get_args();
                if (args1 . end == args2 . end)
                {
                    res = ivy::native_bool (true);
                    vector__ivy__expr::domain::__t idx;
                    idx = args1 . begin();
                    while (res & idx < args1 . end)
                    {
                        if (! args1 . value (idx) -> eq (args2 . value (idx)))
                        {
                            res = ivy::native_bool (false);
                        }
                        idx = idx . next();
                    }
                }
            }
        }
    }
    return res;
}
ivy::ptr< ivy::expr::__t > ivy::symbol::make  (const ivy::ptr< ivy::ident::__t > &name,const ivy::ptr< annot::__t >
    &ann)
{
    ivy::ptr< ivy::expr::__t > res;
    {
        ivy::symbol::__t s;
        s . name = name;
        s . vrb = ivy::verb::__t (ivy::verb::none);
        s . ann = ann;
        res = s;
    }
    return res;
}
ivy::ptr< ivy::expr::__t > ivy::symbol::makestr  (const str::__t &name,const ivy::ptr< annot::__t >
    &ann)
{
    ivy::ptr< ivy::expr::__t > res;
    {
        ivy::symbol::__t s;
        s . name = ivy::strident::make (name);
        s . vrb = ivy::verb_from_name (name);
        s . ann = ann;
        res = s;
    }
    return res;
}
ivy::ptr< ivy::expr::__t > ivy::symbol::makestr1  (const str::__t &name,const ivy::ptr< ivy::ident::__t >
    &arg,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< ivy::expr::__t > res;
    {
        ivy::symbol::__t s;
        s . name = ivy::strident::make1 (name,arg);
        s . vrb = ivy::verb_from_name (name);
        s . ann = ann;
        res = s;
    }
    return res;
}
ivy::ptr< ivy::expr::__t > ivy::symbol::makenum  (const pos::__t &num,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< ivy::expr::__t > res;
    {
        ivy::symbol::__t s;
        s . name = ivy::numident::make (num);
        s . vrb = ivy::verb::__t (ivy::verb::none);
        s . ann = ann;
        res = s;
    }
    return res;
}
void ivy::symbol::__t::encode  (pretty::__t &b,const priority::__t &prio) const
{
    (*this) . ann -> encode (b);
    (*this) . name -> encode (b,priority::__t (0));
}
void ivy::symbol::parse  (pstate::__t &st,ivy::ptr< ivy::expr::__t > &res)
{
    if (st . ok & st . tok . end != pos::__t (0))
    {
        ivy::symbol::__t s;
        s . vrb = ivy::verb_from_name (st . tok);
        st . get_ann (s . ann);
        ivy::strident::__t id;
        ivy::strident::parse (st,id);
        s . name = id;
        res = s;
    } else {
        st . ok = ivy::native_bool (false);
    }
}
ivy::verb::__t ivy::symbol::__t::get_verb () const
{
    ivy::verb::__t res;
    res = (*this) . vrb;
    return res;
}
ivy::ptr< ivy::ident::__t > ivy::symbol::__t::get_name () const
{
    ivy::ptr< ivy::ident::__t > res;
    res = (*this) . name;
    return res;
}
ivy::ptr< annot::__t > ivy::symbol::__t::get_ann () const
{
    ivy::ptr< annot::__t > res;
    res = (*this) . ann;
    return res;
}
ivy::ptr< ivy::expr::__t > ivy::symbol::__t::prefix  (const ivy::ptr< ivy::ident::__t > &pref) const
{
    ivy::ptr< ivy::expr::__t > res;
    res = ivy::symbol::make ((*this) . get_name() -> prefix (pref),(*this) . get_ann());
    return res;
}
vector__ivy__expr::domain::__t vector__ivy__expr::domain::__t::next () const
{
    vector__ivy__expr::domain::__t y;
    y = (*this) + vector__ivy__expr::domain::__t (1);
    return y;
}
vector__ivy__expr::domain::__t vector__ivy__expr::domain::__t::prev () const
{
    vector__ivy__expr::domain::__t y;
    y = (*this) - vector__ivy__expr::domain::__t (1);
    return y;
}
vector__ivy__expr::domain::__t vector__ivy__expr::__t::begin () const
{
    vector__ivy__expr::domain::__t res;
    res = vector__ivy__expr::domain::__t (0);
    return res;
}
vector__ivy__expr::__t vector__ivy__expr::empty () {
    vector__ivy__expr::__t res;
    {}
    return res;
}
void vector__ivy__expr::__t::set  (const vector__ivy__expr::domain::__t &i,const ivy::ptr< ivy::expr::__t >
    &v) {
    (*this) . value (i) = v;
}
void vector__ivy__expr::__t::append  (const ivy::ptr< ivy::expr::__t > &c)
{
    (*this) . value ((*this) . end) = c;
    (*this) . end = (*this) . end . next();
}
void vector__ivy__expr::__t::extend  (const vector__ivy__expr::__t &x)
{
    vector__ivy__expr::domain::__t idx;
    idx = x . begin();
    while (idx < x . end) {
        (*this) . append (x . value (idx));
        idx = idx . next();
    }
}
void vector__ivy__expr::__t::resize  (const vector__ivy__expr::domain::__t &end)
{
    ivy::resize ((*this) . value,end);
    (*this) . end = end;
}
ivy::ptr< ivy::expr::__t > vector__ivy__expr::__t::back () const
{
    ivy::ptr< ivy::expr::__t > y;
    if ((*this) . end > vector__ivy__expr::domain::__t (0))
    {
        y = (*this) . value ((*this) . end . prev());
    }
    return y;
}
void vector__ivy__expr::__t::pop_back ()
{
    if ((*this) . end > vector__ivy__expr::domain::__t (0))
    {
        vector__ivy__expr::domain::__t size;
        size = (*this) . end . prev();
        (*this) . resize (size);
    }
}
vector__ivy__expr::__t vector__ivy__expr::__t::segment  (const vector__ivy__expr::domain::__t &beg,const
    vector__ivy__expr::domain::__t &en) const
{
    vector__ivy__expr::__t res;
    {
        vector__ivy__expr::domain::__t idx;
        idx = beg;
        while (idx < en & idx < (*this) . end)
        {
            res . append ((*this) . value (idx));
            idx = idx . next();
        }
    }
    return res;
}
void vector__ivy__expr::__t::reverse ()
{
    vector__ivy__expr::domain::__t idx;
    idx = (*this) . begin();
    vector__ivy__expr::domain::__t jdx;
    jdx = (*this) . end . prev();
    while (idx < jdx)
    {
        ivy::ptr< ivy::expr::__t > tmp;
        tmp = (*this) . value (idx);
        (*this) . value (idx) = (*this) . value (jdx);
        (*this) . value (jdx) = tmp;
        jdx = jdx . prev();
        idx = idx . next();
    }
}
ivy::ptr< ivy::expr::__t > ivy::app::make  (const ivy::ptr< ivy::expr::__t > &func,const
    vector__ivy__expr::__t &args,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< ivy::expr::__t > res;
    {
        ivy::app::__t s;
        s . func = func;
        s . args = args;
        s . ann = ann;
        res = s;
    }
    return res;
}
ivy::ptr< ivy::expr::__t > ivy::app::make1  (const ivy::ptr< ivy::expr::__t > &func,const ivy::ptr< ivy::expr::__t >
    &arg0,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< ivy::expr::__t > res;
    {
        ivy::app::__t s;
        s . func = func;
        s . args . append (arg0);
        s . ann = ann;
        res = s;
    }
    return res;
}
ivy::ptr< ivy::expr::__t > ivy::app::make2  (const ivy::ptr< ivy::expr::__t > &func,const ivy::ptr< ivy::expr::__t >
    &arg0,const ivy::ptr< ivy::expr::__t > &arg1,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< ivy::expr::__t > res;
    {
        ivy::app::__t s;
        s . func = func;
        s . args . append (arg0);
        s . args . append (arg1);
        s . ann = ann;
        res = s;
    }
    return res;
}
void ivy::app::__t::encode  (pretty::__t &b,const priority::__t &prio) const
{
    (*this) . ann -> encode (b);
    ivy::verb::__t vrb;
    vrb = (*this) . func -> get_verb();
    if (vrb != ivy::verb::__t (ivy::verb::none))
    {
        priority::__t opprio;
        opprio = ivy::verb_to_prio (vrb);
        if (opprio < prio) {
            b . nest();
            b . extend (ivy::from_str< str::__t > ("("));
        }
        if ((*this) . args . end == vector__ivy__expr::domain::__t (1))
        {
            b . extend (ivy::verb_to_str (vrb));
            b . extend (ivy::from_str< str::__t > (" "));
            (*this) . args . value (vector__ivy__expr::domain::__t (0)) -> encode (b,opprio);
        } else
        {
            (*this) . args . value (vector__ivy__expr::domain::__t (0)) -> encode (b,opprio);
            b . extend (ivy::from_str< str::__t > (" "));
            b . extend (ivy::verb_to_str (vrb));
            b . extend (ivy::from_str< str::__t > (" "));
            (*this) . args . value (vector__ivy__expr::domain::__t (1)) -> encode (b,opprio +
                    priority::__t (1));
            if (vrb == ivy::verb::__t (ivy::verb::ite))
            {
                b . extend (ivy::from_str< str::__t > (" "));
                b . extend (ivy::native_bool (false) ? ivy::from_str< str::__t > (":") :
                        ivy::from_str< str::__t > ("else"));
                b . extend (ivy::from_str< str::__t > (" "));
                (*this) . args . value (vector__ivy__expr::domain::__t (2)) -> encode (b,opprio +
                        priority::__t (1));
            }
        }
        if (opprio < prio) {
            b . extend (ivy::from_str< str::__t > (")"));
            b . unnest();
        }
    } else
    {
        b . nest();
        (*this) . func -> encode (b,priority::__t (99));
        if ((*this) . args . end == vector__ivy__expr::domain::__t (0))
        {
            b . extend (ivy::from_str< str::__t > ("()"));
        } else {
            ivy::expr::tup::encode ((*this) . args,b,priority::__t (0));
        }
        b . unnest();
    }
}
__bool ivy::app::__t::is  (const ivy::verb::__t &vrb) const
{
    __bool res;
    res = (*this) . func -> get_verb() == vrb;
    return res;
}
__bool ivy::app::__t::is_typed  (const ivy::verb::__t &vrb) const
{
    __bool res;
    res = (*this) . is (vrb) | (*this) . func -> is (ivy::verb::__t (ivy::verb::colon)) &
        (*this) . func -> get_arg (vector__ivy__expr::domain::__t (0)) -> get_verb() == vrb;
    return res;
}
ivy::verb::__t ivy::app::__t::app_verb () const
{
    ivy::verb::__t res;
    res = (*this) . func -> get_verb();
    return res;
}
ivy::ptr< ivy::expr::__t > ivy::app::__t::get_func () const
{
    ivy::ptr< ivy::expr::__t > res;
    res = (*this) . func;
    return res;
}
vector__ivy__expr::__t ivy::app::__t::get_args () const
{
    vector__ivy__expr::__t res;
    res = (*this) . args;
    return res;
}
ivy::ptr< ivy::expr::__t > ivy::app::__t::get_arg  (const vector__ivy__expr::domain::__t &p) const
{
    ivy::ptr< ivy::expr::__t > res;
    res = (*this) . args . value (p);
    return res;
}
ivy::ptr< annot::__t > ivy::app::__t::get_ann () const
{
    ivy::ptr< annot::__t > res;
    res = (*this) . ann;
    return res;
}
ivy::ptr< ivy::expr::__t > ivy::variable::make  (const pos::__t &idx)
{
    ivy::ptr< ivy::expr::__t > res;
    {
        ivy::variable::__t s;
        s . idx = idx;
        res = s;
    }
    return res;
}
ivy::ptr< ivy::expr::__t > ivy::pi::make  (const vector__ivy__expr::__t &vars,const ivy::ptr< ivy::expr::__t >
    &body,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< ivy::expr::__t > res;
    {
        ivy::pi::__t s;
        s . vars = vars;
        s . ann = ann;
        res = s;
    }
    return res;
}
void ivy::pi::__t::encode  (pretty::__t &b,const priority::__t &prio) const
{
    (*this) . ann -> encode (b);
    b . nest();
    b . extend (ivy::from_str< str::__t > ("pi"));
    b . extend (ivy::from_str< str::__t > (" "));
    ivy::expr::tup::encode ((*this) . vars,b,priority::__t (0));
    b . extend (ivy::from_str< str::__t > ("."));
    b . extend (ivy::from_str< str::__t > (" "));
    (*this) . body -> encode (b,priority::__t (0));
    b . extend (ivy::from_str< str::__t > (";"));
    b . unnest();
}
ivy::ptr< ivy::expr::__t > ivy::iff::make  (const ivy::ptr< ivy::expr::__t > &lhs,const ivy::ptr< ivy::expr::__t >
    &rhs,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< ivy::expr::__t > res;
    {
        ivy::app::__t s;
        s . func = ivy::symbol::makestr (ivy::from_str< str::__t > ("<->"),ann);
        s . args . append (lhs);
        s . args . append (rhs);
        s . ann = ann;
        res = s;
    }
    return res;
}
ivy::ptr< ivy::expr::__t > ivy::iff::fold_left  (const vector__ivy__expr::__t &args,const ivy::ptr< annot::__t >
    &ann)
{
    ivy::ptr< ivy::expr::__t > res;
    if (args . end > vector__ivy__expr::domain::__t (0))
    {
        res = args . value (vector__ivy__expr::domain::__t (0));
        vector__ivy__expr::domain::__t idx;
        idx = args . begin() . next();
        while (idx < args . end)
        {
            res = ivy::iff::make (res,args . value (idx),ann);
            idx = idx . next();
        }
    } else {
        res = ivy::empty::make (ann);
    }
    return res;
}
vector__ivy__expr::__t ivy::iff::unfold_left  (const ivy::ptr< ivy::expr::__t > &s)
{
    vector__ivy__expr::__t args;
    {
        ivy::ptr< ivy::expr::__t > e;
        e = s;
        __bool b;
        b = e -> is_typed (ivy::verb::__t (ivy::verb::iff));
        
        // workaround
        
        while (b)
        {
            args . append (e -> get_arg (vector__ivy__expr::domain::__t (1)));
            e = e -> get_arg (vector__ivy__expr::domain::__t (0));
            b = e -> is_typed (ivy::verb::__t (ivy::verb::iff));
        }
        args . append (e);
        args . reverse();
    }
    return args;
}
ivy::ptr< ivy::expr::__t > ivy::__or::make  (const ivy::ptr< ivy::expr::__t > &lhs,const ivy::ptr< ivy::expr::__t >
    &rhs,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< ivy::expr::__t > res;
    {
        ivy::app::__t s;
        s . func = ivy::symbol::makestr (ivy::from_str< str::__t > ("|"),ann);
        s . args . append (lhs);
        s . args . append (rhs);
        s . ann = ann;
        res = s;
    }
    return res;
}
ivy::ptr< ivy::expr::__t > ivy::__or::fold_left  (const vector__ivy__expr::__t &args,const ivy::ptr< annot::__t >
    &ann)
{
    ivy::ptr< ivy::expr::__t > res;
    if (args . end > vector__ivy__expr::domain::__t (0))
    {
        res = args . value (vector__ivy__expr::domain::__t (0));
        vector__ivy__expr::domain::__t idx;
        idx = args . begin() . next();
        while (idx < args . end)
        {
            res = ivy::__or::make (res,args . value (idx),ann);
            idx = idx . next();
        }
    } else {
        res = ivy::empty::make (ann);
    }
    return res;
}
vector__ivy__expr::__t ivy::__or::unfold_left  (const ivy::ptr< ivy::expr::__t > &s)
{
    vector__ivy__expr::__t args;
    {
        ivy::ptr< ivy::expr::__t > e;
        e = s;
        __bool b;
        b = e -> is_typed (ivy::verb::__t (ivy::verb::__or));
        while (b)
        {
            args . append (e -> get_arg (vector__ivy__expr::domain::__t (1)));
            e = e -> get_arg (vector__ivy__expr::domain::__t (0));
            b = e -> is_typed (ivy::verb::__t (ivy::verb::__or));
        }
        args . append (e);
        args . reverse();
    }
    return args;
}
ivy::ptr< ivy::expr::__t > ivy::__and::make  (const ivy::ptr< ivy::expr::__t > &lhs,const ivy::ptr< ivy::expr::__t >
    &rhs,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< ivy::expr::__t > res;
    {
        ivy::app::__t s;
        s . func = ivy::symbol::makestr (ivy::from_str< str::__t > ("&"),ann);
        s . args . append (lhs);
        s . args . append (rhs);
        s . ann = ann;
        res = s;
    }
    return res;
}
ivy::ptr< ivy::expr::__t > ivy::__and::fold_left  (const vector__ivy__expr::__t &args,const ivy::ptr< annot::__t >
    &ann)
{
    ivy::ptr< ivy::expr::__t > res;
    if (args . end > vector__ivy__expr::domain::__t (0))
    {
        res = args . value (vector__ivy__expr::domain::__t (0));
        vector__ivy__expr::domain::__t idx;
        idx = args . begin() . next();
        while (idx < args . end)
        {
            res = ivy::__and::make (res,args . value (idx),ann);
            idx = idx . next();
        }
    } else {
        res = ivy::empty::make (ann);
    }
    return res;
}
vector__ivy__expr::__t ivy::__and::unfold_left  (const ivy::ptr< ivy::expr::__t > &s)
{
    vector__ivy__expr::__t args;
    {
        ivy::ptr< ivy::expr::__t > e;
        e = s;
        __bool b;
        b = e -> is_typed (ivy::verb::__t (ivy::verb::__and));
        while (b)
        {
            args . append (e -> get_arg (vector__ivy__expr::domain::__t (1)));
            e = e -> get_arg (vector__ivy__expr::domain::__t (0));
            b = e -> is_typed (ivy::verb::__t (ivy::verb::__and));
        }
        args . append (e);
        args . reverse();
    }
    return args;
}
ivy::ptr< ivy::expr::__t > ivy::lt::make  (const ivy::ptr< ivy::expr::__t > &lhs,const ivy::ptr< ivy::expr::__t >
    &rhs,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< ivy::expr::__t > res;
    {
        ivy::app::__t s;
        s . func = ivy::symbol::makestr (ivy::from_str< str::__t > ("<"),ann);
        s . args . append (lhs);
        s . args . append (rhs);
        s . ann = ann;
        res = s;
    }
    return res;
}
ivy::ptr< ivy::expr::__t > ivy::lt::fold_left  (const vector__ivy__expr::__t &args,const ivy::ptr< annot::__t >
    &ann)
{
    ivy::ptr< ivy::expr::__t > res;
    if (args . end > vector__ivy__expr::domain::__t (0))
    {
        res = args . value (vector__ivy__expr::domain::__t (0));
        vector__ivy__expr::domain::__t idx;
        idx = args . begin() . next();
        while (idx < args . end)
        {
            res = ivy::lt::make (res,args . value (idx),ann);
            idx = idx . next();
        }
    } else {
        res = ivy::empty::make (ann);
    }
    return res;
}
vector__ivy__expr::__t ivy::lt::unfold_left  (const ivy::ptr< ivy::expr::__t > &s)
{
    vector__ivy__expr::__t args;
    {
        ivy::ptr< ivy::expr::__t > e;
        e = s;
        __bool b;
        b = e -> is_typed (ivy::verb::__t (ivy::verb::lt));
        while (b)
        {
            args . append (e -> get_arg (vector__ivy__expr::domain::__t (1)));
            e = e -> get_arg (vector__ivy__expr::domain::__t (0));
            b = e -> is_typed (ivy::verb::__t (ivy::verb::lt));
        }
        args . append (e);
        args . reverse();
    }
    return args;
}
ivy::ptr< ivy::expr::__t > ivy::leq::make  (const ivy::ptr< ivy::expr::__t > &lhs,const ivy::ptr< ivy::expr::__t >
    &rhs,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< ivy::expr::__t > res;
    {
        ivy::app::__t s;
        s . func = ivy::symbol::makestr (ivy::from_str< str::__t > ("<="),ann);
        s . args . append (lhs);
        s . args . append (rhs);
        s . ann = ann;
        res = s;
    }
    return res;
}
ivy::ptr< ivy::expr::__t > ivy::leq::fold_left  (const vector__ivy__expr::__t &args,const ivy::ptr< annot::__t >
    &ann)
{
    ivy::ptr< ivy::expr::__t > res;
    if (args . end > vector__ivy__expr::domain::__t (0))
    {
        res = args . value (vector__ivy__expr::domain::__t (0));
        vector__ivy__expr::domain::__t idx;
        idx = args . begin() . next();
        while (idx < args . end)
        {
            res = ivy::leq::make (res,args . value (idx),ann);
            idx = idx . next();
        }
    } else {
        res = ivy::empty::make (ann);
    }
    return res;
}
vector__ivy__expr::__t ivy::leq::unfold_left  (const ivy::ptr< ivy::expr::__t > &s)
{
    vector__ivy__expr::__t args;
    {
        ivy::ptr< ivy::expr::__t > e;
        e = s;
        __bool b;
        b = e -> is_typed (ivy::verb::__t (ivy::verb::leq));
        while (b)
        {
            args . append (e -> get_arg (vector__ivy__expr::domain::__t (1)));
            e = e -> get_arg (vector__ivy__expr::domain::__t (0));
            b = e -> is_typed (ivy::verb::__t (ivy::verb::leq));
        }
        args . append (e);
        args . reverse();
    }
    return args;
}
ivy::ptr< ivy::expr::__t > ivy::gt::make  (const ivy::ptr< ivy::expr::__t > &lhs,const ivy::ptr< ivy::expr::__t >
    &rhs,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< ivy::expr::__t > res;
    {
        ivy::app::__t s;
        s . func = ivy::symbol::makestr (ivy::from_str< str::__t > (">"),ann);
        s . args . append (lhs);
        s . args . append (rhs);
        s . ann = ann;
        res = s;
    }
    return res;
}
ivy::ptr< ivy::expr::__t > ivy::gt::fold_left  (const vector__ivy__expr::__t &args,const ivy::ptr< annot::__t >
    &ann)
{
    ivy::ptr< ivy::expr::__t > res;
    if (args . end > vector__ivy__expr::domain::__t (0))
    {
        res = args . value (vector__ivy__expr::domain::__t (0));
        vector__ivy__expr::domain::__t idx;
        idx = args . begin() . next();
        while (idx < args . end)
        {
            res = ivy::gt::make (res,args . value (idx),ann);
            idx = idx . next();
        }
    } else {
        res = ivy::empty::make (ann);
    }
    return res;
}
vector__ivy__expr::__t ivy::gt::unfold_left  (const ivy::ptr< ivy::expr::__t > &s)
{
    vector__ivy__expr::__t args;
    {
        ivy::ptr< ivy::expr::__t > e;
        e = s;
        __bool b;
        b = e -> is_typed (ivy::verb::__t (ivy::verb::gt));
        while (b)
        {
            args . append (e -> get_arg (vector__ivy__expr::domain::__t (1)));
            e = e -> get_arg (vector__ivy__expr::domain::__t (0));
            b = e -> is_typed (ivy::verb::__t (ivy::verb::gt));
        }
        args . append (e);
        args . reverse();
    }
    return args;
}
ivy::ptr< ivy::expr::__t > ivy::geq::make  (const ivy::ptr< ivy::expr::__t > &lhs,const ivy::ptr< ivy::expr::__t >
    &rhs,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< ivy::expr::__t > res;
    {
        ivy::app::__t s;
        s . func = ivy::symbol::makestr (ivy::from_str< str::__t > (">="),ann);
        s . args . append (lhs);
        s . args . append (rhs);
        s . ann = ann;
        res = s;
    }
    return res;
}
ivy::ptr< ivy::expr::__t > ivy::geq::fold_left  (const vector__ivy__expr::__t &args,const ivy::ptr< annot::__t >
    &ann)
{
    ivy::ptr< ivy::expr::__t > res;
    if (args . end > vector__ivy__expr::domain::__t (0))
    {
        res = args . value (vector__ivy__expr::domain::__t (0));
        vector__ivy__expr::domain::__t idx;
        idx = args . begin() . next();
        while (idx < args . end)
        {
            res = ivy::geq::make (res,args . value (idx),ann);
            idx = idx . next();
        }
    } else {
        res = ivy::empty::make (ann);
    }
    return res;
}
vector__ivy__expr::__t ivy::geq::unfold_left  (const ivy::ptr< ivy::expr::__t > &s)
{
    vector__ivy__expr::__t args;
    {
        ivy::ptr< ivy::expr::__t > e;
        e = s;
        __bool b;
        b = e -> is_typed (ivy::verb::__t (ivy::verb::geq));
        while (b)
        {
            args . append (e -> get_arg (vector__ivy__expr::domain::__t (1)));
            e = e -> get_arg (vector__ivy__expr::domain::__t (0));
            b = e -> is_typed (ivy::verb::__t (ivy::verb::geq));
        }
        args . append (e);
        args . reverse();
    }
    return args;
}
ivy::ptr< ivy::expr::__t > ivy::plus::make  (const ivy::ptr< ivy::expr::__t > &lhs,const ivy::ptr< ivy::expr::__t >
    &rhs,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< ivy::expr::__t > res;
    {
        ivy::app::__t s;
        s . func = ivy::symbol::makestr (ivy::from_str< str::__t > ("+"),ann);
        s . args . append (lhs);
        s . args . append (rhs);
        s . ann = ann;
        res = s;
    }
    return res;
}
ivy::ptr< ivy::expr::__t > ivy::plus::fold_left  (const vector__ivy__expr::__t &args,const ivy::ptr< annot::__t >
    &ann)
{
    ivy::ptr< ivy::expr::__t > res;
    if (args . end > vector__ivy__expr::domain::__t (0))
    {
        res = args . value (vector__ivy__expr::domain::__t (0));
        vector__ivy__expr::domain::__t idx;
        idx = args . begin() . next();
        while (idx < args . end)
        {
            res = ivy::plus::make (res,args . value (idx),ann);
            idx = idx . next();
        }
    } else {
        res = ivy::empty::make (ann);
    }
    return res;
}
vector__ivy__expr::__t ivy::plus::unfold_left  (const ivy::ptr< ivy::expr::__t > &s)
{
    vector__ivy__expr::__t args;
    {
        ivy::ptr< ivy::expr::__t > e;
        e = s;
        __bool b;
        b = e -> is_typed (ivy::verb::__t (ivy::verb::plus));
        while (b)
        {
            args . append (e -> get_arg (vector__ivy__expr::domain::__t (1)));
            e = e -> get_arg (vector__ivy__expr::domain::__t (0));
            b = e -> is_typed (ivy::verb::__t (ivy::verb::plus));
        }
        args . append (e);
        args . reverse();
    }
    return args;
}
ivy::ptr< ivy::expr::__t > ivy::minus::make  (const ivy::ptr< ivy::expr::__t > &lhs,const ivy::ptr< ivy::expr::__t >
    &rhs,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< ivy::expr::__t > res;
    {
        ivy::app::__t s;
        s . func = ivy::symbol::makestr (ivy::from_str< str::__t > ("-"),ann);
        s . args . append (lhs);
        s . args . append (rhs);
        s . ann = ann;
        res = s;
    }
    return res;
}
ivy::ptr< ivy::expr::__t > ivy::minus::fold_left  (const vector__ivy__expr::__t &args,const ivy::ptr< annot::__t >
    &ann)
{
    ivy::ptr< ivy::expr::__t > res;
    if (args . end > vector__ivy__expr::domain::__t (0))
    {
        res = args . value (vector__ivy__expr::domain::__t (0));
        vector__ivy__expr::domain::__t idx;
        idx = args . begin() . next();
        while (idx < args . end)
        {
            res = ivy::minus::make (res,args . value (idx),ann);
            idx = idx . next();
        }
    } else {
        res = ivy::empty::make (ann);
    }
    return res;
}
vector__ivy__expr::__t ivy::minus::unfold_left  (const ivy::ptr< ivy::expr::__t > &s)
{
    vector__ivy__expr::__t args;
    {
        ivy::ptr< ivy::expr::__t > e;
        e = s;
        __bool b;
        b = e -> is_typed (ivy::verb::__t (ivy::verb::minus));
        while (b)
        {
            args . append (e -> get_arg (vector__ivy__expr::domain::__t (1)));
            e = e -> get_arg (vector__ivy__expr::domain::__t (0));
            b = e -> is_typed (ivy::verb::__t (ivy::verb::minus));
        }
        args . append (e);
        args . reverse();
    }
    return args;
}
ivy::ptr< ivy::expr::__t > ivy::times::make  (const ivy::ptr< ivy::expr::__t > &lhs,const ivy::ptr< ivy::expr::__t >
    &rhs,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< ivy::expr::__t > res;
    {
        ivy::app::__t s;
        s . func = ivy::symbol::makestr (ivy::from_str< str::__t > ("*"),ann);
        s . args . append (lhs);
        s . args . append (rhs);
        s . ann = ann;
        res = s;
    }
    return res;
}
ivy::ptr< ivy::expr::__t > ivy::times::fold_left  (const vector__ivy__expr::__t &args,const ivy::ptr< annot::__t >
    &ann)
{
    ivy::ptr< ivy::expr::__t > res;
    if (args . end > vector__ivy__expr::domain::__t (0))
    {
        res = args . value (vector__ivy__expr::domain::__t (0));
        vector__ivy__expr::domain::__t idx;
        idx = args . begin() . next();
        while (idx < args . end)
        {
            res = ivy::times::make (res,args . value (idx),ann);
            idx = idx . next();
        }
    } else {
        res = ivy::empty::make (ann);
    }
    return res;
}
vector__ivy__expr::__t ivy::times::unfold_left  (const ivy::ptr< ivy::expr::__t > &s)
{
    vector__ivy__expr::__t args;
    {
        ivy::ptr< ivy::expr::__t > e;
        e = s;
        __bool b;
        b = e -> is_typed (ivy::verb::__t (ivy::verb::times));
        while (b)
        {
            args . append (e -> get_arg (vector__ivy__expr::domain::__t (1)));
            e = e -> get_arg (vector__ivy__expr::domain::__t (0));
            b = e -> is_typed (ivy::verb::__t (ivy::verb::times));
        }
        args . append (e);
        args . reverse();
    }
    return args;
}
ivy::ptr< ivy::expr::__t > ivy::div::make  (const ivy::ptr< ivy::expr::__t > &lhs,const ivy::ptr< ivy::expr::__t >
    &rhs,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< ivy::expr::__t > res;
    {
        ivy::app::__t s;
        s . func = ivy::symbol::makestr (ivy::from_str< str::__t > ("/"),ann);
        s . args . append (lhs);
        s . args . append (rhs);
        s . ann = ann;
        res = s;
    }
    return res;
}
ivy::ptr< ivy::expr::__t > ivy::div::fold_left  (const vector__ivy__expr::__t &args,const ivy::ptr< annot::__t >
    &ann)
{
    ivy::ptr< ivy::expr::__t > res;
    if (args . end > vector__ivy__expr::domain::__t (0))
    {
        res = args . value (vector__ivy__expr::domain::__t (0));
        vector__ivy__expr::domain::__t idx;
        idx = args . begin() . next();
        while (idx < args . end)
        {
            res = ivy::div::make (res,args . value (idx),ann);
            idx = idx . next();
        }
    } else {
        res = ivy::empty::make (ann);
    }
    return res;
}
vector__ivy__expr::__t ivy::div::unfold_left  (const ivy::ptr< ivy::expr::__t > &s)
{
    vector__ivy__expr::__t args;
    {
        ivy::ptr< ivy::expr::__t > e;
        e = s;
        __bool b;
        b = e -> is_typed (ivy::verb::__t (ivy::verb::div));
        while (b)
        {
            args . append (e -> get_arg (vector__ivy__expr::domain::__t (1)));
            e = e -> get_arg (vector__ivy__expr::domain::__t (0));
            b = e -> is_typed (ivy::verb::__t (ivy::verb::div));
        }
        args . append (e);
        args . reverse();
    }
    return args;
}
ivy::ptr< ivy::expr::__t > ivy::empty::make  (const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< ivy::expr::__t > res;
    res = ivy::symbol::makestr (ivy::from_str< str::__t > ("()"),ann);
    return res;
}
ivy::ptr< ivy::expr::__t > ivy::boolv::make  (const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< ivy::expr::__t > res;
    res = ivy::symbol::makestr (ivy::from_str< str::__t > ("bool"),ann);
    return res;
}
ivy::ptr< ivy::expr::__t > ivy::truev::make  (const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< ivy::expr::__t > res;
    res = ivy::symbol::makestr (ivy::from_str< str::__t > ("true"),ann);
    return res;
}
ivy::ptr< ivy::expr::__t > ivy::falsev::make  (const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< ivy::expr::__t > res;
    res = ivy::symbol::makestr (ivy::from_str< str::__t > ("false"),ann);
    return res;
}
ivy::ptr< ivy::expr::__t > ivy::comma::make  (const ivy::ptr< ivy::expr::__t > &lhs,const ivy::ptr< ivy::expr::__t >
    &rhs,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< ivy::expr::__t > res;
    {
        ivy::app::__t s;
        s . func = ivy::symbol::makestr (ivy::from_str< str::__t > (","),ann);
        s . args . append (lhs);
        s . args . append (rhs);
        s . ann = ann;
        res = s;
    }
    return res;
}
ivy::ptr< ivy::expr::__t > ivy::comma::fold_left  (const vector__ivy__expr::__t &args,const ivy::ptr< annot::__t >
    &ann)
{
    ivy::ptr< ivy::expr::__t > res;
    if (args . end > vector__ivy__expr::domain::__t (0))
    {
        res = args . value (vector__ivy__expr::domain::__t (0));
        vector__ivy__expr::domain::__t idx;
        idx = args . begin() . next();
        while (idx < args . end)
        {
            res = ivy::comma::make (res,args . value (idx),ann);
            idx = idx . next();
        }
    } else {
        res = ivy::empty::make (ann);
    }
    return res;
}
vector__ivy__expr::__t ivy::comma::unfold_left  (const ivy::ptr< ivy::expr::__t > &s)
{
    vector__ivy__expr::__t args;
    {
        ivy::ptr< ivy::expr::__t > e;
        e = s;
        __bool b;
        b = e -> is_typed (ivy::verb::__t (ivy::verb::comma));
        while (b)
        {
            args . append (e -> get_arg (vector__ivy__expr::domain::__t (1)));
            e = e -> get_arg (vector__ivy__expr::domain::__t (0));
            b = e -> is_typed (ivy::verb::__t (ivy::verb::comma));
        }
        args . append (e);
        args . reverse();
    }
    return args;
}
ivy::ptr< ivy::expr::__t > ivy::dot::make  (const ivy::ptr< ivy::expr::__t > &lhs,const ivy::ptr< ivy::expr::__t >
    &rhs,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< ivy::expr::__t > res;
    {
        ivy::app::__t s;
        s . func = ivy::symbol::makestr (ivy::from_str< str::__t > ("."),ann);
        s . args . append (lhs);
        s . args . append (rhs);
        s . ann = ann;
        res = s;
    }
    return res;
}
ivy::ptr< ivy::expr::__t > ivy::dot::fold_left  (const vector__ivy__expr::__t &args,const ivy::ptr< annot::__t >
    &ann)
{
    ivy::ptr< ivy::expr::__t > res;
    if (args . end > vector__ivy__expr::domain::__t (0))
    {
        res = args . value (vector__ivy__expr::domain::__t (0));
        vector__ivy__expr::domain::__t idx;
        idx = args . begin() . next();
        while (idx < args . end)
        {
            res = ivy::dot::make (res,args . value (idx),ann);
            idx = idx . next();
        }
    } else {
        res = ivy::empty::make (ann);
    }
    return res;
}
vector__ivy__expr::__t ivy::dot::unfold_left  (const ivy::ptr< ivy::expr::__t > &s)
{
    vector__ivy__expr::__t args;
    {
        ivy::ptr< ivy::expr::__t > e;
        e = s;
        __bool b;
        b = e -> is_typed (ivy::verb::__t (ivy::verb::dot));
        while (b)
        {
            args . append (e -> get_arg (vector__ivy__expr::domain::__t (1)));
            e = e -> get_arg (vector__ivy__expr::domain::__t (0));
            b = e -> is_typed (ivy::verb::__t (ivy::verb::dot));
        }
        args . append (e);
        args . reverse();
    }
    return args;
}
void ivy::expr::parse  (pstate::__t &st,const priority::__t &prio,ivy::ptr< ivy::expr::__t > &res)
{
    if (st . tok == ivy::from_str< str::__t > ("("))
    {
        st . consume();
        ivy::expr::parse (st,priority::__t (0),res);
        if (st . ok & st . tok == ivy::from_str< str::__t > (")")) {
            st . consume();
        } else {
            st . ok = ivy::native_bool (false);
        }
    } else
    {
        ivy::verb::__t vrb;
        vrb = ivy::str_to_verb (st . tok);
        if (vrb != ivy::verb::__t (ivy::verb::none) & ivy::verb_to_arity (vrb) == pos::__t (1))
        {
            ivy::app::__t s;
            s . func = ivy::symbol::makestr (st . tok,s . ann);
            st . consume();
            ivy::ptr< ivy::expr::__t > arg;
            ivy::expr::parse (st,ivy::verb_to_prio (vrb),arg);
            s . args . append (arg);
            res = s;
        } else {
            ivy::symbol::parse (st,res);
        }
    }
    ivy::verb::__t vrb;
    vrb = ivy::str_to_verb (st . tok);
    while (st . ok & vrb != ivy::verb::__t (ivy::verb::none) & prio < ivy::verb_to_prio (vrb))
    {
        ivy::app::__t s;
        st . get_ann (s . ann);
        if (vrb == ivy::verb::__t (ivy::verb::app))
        {
            s . func = res;
            ivy::expr::tup::parse (st,priority::__t (1),s . args);
        } else
        {
            s . func = ivy::symbol::makestr (st . tok,s . ann);
            st . consume();
            s . args . append (res);
            ivy::ptr< ivy::expr::__t > arg;
            ivy::expr::parse (st,ivy::verb_to_prio (vrb),arg);
            s . args . append (arg);
            if (st . ok & vrb == ivy::verb::__t (ivy::verb::ite))
            {
                if (st . tok ==
                (ivy::native_bool (false) ? ivy::from_str< str::__t > (":") :
                    ivy::from_str< str::__t > ("else")))
                {
                    st . consume();
                    ivy::expr::parse (st,ivy::verb_to_prio (vrb),arg);
                    s . args . append (arg);
                } else {
                    st . ok = ivy::native_bool (false);
                }
            }
        }
        res = s;
        vrb = ivy::str_to_verb (st . tok);
    }
}
void ivy::expr::tup::encode  (const vector__ivy__expr::__t &s,pretty::__t &b,const priority::__t &prio)
{
    if (s . end > vector__ivy__expr::domain::__t (0))
    {
        b . extend (ivy::from_str< str::__t > (" "));
        b . extend (ivy::from_str< str::__t > ("("));
        s . value (vector__ivy__expr::domain::__t (0)) -> encode (b,priority::__t (0));
        vector__ivy__expr::domain::__t idx;
        idx = s . begin() . next();
        while (idx < s . end)
        {
            b . extend (ivy::from_str< str::__t > (","));
            s . value (idx) -> encode (b,priority::__t (0));
            idx = idx . next();
        }
        b . extend (ivy::from_str< str::__t > (")"));
    }
}
void ivy::expr::tup::parse  (pstate::__t &st,const priority::__t &prio,vector__ivy__expr::__t &res)
{
    if (st . tok == ivy::from_str< str::__t > ("("))
    {
        st . consume();
        ivy::ptr< ivy::expr::__t > s;
        ivy::expr::parse (st,prio,s);
        res . append (s);
        while (st . ok & st . tok == ivy::from_str< str::__t > (","))
        {
            st . consume();
            ivy::expr::parse (st,prio,s);
            res . append (s);
        }
        if (st . ok & st . tok == ivy::from_str< str::__t > (")")) {
            st . consume();
        } else {
            st . ok = ivy::native_bool (false);
        }
    } else {
        st . ok = ivy::native_bool (false);
    }
}
void ivy::stmt::__t::encode  (pretty::__t &b,const priority::__t &prio) const {}
str::__t ivy::stmt::__t::enc () const
{
    str::__t s;
    {
        pretty::__t p;
        p = pretty::make (pos::__t (100),pos::__t (4));
        p . cppstyle = ivy::native_bool (false);
        (*this) . encode (p,priority::__t (0));
        p . flush();
        s = p . output;
    }
    return s;
}
ivy::ptr< ivy::stmt::__t > ivy::stmt::dec  (const str::__t &s)
{
    ivy::ptr< ivy::stmt::__t > e;
    {
        pstate::__t st;
        st = pstate::make (s);
        ivy::stmt::parse (st,priority::__t (0),e);
        if (! st . ok | st . tok . end != pos::__t (0)) {
            parse_error (st . ann . line,st . tok);
        }
    }
    return e;
}
str::__t ivy::stmt::encdec  (const str::__t &s)
{
    str::__t res;
    {
        ivy::ptr< ivy::stmt::__t > e;
        e = ivy::stmt::dec (s);
        res = e -> enc();
    }
    return res;
}
ivy::ptr< ivy::expr::__t > ivy::stmt::__t::get_expr () const
{
    ivy::ptr< ivy::expr::__t > res;
    {}
    return res;
}
ivy::ptr< ivy::expr::__t > ivy::stmt::__t::get_lhs () const
{
    ivy::ptr< ivy::expr::__t > res;
    {}
    return res;
}
ivy::ptr< ivy::expr::__t > ivy::stmt::__t::get_rhs () const
{
    ivy::ptr< ivy::expr::__t > res;
    {}
    return res;
}
ivy::ptr< annot::__t > ivy::stmt::__t::get_ann () const {
    ivy::ptr< annot::__t > res;
    {}
    return res;
}
ivy::ptr< ivy::stmt::__t > ivy::asgn::make  (const ivy::ptr< ivy::expr::__t > &x,const ivy::ptr< ivy::expr::__t >
    &y,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< ivy::stmt::__t > res;
    {
        ivy::asgn::__t s;
        s . lhs = x;
        s . rhs = y;
        s . ann = ann;
        res = s;
    }
    return res;
}
void ivy::asgn::__t::encode  (pretty::__t &b,const priority::__t &prio) const
{
    (*this) . ann -> encode (b);
    if (priority::__t (1) < prio)
    {
        b . nest();
        b . extend (ivy::from_str< str::__t > ("{"));
        b . newline();
    }
    (*this) . encode_int (b,prio);
    if (priority::__t (1) < prio)
    {
        b . unnest();
        b . newline();
        b . extend (ivy::from_str< str::__t > ("}"));
    }
}
void ivy::asgn::__t::encode_int  (pretty::__t &b,const priority::__t &prio) const
{
    b . nest();
    if ((*this) . lhs -> get_verb() != ivy::verb::__t (ivy::verb::empty))
    {
        (*this) . lhs -> encode (b,priority::__t (0));
        b . extend (ivy::from_str< str::__t > (" "));
        b . extend (ivy::from_str< str::__t > (":="));
        b . extend (ivy::from_str< str::__t > (" "));
    }
    (*this) . rhs -> encode (b,priority::__t (0));
    b . extend (ivy::from_str< str::__t > (";"));
    b . unnest();
}
ivy::ptr< ivy::expr::__t > ivy::asgn::__t::get_lhs () const
{
    ivy::ptr< ivy::expr::__t > res;
    res = (*this) . lhs;
    return res;
}
ivy::ptr< ivy::expr::__t > ivy::asgn::__t::get_rhs () const
{
    ivy::ptr< ivy::expr::__t > res;
    res = (*this) . rhs;
    return res;
}
ivy::ptr< annot::__t > ivy::asgn::__t::get_ann () const
{
    ivy::ptr< annot::__t > res;
    res = (*this) . ann;
    return res;
}
ivy::ptr< ivy::stmt::__t > ivy::sequence::make  (const ivy::ptr< ivy::stmt::__t > &x,const ivy::ptr< ivy::stmt::__t >
    &y,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< ivy::stmt::__t > res;
    {
        ivy::sequence::__t s;
        s . lhs = x;
        s . rhs = y;
        s . ann = ann;
        res = s;
    }
    return res;
}
void ivy::sequence::__t::encode  (pretty::__t &b,const priority::__t &prio) const
{
    (*this) . ann -> encode (b);
    if (priority::__t (0) < prio)
    {
        b . nest();
        b . extend (ivy::from_str< str::__t > ("{"));
        b . newline();
    }
    (*this) . encode_int (b,prio);
    if (priority::__t (0) < prio)
    {
        b . unnest();
        b . newline();
        b . extend (ivy::from_str< str::__t > ("}"));
    }
}
void ivy::sequence::__t::encode_int  (pretty::__t &b,const priority::__t &prio) const
{
    (*this) . lhs -> encode (b,priority::__t (1));
    if (! (*this) . rhs . isa< ivy::skipst::__t >())
    {
        b . newline();
        (*this) . rhs -> encode (b,priority::__t (0));
    }
}
vector__ivy__stmt::domain::__t vector__ivy__stmt::domain::__t::next () const
{
    vector__ivy__stmt::domain::__t y;
    y = (*this) + vector__ivy__stmt::domain::__t (1);
    return y;
}
vector__ivy__stmt::domain::__t vector__ivy__stmt::domain::__t::prev () const
{
    vector__ivy__stmt::domain::__t y;
    y = (*this) - vector__ivy__stmt::domain::__t (1);
    return y;
}
vector__ivy__stmt::domain::__t vector__ivy__stmt::__t::begin () const
{
    vector__ivy__stmt::domain::__t res;
    res = vector__ivy__stmt::domain::__t (0);
    return res;
}
vector__ivy__stmt::__t vector__ivy__stmt::empty () {
    vector__ivy__stmt::__t res;
    {}
    return res;
}
void vector__ivy__stmt::__t::set  (const vector__ivy__stmt::domain::__t &i,const ivy::ptr< ivy::stmt::__t >
    &v) {
    (*this) . value (i) = v;
}
void vector__ivy__stmt::__t::append  (const ivy::ptr< ivy::stmt::__t > &c)
{
    (*this) . value ((*this) . end) = c;
    (*this) . end = (*this) . end . next();
}
void vector__ivy__stmt::__t::extend  (const vector__ivy__stmt::__t &x)
{
    vector__ivy__stmt::domain::__t idx;
    idx = x . begin();
    while (idx < x . end) {
        (*this) . append (x . value (idx));
        idx = idx . next();
    }
}
void vector__ivy__stmt::__t::resize  (const vector__ivy__stmt::domain::__t &end)
{
    ivy::resize ((*this) . value,end);
    (*this) . end = end;
}
ivy::ptr< ivy::stmt::__t > vector__ivy__stmt::__t::back () const
{
    ivy::ptr< ivy::stmt::__t > y;
    if ((*this) . end > vector__ivy__stmt::domain::__t (0))
    {
        y = (*this) . value ((*this) . end . prev());
    }
    return y;
}
void vector__ivy__stmt::__t::pop_back ()
{
    if ((*this) . end > vector__ivy__stmt::domain::__t (0))
    {
        vector__ivy__stmt::domain::__t size;
        size = (*this) . end . prev();
        (*this) . resize (size);
    }
}
vector__ivy__stmt::__t vector__ivy__stmt::__t::segment  (const vector__ivy__stmt::domain::__t &beg,const
    vector__ivy__stmt::domain::__t &en) const
{
    vector__ivy__stmt::__t res;
    {
        vector__ivy__stmt::domain::__t idx;
        idx = beg;
        while (idx < en & idx < (*this) . end)
        {
            res . append ((*this) . value (idx));
            idx = idx . next();
        }
    }
    return res;
}
void vector__ivy__stmt::__t::reverse ()
{
    vector__ivy__stmt::domain::__t idx;
    idx = (*this) . begin();
    vector__ivy__stmt::domain::__t jdx;
    jdx = (*this) . end . prev();
    while (idx < jdx)
    {
        ivy::ptr< ivy::stmt::__t > tmp;
        tmp = (*this) . value (idx);
        (*this) . value (idx) = (*this) . value (jdx);
        (*this) . value (jdx) = tmp;
        jdx = jdx . prev();
        idx = idx . next();
    }
}
ivy::ptr< ivy::stmt::__t > ivy::sequence::fold_right  (const vector__ivy__stmt::__t &args,const ivy::ptr< annot::__t >
    &ann)
{
    ivy::ptr< ivy::stmt::__t > res;
    if (args . end > vector__ivy__stmt::domain::__t (0))
    {
        vector__ivy__stmt::domain::__t idx;
        idx = args . end . prev();
        res = args . value (idx);
        while (idx > vector__ivy__stmt::domain::__t (0))
        {
            idx = idx . prev();
            res = ivy::sequence::make (args . value (idx),res,ann);
        }
    }
    return res;
}
ivy::ptr< annot::__t > ivy::sequence::__t::get_ann () const
{
    ivy::ptr< annot::__t > res;
    res = (*this) . ann;
    return res;
}
ivy::ptr< ivy::stmt::__t > ivy::skipst::make  (const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< ivy::stmt::__t > res;
    {
        ivy::skipst::__t s;
        s . ann = ann;
        res = s;
    }
    return res;
}
void ivy::skipst::__t::encode  (pretty::__t &b,const priority::__t &prio) const
{
    (*this) . ann -> encode (b);
    b . extend (ivy::from_str< str::__t > ("{"));
    b . extend (ivy::from_str< str::__t > ("}"));
}
ivy::ptr< annot::__t > ivy::skipst::__t::get_ann () const
{
    ivy::ptr< annot::__t > res;
    res = (*this) . ann;
    return res;
}
void ivy::ifst::__t::encode  (pretty::__t &b,const priority::__t &prio) const
{
    (*this) . ann -> encode (b);
    if (priority::__t (1) < prio)
    {
        b . nest();
        b . extend (ivy::from_str< str::__t > ("{"));
        b . newline();
    }
    (*this) . encode_int (b,prio);
    if (priority::__t (1) < prio)
    {
        b . unnest();
        b . newline();
        b . extend (ivy::from_str< str::__t > ("}"));
    }
}
ivy::ptr< ivy::stmt::__t > ivy::ifst::make  (const ivy::ptr< ivy::expr::__t > &cond,const ivy::ptr< ivy::stmt::__t >
    &thenst,const ivy::ptr< ivy::stmt::__t > &elsest,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< ivy::stmt::__t > res;
    {
        ivy::ifst::__t s;
        s . cond = cond;
        s . thenst = elsest;
        s . elsest = elsest;
        s . ann = ann;
        res = s;
    }
    return res;
}
void ivy::ifst::__t::encode_int  (pretty::__t &b,const priority::__t &prio) const
{
    b . extend (ivy::from_str< str::__t > ("if"));
    b . extend (ivy::from_str< str::__t > (" "));
    if (ivy::native_bool (false)) {
        b . extend (ivy::from_str< str::__t > ("("));
    }
    (*this) . cond -> encode (b,priority::__t (0));
    if (ivy::native_bool (false)) {
        b . extend (ivy::from_str< str::__t > (")"));
    }
    b . extend (ivy::from_str< str::__t > (" "));
    (*this) . thenst -> encode (b,priority::__t (2));
    if (! (*this) . elsest . isa< ivy::skipst::__t >())
    {
        b . extend (ivy::from_str< str::__t > (" "));
        b . extend (ivy::from_str< str::__t > ("else"));
        b . extend (ivy::from_str< str::__t > (" "));
        (*this) . elsest -> encode (b,priority::__t (2));
    }
    {}
}
ivy::ptr< annot::__t > ivy::ifst::__t::get_ann () const
{
    ivy::ptr< annot::__t > res;
    res = (*this) . ann;
    return res;
}
void ivy::whilest::__t::encode  (pretty::__t &b,const priority::__t &prio) const
{
    (*this) . ann -> encode (b);
    if (priority::__t (1) < prio)
    {
        b . nest();
        b . extend (ivy::from_str< str::__t > ("{"));
        b . newline();
    }
    (*this) . encode_int (b,prio);
    if (priority::__t (1) < prio)
    {
        b . unnest();
        b . newline();
        b . extend (ivy::from_str< str::__t > ("}"));
    }
}
ivy::ptr< ivy::stmt::__t > ivy::whilest::make  (const ivy::ptr< ivy::expr::__t > &cond,const ivy::ptr< ivy::stmt::__t >
    &body,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< ivy::stmt::__t > res;
    {
        ivy::whilest::__t s;
        s . cond = cond;
        s . body = body;
        s . ann = ann;
        res = s;
    }
    return res;
}
void ivy::whilest::__t::encode_int  (pretty::__t &b,const priority::__t &prio) const
{
    b . extend (ivy::from_str< str::__t > ("while"));
    b . extend (ivy::from_str< str::__t > (" "));
    if (ivy::native_bool (false)) {
        b . extend (ivy::from_str< str::__t > ("("));
    }
    (*this) . cond -> encode (b,priority::__t (0));
    if (ivy::native_bool (false)) {
        b . extend (ivy::from_str< str::__t > (")"));
    }
    b . extend (ivy::from_str< str::__t > (" "));
    (*this) . body -> encode (b,priority::__t (2));
}
ivy::ptr< annot::__t > ivy::whilest::__t::get_ann () const
{
    ivy::ptr< annot::__t > res;
    res = (*this) . ann;
    return res;
}
void ivy::breakst::__t::encode  (pretty::__t &b,const priority::__t &prio) const
{
    (*this) . ann -> encode (b);
    if (priority::__t (1) < prio)
    {
        b . nest();
        b . extend (ivy::from_str< str::__t > ("{"));
        b . newline();
    }
    (*this) . encode_int (b,prio);
    if (priority::__t (1) < prio)
    {
        b . unnest();
        b . newline();
        b . extend (ivy::from_str< str::__t > ("}"));
    }
}
ivy::ptr< ivy::stmt::__t > ivy::breakst::make  (const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< ivy::stmt::__t > res;
    {
        ivy::breakst::__t s;
        s . ann = ann;
        res = s;
    }
    return res;
}
void ivy::breakst::__t::encode_int  (pretty::__t &b,const priority::__t &prio) const
{
    b . extend (ivy::from_str< str::__t > ("break;"));
}
ivy::ptr< annot::__t > ivy::breakst::__t::get_ann () const
{
    ivy::ptr< annot::__t > res;
    res = (*this) . ann;
    return res;
}
void ivy::stmt::parse  (pstate::__t &st,const priority::__t &prio,ivy::ptr< ivy::stmt::__t > &res)
{
    while (st . tok == ivy::from_str< str::__t > (";")) {
        st . consume();
    }
    if (st . tok == ivy::from_str< str::__t > ("{"))
    {
        st . consume();
        ivy::stmt::parse (st,priority::__t (0),res);
        if (st . ok & st . tok == ivy::from_str< str::__t > ("}")) {
            st . consume();
        } else {
            st . ok = ivy::native_bool (false);
        }
    } else
    {
        if (st . tok == ivy::from_str< str::__t > ("if"))
        {
            st . consume();
            ivy::ifst::__t s;
            st . get_ann (s . ann);
            ivy::expr::parse (st,priority::__t (0),s . cond);
            if (st . ok & st . tok == ivy::from_str< str::__t > ("{"))
            {
                ivy::stmt::parse (st,priority::__t (1),s . thenst);
                if (st . ok & st . tok == ivy::from_str< str::__t > ("else"))
                {
                    st . consume();
                    if (st . ok &
                    (st . tok == ivy::from_str< str::__t > ("{") | st . tok ==
                        ivy::from_str< str::__t > ("if")))
                    {
                        ivy::stmt::parse (st,priority::__t (1),s . elsest);
                    } else {
                        st . ok = ivy::native_bool (false);
                    }
                } else
                {
                    ivy::ptr< annot::__t > ann;
                    
                    // missing else doesn't print, so don't annotate
                    
                    s . elsest = ivy::skipst::make (ann);
                }
            } else {
                st . ok = ivy::native_bool (false);
            }
            res = s;
        } else
        {
            if (st . tok == ivy::from_str< str::__t > ("while"))
            {
                st . consume();
                ivy::whilest::__t s;
                st . get_ann (s . ann);
                ivy::expr::parse (st,priority::__t (0),s . cond);
                if (st . ok & st . tok == ivy::from_str< str::__t > ("{"))
                {
                    ivy::stmt::parse (st,priority::__t (1),s . body);
                } else {
                    st . ok = ivy::native_bool (false);
                }
                res = s;
            } else
            {
                if (st . tok == ivy::from_str< str::__t > ("}"))
                {
                    ivy::ptr< annot::__t > ann;
                    st . get_ann (ann);
                    res = ivy::skipst::make (ann);
                } else {
                    ivy::stmt::parse_lang_stmt (st,prio,res);
                }
            }
        }
    }
    if (st . ok & prio == priority::__t (0) & st . tok . end > pos::__t (0) & st . tok !=
    ivy::from_str< str::__t > ("}"))
    {
        ivy::sequence::__t sq;
        sq . lhs = res;
        ivy::stmt::parse (st,priority::__t (0),sq . rhs);
        res = sq;
    }
}
void ivy::decl::__t::encode  (pretty::__t &b,const priority::__t &prio) const {}
str::__t ivy::decl::__t::enc () const
{
    str::__t s;
    {
        pretty::__t p;
        p = pretty::make (pos::__t (100),pos::__t (4));
        p . cppstyle = ivy::native_bool (false);
        (*this) . encode (p,priority::__t (0));
        p . flush();
        s = p . output;
    }
    return s;
}
ivy::ptr< ivy::decl::__t > ivy::decl::dec  (const str::__t &s)
{
    ivy::ptr< ivy::decl::__t > e;
    {
        pstate::__t st;
        st = pstate::make (s);
        ivy::decl::parse (st,priority::__t (0),e);
        if (! st . ok | st . tok . end != pos::__t (0)) {
            parse_error (st . ann . line,st . tok);
        }
    }
    return e;
}
str::__t ivy::decl::encdec  (const str::__t &s)
{
    str::__t res;
    {
        ivy::ptr< ivy::decl::__t > e;
        e = ivy::decl::dec (s);
        res = e -> enc();
    }
    return res;
}
ivy::ptr< ivy::expr::__t > ivy::decl::__t::get_expr () const
{
    ivy::ptr< ivy::expr::__t > res;
    {}
    return res;
}
ivy::ptr< annot::__t > ivy::decl::__t::get_ann () const {
    ivy::ptr< annot::__t > res;
    {}
    return res;
}
ivy::ptr< ivy::stmt::__t > ivy::decl::__t::get_body () const
{
    ivy::ptr< ivy::stmt::__t > res;
    {}
    return res;
}
vector__ivy__prototype_argument::domain::__t vector__ivy__prototype_argument::domain::__t::next ()
    const
{
    vector__ivy__prototype_argument::domain::__t y;
    y = (*this) + vector__ivy__prototype_argument::domain::__t (1);
    return y;
}
vector__ivy__prototype_argument::domain::__t vector__ivy__prototype_argument::domain::__t::prev ()
    const
{
    vector__ivy__prototype_argument::domain::__t y;
    y = (*this) - vector__ivy__prototype_argument::domain::__t (1);
    return y;
}
vector__ivy__prototype_argument::domain::__t vector__ivy__prototype_argument::__t::begin () const
{
    vector__ivy__prototype_argument::domain::__t res;
    res = vector__ivy__prototype_argument::domain::__t (0);
    return res;
}
vector__ivy__prototype_argument::__t vector__ivy__prototype_argument::empty ()
{
    vector__ivy__prototype_argument::__t res;
    {}
    return res;
}
void vector__ivy__prototype_argument::__t::set  (const vector__ivy__prototype_argument::domain::__t
    &i,const ivy::prototype_argument::__t &v) {
    (*this) . value (i) = v;
}
void vector__ivy__prototype_argument::__t::append  (const ivy::prototype_argument::__t &c)
{
    (*this) . value ((*this) . end) = c;
    (*this) . end = (*this) . end . next();
}
void vector__ivy__prototype_argument::__t::extend  (const vector__ivy__prototype_argument::__t &x)
{
    vector__ivy__prototype_argument::domain::__t idx;
    idx = x . begin();
    while (idx < x . end) {
        (*this) . append (x . value (idx));
        idx = idx . next();
    }
}
void vector__ivy__prototype_argument::__t::resize  (const vector__ivy__prototype_argument::domain::__t
    &end) {
    ivy::resize ((*this) . value,end);
    (*this) . end = end;
}
ivy::prototype_argument::__t vector__ivy__prototype_argument::__t::back () const
{
    ivy::prototype_argument::__t y;
    if ((*this) . end > vector__ivy__prototype_argument::domain::__t (0))
    {
        y = (*this) . value ((*this) . end . prev());
    }
    return y;
}
void vector__ivy__prototype_argument::__t::pop_back ()
{
    if ((*this) . end > vector__ivy__prototype_argument::domain::__t (0))
    {
        vector__ivy__prototype_argument::domain::__t size;
        size = (*this) . end . prev();
        (*this) . resize (size);
    }
}
vector__ivy__prototype_argument::__t vector__ivy__prototype_argument::__t::segment  (const
    vector__ivy__prototype_argument::domain::__t &beg,const vector__ivy__prototype_argument::domain::__t
    &en) const
{
    vector__ivy__prototype_argument::__t res;
    {
        vector__ivy__prototype_argument::domain::__t idx;
        idx = beg;
        while (idx < en & idx < (*this) . end)
        {
            res . append ((*this) . value (idx));
            idx = idx . next();
        }
    }
    return res;
}
void vector__ivy__prototype_argument::__t::reverse ()
{
    vector__ivy__prototype_argument::domain::__t idx;
    idx = (*this) . begin();
    vector__ivy__prototype_argument::domain::__t jdx;
    jdx = (*this) . end . prev();
    while (idx < jdx)
    {
        ivy::prototype_argument::__t tmp;
        tmp = (*this) . value (idx);
        (*this) . value (idx) = (*this) . value (jdx);
        (*this) . value (jdx) = tmp;
        jdx = jdx . prev();
        idx = idx . next();
    }
}
ivy::ptr< ivy::decl::__t > ivy::actdc::make  (const ivy::ptr< ivy::expr::__t > &name,const
    vector__ivy__expr::__t &inputs,const vector__ivy__expr::__t &outputs,const __bool &has_body,const
    ivy::ptr< ivy::stmt::__t > &body)
{
    ivy::ptr< ivy::decl::__t > res;
    {
        ivy::actdc::__t s;
        s . name = name;
        s . inputs = inputs;
        s . outputs = outputs;
        s . has_body = has_body;
        s . body = body;
        res = s;
    }
    return res;
}
void ivy::actdc::__t::encode  (pretty::__t &b,const priority::__t &prio) const
{
    (*this) . ann -> encode (b);
    b . nest();
    if ((*this) . kind == ivy::action_kind::__t (ivy::action_kind::external))
    {
        b . extend (ivy::from_str< str::__t > ("extern"));
        b . extend (ivy::from_str< str::__t > (" "));
    } else
    {
        if ((*this) . kind == ivy::action_kind::__t (ivy::action_kind::imported))
        {
            b . extend (ivy::from_str< str::__t > ("import"));
            b . extend (ivy::from_str< str::__t > (" "));
        } else
        {
            if ((*this) . kind == ivy::action_kind::__t (ivy::action_kind::exported))
            {
                b . extend (ivy::from_str< str::__t > ("export"));
                b . extend (ivy::from_str< str::__t > (" "));
            }
        }
    }
    b . extend (ivy::from_str< str::__t > ("action"));
    b . extend (ivy::from_str< str::__t > (" "));
    (*this) . name -> encode (b,priority::__t (0));
    ivy::expr::tup::encode ((*this) . inputs,b,prio);
    if ((*this) . outputs . end > vector__ivy__expr::domain::__t (0))
    {
        b . extend (ivy::from_str< str::__t > (" "));
        b . extend (ivy::from_str< str::__t > ("returns"));
        ivy::expr::tup::encode ((*this) . outputs,b,prio);
    }
    b . unnest();
    if ((*this) . has_body)
    {
        b . extend (ivy::from_str< str::__t > (" "));
        b . extend (ivy::from_str< str::__t > ("="));
        b . extend (ivy::from_str< str::__t > (" "));
        (*this) . body -> encode (b,priority::__t (2));
    }
}
__bool ivy::actdc::__t::is_member () const
{
    __bool res;
    res = (*this) . name -> get_name() . isa< ivy::dotident::__t >() & (*this) . inputs . end >
        vector__ivy__expr::domain::__t (0) & (*this) . member_type() ==
        (*this) . name -> get_name() -> get_namesp();
    return res;
}
ivy::ptr< ivy::ident::__t > ivy::actdc::__t::member_type () const
{
    ivy::ptr< ivy::ident::__t > res;
    res =
        (*this) . inputs . value (vector__ivy__expr::domain::__t (0)) -> get_arg (vector__ivy__expr::domain::__t
                    (1)) -> get_name();
    return res;
}
ivy::ptr< ivy::stmt::__t > ivy::actdc::__t::get_body () const
{
    ivy::ptr< ivy::stmt::__t > res;
    res = (*this) . body;
    return res;
}
ivy::ident_set::__t ivy::ident_set::empty () {
    ivy::ident_set::__t a;
    {}
    return a;
}
void ivy::ident_set::__t::set  (const ivy::ptr< ivy::ident::__t > &x,const __bool &y)
{
    ivy::ident_set::rec z;
    z . full = ivy::native_bool (true);
    z . val = y;
    (*this) . map (x) = z;
}
void ivy::ident_set::__t::get  (const ivy::ptr< ivy::ident::__t > &x,__bool &y) const
{
    ivy::ident_set::rec z;
    z = (*this) . map (x);
    if (z . full) {
        y = z . val;
    }
}
__bool ivy::ident_set::__t::mem  (const ivy::ptr< ivy::ident::__t > &x) const
{
    __bool res;
    res = (*this) . map (x) . full;
    return res;
}
void ivy::ident_set::__t::remove  (const ivy::ptr< ivy::ident::__t > &x)
{
    ivy::ident_set::rec z;
    (*this) . map (x) = z;
}
__bool ivy::ident_set::__t::value  (const ivy::ptr< ivy::ident::__t > &x) const
{
    __bool y;
    y = (*this) . map (x) . val;
    return y;
}
ivy::ptr< ivy::expr::__t > ivy::colon::make  (const ivy::ptr< ivy::expr::__t > &lhs,const ivy::ptr< ivy::expr::__t >
    &rhs,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< ivy::expr::__t > res;
    {
        ivy::app::__t s;
        s . func = ivy::symbol::makestr (ivy::from_str< str::__t > (":"),ann);
        s . args . append (lhs);
        s . args . append (rhs);
        s . ann = ann;
        res = s;
    }
    return res;
}
ivy::ptr< ivy::expr::__t > ivy::colon::fold_left  (const vector__ivy__expr::__t &args,const ivy::ptr< annot::__t >
    &ann)
{
    ivy::ptr< ivy::expr::__t > res;
    if (args . end > vector__ivy__expr::domain::__t (0))
    {
        res = args . value (vector__ivy__expr::domain::__t (0));
        vector__ivy__expr::domain::__t idx;
        idx = args . begin() . next();
        while (idx < args . end)
        {
            res = ivy::colon::make (res,args . value (idx),ann);
            idx = idx . next();
        }
    } else {
        res = ivy::empty::make (ann);
    }
    return res;
}
vector__ivy__expr::__t ivy::colon::unfold_left  (const ivy::ptr< ivy::expr::__t > &s)
{
    vector__ivy__expr::__t args;
    {
        ivy::ptr< ivy::expr::__t > e;
        e = s;
        __bool b;
        b = e -> is_typed (ivy::verb::__t (ivy::verb::colon));
        while (b)
        {
            args . append (e -> get_arg (vector__ivy__expr::domain::__t (1)));
            e = e -> get_arg (vector__ivy__expr::domain::__t (0));
            b = e -> is_typed (ivy::verb::__t (ivy::verb::colon));
        }
        args . append (e);
        args . reverse();
    }
    return args;
}
ivy::ptr< ivy::expr::__t > ivy::arrow::make  (const ivy::ptr< ivy::expr::__t > &lhs,const ivy::ptr< ivy::expr::__t >
    &rhs,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< ivy::expr::__t > res;
    {
        ivy::app::__t s;
        s . func = ivy::symbol::makestr (ivy::from_str< str::__t > ("->"),ann);
        s . args . append (lhs);
        s . args . append (rhs);
        s . ann = ann;
        res = s;
    }
    return res;
}
ivy::ptr< ivy::expr::__t > ivy::arrow::fold_left  (const vector__ivy__expr::__t &args,const ivy::ptr< annot::__t >
    &ann)
{
    ivy::ptr< ivy::expr::__t > res;
    if (args . end > vector__ivy__expr::domain::__t (0))
    {
        res = args . value (vector__ivy__expr::domain::__t (0));
        vector__ivy__expr::domain::__t idx;
        idx = args . begin() . next();
        while (idx < args . end)
        {
            res = ivy::arrow::make (res,args . value (idx),ann);
            idx = idx . next();
        }
    } else {
        res = ivy::empty::make (ann);
    }
    return res;
}
vector__ivy__expr::__t ivy::arrow::unfold_left  (const ivy::ptr< ivy::expr::__t > &s)
{
    vector__ivy__expr::__t args;
    {
        ivy::ptr< ivy::expr::__t > e;
        e = s;
        __bool b;
        b = e -> is_typed (ivy::verb::__t (ivy::verb::arrow));
        while (b)
        {
            args . append (e -> get_arg (vector__ivy__expr::domain::__t (1)));
            e = e -> get_arg (vector__ivy__expr::domain::__t (0));
            b = e -> is_typed (ivy::verb::__t (ivy::verb::arrow));
        }
        args . append (e);
        args . reverse();
    }
    return args;
}
ivy::ptr< ivy::expr::__t > ivy::castop::make  (const ivy::ptr< ivy::expr::__t > &arg,const ivy::ptr< annot::__t >
    &ann)
{
    ivy::ptr< ivy::expr::__t > res;
    {
        ivy::app::__t s;
        s . func = ivy::symbol::makestr (ivy::from_str< str::__t > ("cast"),ann);
        s . args . append (arg);
        s . ann = ann;
        res = s;
    }
    return res;
}
ivy::ptr< ivy::expr::__t > ivy::equals::make  (const ivy::ptr< ivy::expr::__t > &lhs,const ivy::ptr< ivy::expr::__t >
    &rhs,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< ivy::expr::__t > res;
    {
        ivy::app::__t s;
        s . func = ivy::symbol::makestr (ivy::from_str< str::__t > ("="),ann);
        s . args . append (lhs);
        s . args . append (rhs);
        s . ann = ann;
        res = s;
    }
    return res;
}
ivy::ptr< ivy::expr::__t > ivy::equals::fold_left  (const vector__ivy__expr::__t &args,const ivy::ptr< annot::__t >
    &ann)
{
    ivy::ptr< ivy::expr::__t > res;
    if (args . end > vector__ivy__expr::domain::__t (0))
    {
        res = args . value (vector__ivy__expr::domain::__t (0));
        vector__ivy__expr::domain::__t idx;
        idx = args . begin() . next();
        while (idx < args . end)
        {
            res = ivy::equals::make (res,args . value (idx),ann);
            idx = idx . next();
        }
    } else {
        res = ivy::empty::make (ann);
    }
    return res;
}
vector__ivy__expr::__t ivy::equals::unfold_left  (const ivy::ptr< ivy::expr::__t > &s)
{
    vector__ivy__expr::__t args;
    {
        ivy::ptr< ivy::expr::__t > e;
        e = s;
        __bool b;
        b = e -> is_typed (ivy::verb::__t (ivy::verb::equals));
        while (b)
        {
            args . append (e -> get_arg (vector__ivy__expr::domain::__t (1)));
            e = e -> get_arg (vector__ivy__expr::domain::__t (0));
            b = e -> is_typed (ivy::verb::__t (ivy::verb::equals));
        }
        args . append (e);
        args . reverse();
    }
    return args;
}
ivy::ptr< ivy::expr::__t > ivy::notequals::make  (const ivy::ptr< ivy::expr::__t > &lhs,const ivy::ptr< ivy::expr::__t >
    &rhs,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< ivy::expr::__t > res;
    {
        ivy::app::__t s;
        s . func = ivy::symbol::makestr (ivy::from_str< str::__t > ("~="),ann);
        s . args . append (lhs);
        s . args . append (rhs);
        s . ann = ann;
        res = s;
    }
    return res;
}
ivy::ptr< ivy::expr::__t > ivy::notequals::fold_left  (const vector__ivy__expr::__t &args,const ivy::ptr< annot::__t >
    &ann)
{
    ivy::ptr< ivy::expr::__t > res;
    if (args . end > vector__ivy__expr::domain::__t (0))
    {
        res = args . value (vector__ivy__expr::domain::__t (0));
        vector__ivy__expr::domain::__t idx;
        idx = args . begin() . next();
        while (idx < args . end)
        {
            res = ivy::notequals::make (res,args . value (idx),ann);
            idx = idx . next();
        }
    } else {
        res = ivy::empty::make (ann);
    }
    return res;
}
vector__ivy__expr::__t ivy::notequals::unfold_left  (const ivy::ptr< ivy::expr::__t > &s)
{
    vector__ivy__expr::__t args;
    {
        ivy::ptr< ivy::expr::__t > e;
        e = s;
        __bool b;
        b = e -> is_typed (ivy::verb::__t (ivy::verb::notequals));
        while (b)
        {
            args . append (e -> get_arg (vector__ivy__expr::domain::__t (1)));
            e = e -> get_arg (vector__ivy__expr::domain::__t (0));
            b = e -> is_typed (ivy::verb::__t (ivy::verb::notequals));
        }
        args . append (e);
        args . reverse();
    }
    return args;
}
ivy::ptr< ivy::expr::__t > ivy::__not::make  (const ivy::ptr< ivy::expr::__t > &arg,const ivy::ptr< annot::__t >
    &ann)
{
    ivy::ptr< ivy::expr::__t > res;
    {
        ivy::app::__t s;
        s . func = ivy::symbol::makestr (ivy::from_str< str::__t > ("~"),ann);
        s . args . append (arg);
        s . ann = ann;
        res = s;
    }
    return res;
}
ivy::ptr< ivy::expr::__t > ivy::ite::make  (const ivy::ptr< ivy::expr::__t > &arg0,const ivy::ptr< ivy::expr::__t >
    &arg1,const ivy::ptr< ivy::expr::__t > &arg2,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< ivy::expr::__t > res;
    {
        ivy::app::__t s;
        s . func = ivy::symbol::makestr (ivy::from_str< str::__t > ("if"),ann);
        s . args . append (arg0);
        s . args . append (arg1);
        s . args . append (arg2);
        s . ann = ann;
        res = s;
    }
    return res;
}
ivy::ptr< ivy::expr::__t > ivy::varv::make  (const ivy::ptr< ivy::expr::__t > &arg,const ivy::ptr< annot::__t >
    &ann)
{
    ivy::ptr< ivy::expr::__t > res;
    {
        ivy::app::__t s;
        s . func = ivy::symbol::makestr (ivy::from_str< str::__t > ("var"),ann);
        s . args . append (arg);
        s . ann = ann;
        res = s;
    }
    return res;
}
ivy::ptr< ivy::expr::__t > ivy::isaop::make  (const ivy::ptr< ivy::expr::__t > &lhs,const ivy::ptr< ivy::expr::__t >
    &rhs,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< ivy::expr::__t > res;
    {
        ivy::app::__t s;
        s . func = ivy::symbol::makestr (ivy::from_str< str::__t > ("isa"),ann);
        s . args . append (lhs);
        s . args . append (rhs);
        s . ann = ann;
        res = s;
    }
    return res;
}
ivy::ptr< ivy::expr::__t > ivy::isaop::fold_left  (const vector__ivy__expr::__t &args,const ivy::ptr< annot::__t >
    &ann)
{
    ivy::ptr< ivy::expr::__t > res;
    if (args . end > vector__ivy__expr::domain::__t (0))
    {
        res = args . value (vector__ivy__expr::domain::__t (0));
        vector__ivy__expr::domain::__t idx;
        idx = args . begin() . next();
        while (idx < args . end)
        {
            res = ivy::isaop::make (res,args . value (idx),ann);
            idx = idx . next();
        }
    } else {
        res = ivy::empty::make (ann);
    }
    return res;
}
vector__ivy__expr::__t ivy::isaop::unfold_left  (const ivy::ptr< ivy::expr::__t > &s)
{
    vector__ivy__expr::__t args;
    {
        ivy::ptr< ivy::expr::__t > e;
        e = s;
        __bool b;
        b = e -> is_typed (ivy::verb::__t (ivy::verb::isav));
        while (b)
        {
            args . append (e -> get_arg (vector__ivy__expr::domain::__t (1)));
            e = e -> get_arg (vector__ivy__expr::domain::__t (0));
            b = e -> is_typed (ivy::verb::__t (ivy::verb::isav));
        }
        args . append (e);
        args . reverse();
    }
    return args;
}
ivy::ptr< ivy::stmt::__t > ivy::varst::make  (const ivy::ptr< ivy::expr::__t > &name,const ivy::ptr< annot::__t >
    &ann)
{
    ivy::ptr< ivy::stmt::__t > res;
    {
        ivy::varst::__t s;
        s . name = name;
        s . ann = ann;
        res = s;
    }
    return res;
}
void ivy::varst::__t::encode  (pretty::__t &b,const priority::__t &prio) const
{
    (*this) . ann -> encode (b);
    if (priority::__t (1) < prio)
    {
        b . nest();
        b . extend (ivy::from_str< str::__t > ("{"));
        b . newline();
    }
    (*this) . encode_int (b,prio);
    if (priority::__t (1) < prio)
    {
        b . unnest();
        b . newline();
        b . extend (ivy::from_str< str::__t > ("}"));
    }
}
void ivy::varst::__t::encode_int  (pretty::__t &b,const priority::__t &prio) const
{
    (*this) . ann -> encode (b);
    b . nest();
    b . extend (ivy::from_str< str::__t > ("var"));
    b . extend (ivy::from_str< str::__t > (" "));
    (*this) . name -> encode (b,priority::__t (0));
    b . extend (ivy::from_str< str::__t > (";"));
    b . unnest();
}
ivy::ptr< ivy::expr::__t > ivy::varst::__t::get_expr () const
{
    ivy::ptr< ivy::expr::__t > res;
    res = (*this) . name;
    return res;
}
ivy::ptr< ivy::stmt::__t > ivy::pragmast::make  (const ivy::ptr< ivy::expr::__t > &prg,const ivy::ptr< annot::__t >
    &ann)
{
    ivy::ptr< ivy::stmt::__t > res;
    {
        ivy::pragmast::__t s;
        s . prg = prg;
        s . ann = ann;
        res = s;
    }
    return res;
}
void ivy::pragmast::__t::encode  (pretty::__t &b,const priority::__t &prio) const
{
    (*this) . ann -> encode (b);
    if (priority::__t (1) < prio)
    {
        b . nest();
        b . extend (ivy::from_str< str::__t > ("{"));
        b . newline();
    }
    (*this) . encode_int (b,prio);
    if (priority::__t (1) < prio)
    {
        b . unnest();
        b . newline();
        b . extend (ivy::from_str< str::__t > ("}"));
    }
}
void ivy::pragmast::__t::encode_int  (pretty::__t &b,const priority::__t &prio) const
{
    (*this) . ann -> encode (b);
    b . nest();
    b . extend (ivy::from_str< str::__t > ("@"));
    (*this) . prg -> encode (b,priority::__t (0));
    b . extend (ivy::from_str< str::__t > (";"));
    b . unnest();
}
ivy::ptr< ivy::expr::__t > ivy::pragmast::__t::get_expr () const
{
    ivy::ptr< ivy::expr::__t > res;
    res = (*this) . prg;
    return res;
}
void ivy::stmt::parse_stmt_term  (pstate::__t &st)
{
    if (st . ok & st . tok == ivy::from_str< str::__t > (";")) {
        st . consume();
    } else {
        st . ok = st . ok & st . tok == ivy::from_str< str::__t > ("}");
    }
}
void ivy::stmt::parse_lang_stmt  (pstate::__t &st,const priority::__t &prio,ivy::ptr< ivy::stmt::__t >
    &res)
{
    if (st . ok & st . tok == ivy::from_str< str::__t > ("@"))
    {
        st . consume();
        ivy::pragmast::__t s;
        ivy::expr::parse (st,priority::__t (0),s . prg);
        ivy::stmt::parse_stmt_term (st);
        res = s;
    } else
    {
        ivy::asgn::__t s;
        st . get_ann (s . ann);
        if (st . tok == ivy::from_str< str::__t > ("call")) {
            st . consume();
        }
        ivy::expr::parse (st,priority::__t (0),s . lhs);
        if (st . ok & st . tok == ivy::from_str< str::__t > (":="))
        {
            st . consume();
            ivy::expr::parse (st,priority::__t (0),s . rhs);
            ivy::stmt::parse_stmt_term (st);
            res = s;
        } else
        {
            ivy::stmt::parse_stmt_term (st);
            if (s . lhs -> is (ivy::verb::__t (ivy::verb::varv)))
            {
                ivy::varst::__t vst;
                vst . ann = s . ann;
                vst . name = s . lhs -> get_arg (vector__ivy__expr::domain::__t (0));
                res = vst;
            } else
            {
                s . rhs = s . lhs;
                s . lhs = ivy::empty::make (s . ann -> strip());
                
                // just an expression -- assign to ()
                
                res = s;
            }
        }
    }
}
vector__ivy__decl::domain::__t vector__ivy__decl::domain::__t::next () const
{
    vector__ivy__decl::domain::__t y;
    y = (*this) + vector__ivy__decl::domain::__t (1);
    return y;
}
vector__ivy__decl::domain::__t vector__ivy__decl::domain::__t::prev () const
{
    vector__ivy__decl::domain::__t y;
    y = (*this) - vector__ivy__decl::domain::__t (1);
    return y;
}
vector__ivy__decl::domain::__t vector__ivy__decl::__t::begin () const
{
    vector__ivy__decl::domain::__t res;
    res = vector__ivy__decl::domain::__t (0);
    return res;
}
vector__ivy__decl::__t vector__ivy__decl::empty () {
    vector__ivy__decl::__t res;
    {}
    return res;
}
void vector__ivy__decl::__t::set  (const vector__ivy__decl::domain::__t &i,const ivy::ptr< ivy::decl::__t >
    &v) {
    (*this) . value (i) = v;
}
void vector__ivy__decl::__t::append  (const ivy::ptr< ivy::decl::__t > &c)
{
    (*this) . value ((*this) . end) = c;
    (*this) . end = (*this) . end . next();
}
void vector__ivy__decl::__t::extend  (const vector__ivy__decl::__t &x)
{
    vector__ivy__decl::domain::__t idx;
    idx = x . begin();
    while (idx < x . end) {
        (*this) . append (x . value (idx));
        idx = idx . next();
    }
}
void vector__ivy__decl::__t::resize  (const vector__ivy__decl::domain::__t &end)
{
    ivy::resize ((*this) . value,end);
    (*this) . end = end;
}
ivy::ptr< ivy::decl::__t > vector__ivy__decl::__t::back () const
{
    ivy::ptr< ivy::decl::__t > y;
    if ((*this) . end > vector__ivy__decl::domain::__t (0))
    {
        y = (*this) . value ((*this) . end . prev());
    }
    return y;
}
void vector__ivy__decl::__t::pop_back ()
{
    if ((*this) . end > vector__ivy__decl::domain::__t (0))
    {
        vector__ivy__decl::domain::__t size;
        size = (*this) . end . prev();
        (*this) . resize (size);
    }
}
vector__ivy__decl::__t vector__ivy__decl::__t::segment  (const vector__ivy__decl::domain::__t &beg,const
    vector__ivy__decl::domain::__t &en) const
{
    vector__ivy__decl::__t res;
    {
        vector__ivy__decl::domain::__t idx;
        idx = beg;
        while (idx < en & idx < (*this) . end)
        {
            res . append ((*this) . value (idx));
            idx = idx . next();
        }
    }
    return res;
}
void vector__ivy__decl::__t::reverse ()
{
    vector__ivy__decl::domain::__t idx;
    idx = (*this) . begin();
    vector__ivy__decl::domain::__t jdx;
    jdx = (*this) . end . prev();
    while (idx < jdx)
    {
        ivy::ptr< ivy::decl::__t > tmp;
        tmp = (*this) . value (idx);
        (*this) . value (idx) = (*this) . value (jdx);
        (*this) . value (jdx) = tmp;
        jdx = jdx . prev();
        idx = idx . next();
    }
}
ivy::ptr< ivy::decl::__t > ivy::groupdc::make  (const vector__ivy__decl::__t &decls)
{
    ivy::ptr< ivy::decl::__t > res;
    {
        ivy::groupdc::__t s;
        s . decls = decls;
        res = s;
    }
    return res;
}
void ivy::groupdc::__t::encode  (pretty::__t &b,const priority::__t &prio) const
{
    b . nest();
    b . extend (ivy::from_str< str::__t > ("{"));
    vector__ivy__decl::domain::__t idx;
    idx = (*this) . decls . begin();
    while (idx < (*this) . decls . end)
    {
        b . newline();
        (*this) . decls . value (idx) -> encode (b,priority::__t (0));
        idx = idx . next();
    }
    b . unnest();
    b . newline();
    b . extend (ivy::from_str< str::__t > ("}"));
}
void ivy::typespec::parse  (pstate::__t &st,const priority::__t &prio,ivy::ptr< ivy::typespec::__t >
    &res)
{
    if (st . tok == ivy::from_str< str::__t > ("struct"))
    {
        ivy::structspec::__t s;
        st . get_ann (s . ann);
        st . consume();
        ivy::curly_tup::parse (st,priority::__t (1),s . destructors);
        res = s;
    } else
    {
        ivy::enumspec::__t s;
        st . get_ann (s . ann);
        ivy::curly_tup::parse (st,priority::__t (1),s . constructors);
        res = s;
    }
}
void ivy::typespec::__t::encode  (pretty::__t &b,const priority::__t &prio) const {}
vector__ivy__expr::__t ivy::typespec::__t::get_elems () const
{
    vector__ivy__expr::__t res;
    {}
    return res;
}
void ivy::curly_tup::encode  (const vector__ivy__expr::__t &s,pretty::__t &b,const priority::__t &prio)
{
    if (s . end > vector__ivy__expr::domain::__t (0))
    {
        b . extend (ivy::from_str< str::__t > (" "));
        b . extend (ivy::from_str< str::__t > ("{"));
        s . value (vector__ivy__expr::domain::__t (0)) -> encode (b,priority::__t (0));
        vector__ivy__expr::domain::__t idx;
        idx = s . begin() . next();
        while (idx < s . end)
        {
            b . extend (ivy::from_str< str::__t > (","));
            s . value (idx) -> encode (b,priority::__t (0));
            idx = idx . next();
        }
        b . extend (ivy::from_str< str::__t > ("}"));
    }
}
void ivy::curly_tup::parse  (pstate::__t &st,const priority::__t &prio,vector__ivy__expr::__t &res)
{
    if (st . tok == ivy::from_str< str::__t > ("{"))
    {
        st . consume();
        ivy::ptr< ivy::expr::__t > s;
        ivy::expr::parse (st,prio,s);
        res . append (s);
        while (st . ok & st . tok == ivy::from_str< str::__t > (","))
        {
            st . consume();
            ivy::expr::parse (st,prio,s);
            res . append (s);
        }
        if (st . ok & st . tok == ivy::from_str< str::__t > ("}")) {
            st . consume();
        } else {
            st . ok = ivy::native_bool (false);
        }
    } else {
        st . ok = ivy::native_bool (false);
    }
}
void ivy::enumspec::__t::encode  (pretty::__t &b,const priority::__t &prio) const
{
    b . nest();
    ivy::curly_tup::encode ((*this) . constructors,b,prio);
    b . unnest();
}
vector__ivy__expr::__t ivy::enumspec::__t::get_elems () const
{
    vector__ivy__expr::__t res;
    res = (*this) . constructors;
    return res;
}
void ivy::structspec::__t::encode  (pretty::__t &b,const priority::__t &prio) const
{
    b . nest();
    b . extend (ivy::from_str< str::__t > ("struct"));
    b . extend (ivy::from_str< str::__t > (" "));
    ivy::curly_tup::encode ((*this) . destructors,b,prio);
    b . unnest();
}
vector__ivy__expr::__t ivy::structspec::__t::get_elems () const
{
    vector__ivy__expr::__t res;
    res = (*this) . destructors;
    return res;
}
ivy::ptr< ivy::decl::__t > ivy::typedc::make  (const ivy::ptr< ivy::expr::__t > &sort)
{
    ivy::ptr< ivy::decl::__t > res;
    {
        ivy::typedc::__t s;
        s . sort = sort;
        res = s;
    }
    return res;
}
void ivy::typedc::__t::encode  (pretty::__t &b,const priority::__t &prio) const
{
    (*this) . ann -> encode (b);
    b . nest();
    b . extend ((*this) . has_super ? ivy::from_str< str::__t > ("variant") :
            ivy::from_str< str::__t > ("type"));
    b . extend (ivy::from_str< str::__t > (" "));
    (*this) . sort -> encode (b,priority::__t (0));
    if ((*this) . has_super)
    {
        b . extend (ivy::from_str< str::__t > (" "));
        b . extend (ivy::from_str< str::__t > ("of"));
        b . extend (ivy::from_str< str::__t > (" "));
        (*this) . super -> encode (b,priority::__t (0));
    }
    if ((*this) . has_spec)
    {
        b . extend (ivy::from_str< str::__t > (" "));
        b . extend (ivy::from_str< str::__t > ("="));
        b . extend (ivy::from_str< str::__t > (" "));
        (*this) . spec -> encode (b,priority::__t (0));
    }
    b . unnest();
    b . newline();
}
ivy::ptr< ivy::decl::__t > ivy::vardc::make  (const ivy::ptr< ivy::expr::__t > &typing,const __bool
    &is_destructor,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< ivy::decl::__t > res;
    {
        ivy::vardc::__t s;
        s . typing = typing;
        s . is_destructor = is_destructor;
        s . ann = ann;
        res = s;
    }
    return res;
}
void ivy::vardc::__t::encode  (pretty::__t &b,const priority::__t &prio) const
{
    b . nest();
    b . extend ((*this) . is_destructor ? ivy::from_str< str::__t > ("destructor") :
            ((*this) . has_def ? ivy::from_str< str::__t > ("function") :
                ivy::from_str< str::__t > ("var")));
    b . extend (ivy::from_str< str::__t > (" "));
    (*this) . typing -> encode (b,priority::__t (0));
    b . unnest();
    if ((*this) . has_def)
    {
        b . extend (ivy::from_str< str::__t > (" "));
        b . extend (ivy::from_str< str::__t > ("="));
        b . extend (ivy::from_str< str::__t > (" "));
        (*this) . def -> encode (b,priority::__t (0));
    }
    b . newline();
}
ivy::ptr< ivy::decl::__t > ivy::header::make  (const str::__t &filename)
{
    ivy::ptr< ivy::decl::__t > res;
    {
        ivy::header::__t s;
        s . filename = filename;
        res = s;
    }
    return res;
}
void ivy::header::__t::encode  (pretty::__t &b,const priority::__t &prio) const
{
    b . nest();
    b . extend (ivy::from_str< str::__t > ("header"));
    b . extend (ivy::from_str< str::__t > (" "));
    b . extend ((*this) . filename);
    b . unnest();
    b . newline();
}
ivy::ptr< ivy::decl::__t > ivy::interpdc::make  (const ivy::ptr< ivy::expr::__t > &itype,const ivy::ptr< ivy::expr::__t >
    &ctype,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< ivy::decl::__t > res;
    {
        ivy::interpdc::__t s;
        s . itype = itype;
        s . ctype = ctype;
        res = s;
    }
    return res;
}
void ivy::interpdc::__t::encode  (pretty::__t &b,const priority::__t &prio) const
{
    b . nest();
    b . extend (ivy::from_str< str::__t > ("interpret"));
    b . extend (ivy::from_str< str::__t > (" "));
    (*this) . itype -> encode (b,priority::__t (0));
    b . extend (ivy::from_str< str::__t > (" "));
    b . extend (ivy::from_str< str::__t > ("->"));
    b . extend (ivy::from_str< str::__t > (" "));
    (*this) . ctype -> encode (b,priority::__t (0));
    b . unnest();
    b . newline();
}
ivy::ptr< ivy::decl::__t > ivy::includedc::make  (const ivy::ptr< ivy::expr::__t > &file,const ivy::ptr< annot::__t >
    &ann)
{
    ivy::ptr< ivy::decl::__t > res;
    {
        ivy::includedc::__t s;
        s . ann = ann;
        s . file = file;
        res = s;
    }
    return res;
}
void ivy::includedc::__t::encode  (pretty::__t &b,const priority::__t &prio) const
{
    b . nest();
    b . extend (ivy::from_str< str::__t > ("include"));
    b . extend (ivy::from_str< str::__t > (" "));
    (*this) . file -> encode (b,priority::__t (0));
    b . unnest();
    b . newline();
}
ivy::ptr< ivy::expr::__t > ivy::includedc::__t::get_expr () const
{
    ivy::ptr< ivy::expr::__t > res;
    res = (*this) . file;
    return res;
}
ivy::ptr< annot::__t > ivy::includedc::__t::get_ann () const
{
    ivy::ptr< annot::__t > res;
    res = (*this) . ann;
    return res;
}
ivy::ptr< ivy::decl::__t > ivy::moduledc::make  (const ivy::ptr< ivy::expr::__t > &name,const
    vector__ivy__expr::__t &prms,const ivy::ptr< ivy::decl::__t > &body)
{
    ivy::ptr< ivy::decl::__t > res;
    {
        ivy::moduledc::__t s;
        s . name = name;
        s . prms = prms;
        s . body = body;
        res = s;
    }
    return res;
}
void ivy::moduledc::__t::encode  (pretty::__t &b,const priority::__t &prio) const
{
    b . nest();
    b . extend (ivy::from_str< str::__t > ("module"));
    b . extend (ivy::from_str< str::__t > (" "));
    (*this) . name -> encode (b,priority::__t (0));
    if ((*this) . prms . end > vector__ivy__expr::domain::__t (0))
    {
        ivy::expr::tup::encode ((*this) . prms,b,priority::__t (0));
    }
    b . unnest();
    b . extend (ivy::from_str< str::__t > (" "));
    b . extend (ivy::from_str< str::__t > ("="));
    b . extend (ivy::from_str< str::__t > (" "));
    (*this) . body -> encode (b,priority::__t (2));
}
ivy::ptr< ivy::decl::__t > ivy::instantiatedc::make  (const ivy::ptr< ivy::expr::__t > &name,const
    vector__ivy__expr::__t &prms,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< ivy::decl::__t > res;
    {
        ivy::instantiatedc::__t s;
        s . name = name;
        s . prms = prms;
        s . ann = ann;
        res = s;
    }
    return res;
}
void ivy::instantiatedc::__t::encode  (pretty::__t &b,const priority::__t &prio) const
{
    b . nest();
    b . extend (ivy::from_str< str::__t > ("instantiate"));
    b . extend (ivy::from_str< str::__t > (" "));
    (*this) . name -> encode (b,priority::__t (0));
    if ((*this) . prms . end > vector__ivy__expr::domain::__t (0))
    {
        ivy::expr::tup::encode ((*this) . prms,b,priority::__t (0));
    }
    b . unnest();
    b . newline();
}
ivy::ptr< ivy::decl::__t > ivy::objectdc::make  (const ivy::ptr< ivy::expr::__t > &name,const ivy::ptr< ivy::decl::__t >
    &body,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< ivy::decl::__t > res;
    {
        ivy::objectdc::__t s;
        s . name = name;
        s . body = body;
        s . ann = ann;
        res = s;
    }
    return res;
}
void ivy::objectdc::__t::encode  (pretty::__t &b,const priority::__t &prio) const
{
    b . nest();
    b . extend (ivy::from_str< str::__t > ("object"));
    b . extend (ivy::from_str< str::__t > (" "));
    (*this) . name -> encode (b,priority::__t (0));
    b . unnest();
    b . extend (ivy::from_str< str::__t > (" "));
    b . extend (ivy::from_str< str::__t > ("="));
    b . extend (ivy::from_str< str::__t > (" "));
    (*this) . body -> encode (b,priority::__t (0));
}
ivy::ptr< ivy::decl::__t > ivy::instancedc::make  (const ivy::ptr< ivy::expr::__t > &objname,const
    ivy::ptr< ivy::expr::__t > &modname,const vector__ivy__expr::__t &prms)
{
    ivy::ptr< ivy::decl::__t > res;
    {
        ivy::instancedc::__t s;
        s . objname = objname;
        s . modname = modname;
        s . prms = prms;
        res = s;
    }
    return res;
}
void ivy::instancedc::__t::encode  (pretty::__t &b,const priority::__t &prio) const
{
    b . nest();
    b . extend ((*this) . is_auto ? ivy::from_str< str::__t > ("autoinstance") :
            ivy::from_str< str::__t > ("instance"));
    b . extend (ivy::from_str< str::__t > (" "));
    (*this) . objname -> encode (b,priority::__t (0));
    b . extend (ivy::from_str< str::__t > (" "));
    b . extend (ivy::from_str< str::__t > (":"));
    b . extend (ivy::from_str< str::__t > (" "));
    (*this) . modname -> encode (b,priority::__t (0));
    if ((*this) . prms . end > vector__ivy__expr::domain::__t (0))
    {
        ivy::expr::tup::encode ((*this) . prms,b,priority::__t (0));
    }
    b . unnest();
    b . newline();
}
void ivy::initdc::__t::encode  (pretty::__t &b,const priority::__t &prio) const
{
    b . extend (ivy::from_str< str::__t > ("init"));
    b . extend (ivy::from_str< str::__t > (" "));
    (*this) . body -> encode (b,priority::__t (1));
    b . newline();
}
ivy::ptr< ivy::stmt::__t > ivy::initdc::__t::get_body () const
{
    ivy::ptr< ivy::stmt::__t > res;
    res = (*this) . body;
    return res;
}
void ivy::parse_action  (pstate::__t &st,const priority::__t &prio,const ivy::action_kind::__t &kind,ivy::ptr< ivy::decl::__t >
    &res)
{
    if (st . tok == ivy::from_str< str::__t > ("action"))
    {
        st . consume();
        ivy::actdc::__t s;
        s . kind = kind;
        st . get_ann (s . ann);
        ivy::expr::parse (st,priority::__t (99),s . name);
        if (st . ok & st . tok == ivy::from_str< str::__t > ("("))
        {
            ivy::expr::tup::parse (st,priority::__t (1),s . inputs);
        }
        
        // 1 = prio of ","
        
        if (st . ok & st . tok == ivy::from_str< str::__t > ("returns"))
        {
            st . consume();
            ivy::expr::tup::parse (st,priority::__t (1),s . outputs);
        }
        if (st . ok & st . tok == ivy::from_str< str::__t > ("="))
        {
            st . consume();
            s . has_body = ivy::native_bool (true);
            if (st . tok == ivy::from_str< str::__t > ("{"))
            {
                ivy::stmt::parse (st,priority::__t (1),s . body);
            } else {
                st . ok = ivy::native_bool (false);
            }
        }
        res = s;
    } else {
        st . ok = ivy::native_bool (false);
    }
}
void ivy::decl::parse  (pstate::__t &st,const priority::__t &prio,ivy::ptr< ivy::decl::__t > &res)
{
    if (st . tok == ivy::from_str< str::__t > ("{"))
    {
        st . consume();
        ivy::groupdc::__t s;
        st . get_ann (s . ann);
        if (st . tok == ivy::from_str< str::__t > ("...")) {
            st . consume();
        }
        ivy::decl::parse_list (st,priority::__t (0),s . decls);
        if (st . tok == ivy::from_str< str::__t > ("}")) {
            st . consume();
        } else {
            st . ok = ivy::native_bool (false);
        }
        res = s;
    } else
    {
        if (st . tok == ivy::from_str< str::__t > ("action"))
        {
            ivy::parse_action (st,prio,ivy::action_kind::__t (ivy::action_kind::internal),res);
        } else
        {
            if (st . tok == ivy::from_str< str::__t > ("type"))
            {
                st . consume();
                ivy::typedc::__t s;
                st . get_ann (s . ann);
                ivy::expr::parse (st,ivy::verb_to_prio (ivy::verb::__t (ivy::verb::equals)),s . sort);
                if (st . ok & st . tok == ivy::from_str< str::__t > ("="))
                {
                    st . consume();
                    s . has_spec = ivy::native_bool (true);
                    ivy::typespec::parse (st,priority::__t (0),s . spec);
                }
                res = s;
            } else
            {
                if (st . tok == ivy::from_str< str::__t > ("var") | st . tok ==
                ivy::from_str< str::__t > ("destructor") | st . tok ==
                ivy::from_str< str::__t > ("function"))
                {
                    ivy::vardc::__t s;
                    s . is_destructor = st . tok == ivy::from_str< str::__t > ("destructor");
                    st . consume();
                    st . get_ann (s . ann);
                    ivy::expr::parse (st,ivy::verb_to_prio (ivy::verb::__t (ivy::verb::equals)),s .
                            typing);
                    if (st . ok & st . tok == ivy::from_str< str::__t > ("="))
                    {
                        st . consume();
                        s . has_def = ivy::native_bool (true);
                        ivy::expr::parse (st,priority::__t (0),s . def);
                    }
                    res = s;
                } else
                {
                    if (st . tok == ivy::from_str< str::__t > ("header"))
                    {
                        ivy::header::__t s;
                        st . get_ann (s . ann);
                        st . consume();
                        if (st . ok & st . tok . end > pos::__t (0) &
                        st . tok . value (pos::__t (0)) == __char::__t (34))
                        {
                            
                            // double quote
                            
                            s . filename = st . tok;
                            st . consume();
                        } else {
                            st . ok = ivy::native_bool (false);
                        }
                        res = s;
                    } else
                    {
                        if (st . tok == ivy::from_str< str::__t > ("interpret"))
                        {
                            ivy::interpdc::__t s;
                            st . get_ann (s . ann);
                            st . consume();
                            if (st . ok & st . tok . end > pos::__t (0))
                            {
                                ivy::expr::parse (st,ivy::verb_to_prio (ivy::verb::__t (ivy::verb::arrow)),s
                                        . itype);
                                if (st . ok & st . tok == ivy::from_str< str::__t > ("->"))
                                {
                                    st . consume();
                                    ivy::expr::parse (st,priority::__t (0),s . ctype);
                                } else {
                                    st . ok = ivy::native_bool (false);
                                }
                                {}
                            } else {
                                st . ok = ivy::native_bool (false);
                            }
                            res = s;
                        } else
                        {
                            if (st . tok == ivy::from_str< str::__t > ("include"))
                            {
                                ivy::includedc::__t s;
                                st . get_ann (s . ann);
                                st . consume();
                                ivy::expr::parse (st,priority::__t (0),s . file);
                                res = s;
                            } else
                            {
                                if (st . tok == ivy::from_str< str::__t > ("module"))
                                {
                                    ivy::moduledc::__t s;
                                    st . get_ann (s . ann);
                                    st . consume();
                                    ivy::expr::parse (st,priority::__t (99),s . name);
                                    
                                    // allow dot operator, not application
                                    
                                    if (st . ok & st . tok == ivy::from_str< str::__t > ("("))
                                    {
                                        ivy::expr::tup::parse (st,priority::__t (1),s . prms);
                                    }
                                    if (st . ok & st . tok == ivy::from_str< str::__t > ("="))
                                    {
                                        st . consume();
                                        ivy::decl::parse (st,priority::__t (0),s . body);
                                    } else {
                                        st . ok = ivy::native_bool (false);
                                    }
                                    res = s;
                                } else
                                {
                                    if (st . tok == ivy::from_str< str::__t > ("instantiate"))
                                    {
                                        ivy::instantiatedc::__t s;
                                        st . get_ann (s . ann);
                                        st . consume();
                                        ivy::expr::parse (st,priority::__t (99),s . name);
                                        if (st . ok & st . tok == ivy::from_str< str::__t > ("("))
                                        {
                                            ivy::expr::tup::parse (st,priority::__t (1),s . prms);
                                        }
                                        res = s;
                                    } else
                                    {
                                        if (st . tok == ivy::from_str< str::__t > ("object"))
                                        {
                                            ivy::objectdc::__t s;
                                            st . get_ann (s . ann);
                                            st . consume();
                                            ivy::expr::parse (st,priority::__t (99),s . name);
                                            if (st . ok & st . tok ==
                                            ivy::from_str< str::__t > ("=")) {
                                                st . consume();
                                            }
                                            if (st . ok & st . tok ==
                                            ivy::from_str< str::__t > ("{"))
                                            {
                                                ivy::decl::parse (st,priority::__t (0),s . body);
                                            }
                                            res = s;
                                        } else
                                        {
                                            if (st . tok == ivy::from_str< str::__t > ("instance") |
                                            st . tok == ivy::from_str< str::__t > ("autoinstance"))
                                            {
                                                ivy::instancedc::__t s;
                                                s . is_auto = st . tok ==
                                                    ivy::from_str< str::__t > ("autoinstance");
                                                st . get_ann (s . ann);
                                                st . consume();
                                                ivy::expr::parse (st,priority::__t (99),s . objname);
                                                if (st . ok & st . tok ==
                                                ivy::from_str< str::__t > (":")) {
                                                    st . consume();
                                                }
                                                if (st . ok)
                                                {
                                                    ivy::expr::parse (st,priority::__t (99),s .
                                                            modname);
                                                }
                                                if (st . ok & st . tok ==
                                                ivy::from_str< str::__t > ("("))
                                                {
                                                    ivy::expr::tup::parse (st,priority::__t (1),s .
                                                            prms);
                                                }
                                                res = s;
                                            } else
                                            {
                                                if (st . tok ==
                                                ivy::from_str< str::__t > ("variant"))
                                                {
                                                    st . consume();
                                                    ivy::typedc::__t s;
                                                    s . has_super = ivy::native_bool (true);
                                                    st . get_ann (s . ann);
                                                    ivy::expr::parse (st,priority::__t (0),s . sort);
                                                    if (st . ok & st . tok ==
                                                    ivy::from_str< str::__t > ("of"))
                                                    {
                                                        st . consume();
                                                    } else {
                                                        st . ok = ivy::native_bool (false);
                                                    }
                                                    ivy::expr::parse (st,ivy::verb_to_prio (ivy::verb::__t
                                                                    (ivy::verb::equals)),s . super);
                                                    if (st . ok & st . tok ==
                                                    ivy::from_str< str::__t > ("="))
                                                    {
                                                        st . consume();
                                                        s . has_spec = ivy::native_bool (true);
                                                        ivy::typespec::parse (st,priority::__t (0),s
                                                                . spec);
                                                    }
                                                    res = s;
                                                } else
                                                {
                                                    if (st . tok ==
                                                    ivy::from_str< str::__t > ("extern"))
                                                    {
                                                        st . consume();
                                                        ivy::parse_action (st,prio,ivy::action_kind::__t
                                                                    (ivy::action_kind::external),res);
                                                    } else
                                                    {
                                                        if (st . tok ==
                                                        ivy::from_str< str::__t > ("import"))
                                                        {
                                                            st . consume();
                                                            ivy::parse_action (st,prio,ivy::action_kind::__t
                                                                        (ivy::action_kind::imported),res);
                                                        } else
                                                        {
                                                            if (st . tok ==
                                                            ivy::from_str< str::__t > ("export"))
                                                            {
                                                                st . consume();
                                                                ivy::parse_action (st,prio,ivy::action_kind::__t
                                                                            (ivy::action_kind::exported),res);
                                                            } else
                                                            {
                                                                if (st . tok ==
                                                                ivy::from_str< str::__t > ("init"))
                                                                {
                                                                    ivy::initdc::__t s;
                                                                    st . get_ann (s . ann);
                                                                    st . consume();
                                                                    if (st . tok ==
                                                                    ivy::from_str< str::__t > ("{"))
                                                                    {
                                                                        ivy::stmt::parse (st,priority::__t
                                                                                    (1),s . body);
                                                                    } else
                                                                    {
                                                                        st . ok =
                                                                            ivy::native_bool (false);
                                                                    }
                                                                    res = s;
                                                                } else
                                                                {
                                                                    if (st . tok ==
                                                                    ivy::from_str< str::__t > ("after"))
                                                                    {
                                                                        ivy::initdc::__t s;
                                                                        st . get_ann (s . ann);
                                                                        st . consume();
                                                                        if (st . tok ==
                                                                        ivy::from_str< str::__t > ("init"))
                                                                        {
                                                                            st . consume();
                                                                        } else
                                                                        {
                                                                            st . ok =
                                                                                ivy::native_bool (false);
                                                                        }
                                                                        if (st . ok & st . tok ==
                                                                        ivy::from_str< str::__t > ("{"))
                                                                        {
                                                                            ivy::stmt::parse (st,priority::__t
                                                                                        (1),s . body);
                                                                        } else
                                                                        {
                                                                            st . ok =
                                                                                ivy::native_bool (false);
                                                                        }
                                                                        res = s;
                                                                    } else
                                                                    {
                                                                        st . ok =
                                                                            ivy::native_bool (false);
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
void ivy::decl::parse_list  (pstate::__t &st,const priority::__t &prio,vector__ivy__decl::__t &res)
{
    while (st . ok & st . tok . end > pos::__t (0) & st . tok != ivy::from_str< str::__t > ("}"))
    {
        ivy::ptr< ivy::decl::__t > s;
        ivy::decl::parse (st,priority::__t (0),s);
        res . append (s);
    }
}
void ivy::version::__t::encode  (pretty::__t &b) const
{
    b . extend (ivy::from_str< str::__t > ("#lang ivy"));
    vector__pos::domain::__t idx;
    idx = (*this) . nums . begin();
    while (idx < (*this) . nums . end)
    {
        if (idx > (*this) . nums . begin()) {
            b . extend (ivy::from_str< str::__t > ("."));
        }
        b . extend ((*this) . nums . value (idx) . to_str());
        idx = idx . next();
    }
}
void ivy::version::parse  (pstate::__t &st,const priority::__t &prio,ivy::version::__t &res)
{
    if (st . ok & st . tok == ivy::from_str< str::__t > ("lang")) {
        st . consume();
    } else {
        st . ok = ivy::native_bool (false);
    }
    if (st . ok & st . tok . segment (pos::__t (0),pos::__t (3)) ==
    ivy::from_str< str::__t > ("ivy"))
    {
        st . p = st . p - (st . tok . end - pos::__t (3));
        st . consume();
    }
    if (st . ok & st . tok . end > pos::__t (0) & st . tok . value (pos::__t (0)) . is_digit())
    {
        res . nums . append (pos::from_str (st . tok));
        st . consume();
        while (st . ok & st . tok == ivy::from_str< str::__t > ("."))
        {
            st . consume();
            if (st . tok . end > pos::__t (0) & st . tok . value (pos::__t (0)) . is_digit())
            {
                res . nums . append (pos::from_str (st . tok));
                st . consume();
            } else {
                st . ok = ivy::native_bool (false);
            }
        }
    }
    if (st . tok . end > pos::__t (0)) {
        st . ok = ivy::native_bool (false);
    }
}
str::__t ivy::prog::__t::enc () const
{
    str::__t s;
    {
        pretty::__t p;
        p = pretty::make (pos::__t (100),pos::__t (4));
        p . cppstyle = ivy::native_bool (false);
        (*this) . encode (p,priority::__t (0));
        p . flush();
        s = p . output;
    }
    return s;
}
ivy::prog::__t ivy::prog::dec  (const str::__t &s)
{
    ivy::prog::__t e;
    {
        pstate::__t st;
        st = pstate::make (s);
        ivy::prog::parse (st,priority::__t (0),e);
        if (! st . ok | st . tok . end != pos::__t (0)) {
            parse_error (st . ann . line,st . tok);
        }
    }
    return e;
}
str::__t ivy::prog::encdec  (const str::__t &s)
{
    str::__t res;
    {
        ivy::prog::__t e;
        e = ivy::prog::dec (s);
        res = e . enc();
    }
    return res;
}
ivy::prog::__t ivy::prog::make  (const vector__ivy__decl::__t &decls)
{
    ivy::prog::__t res;
    {
        ivy::prog::__t s;
        s . decls = decls;
        res = s;
    }
    return res;
}
void ivy::prog::__t::encode  (pretty::__t &b,const priority::__t &prio) const
{
    if (! ivy::native_bool (false)) {
        (*this) . vers . encode (b);
    }
    b . newline();
    vector__ivy__decl::domain::__t idx;
    idx = (*this) . decls . begin();
    while (idx < (*this) . decls . end)
    {
        b . newline();
        if (idx > vector__ivy__decl::domain::__t (0)) {
            b . newline();
        }
        (*this) . decls . value (idx) -> encode (b,priority::__t (0));
        idx = idx . next();
    }
    {}
}
void ivy::prog::parse_to  (pstate::__t &st,const priority::__t &prio,ivy::prog::__t &res)
{
    if (! ivy::native_bool (false))
    {
        if (st . ann . comments . end > vector__str::domain::__t (0))
        {
            pstate::__t vst;
            vst = pstate::make (st . ann . comments . value (vector__str::domain::__t (0)));
            ivy::version::parse (vst,priority::__t (0),res . vers);
            st . ok = vst . ok;
            st . ann . comments =
                st . ann . comments . segment (vector__str::domain::__t (1),st . ann . comments .
                    end);
        } else {
            st . ok = ivy::native_bool (false);
        }
        {}
    }
    while (st . ok & st . tok . end > pos::__t (0))
    {
        ivy::ptr< ivy::decl::__t > dcl;
        ivy::decl::parse (st,priority::__t (0),dcl);
        res . decls . append (dcl);
    }
}
void ivy::prog::parse  (pstate::__t &st,const priority::__t &prio,ivy::prog::__t &res)
{
    ivy::prog::parse_to (st,prio,res);
}
void ivy::error::__t::encode  (pretty::__t &b) const
{
    b . extend (ivy::from_str< str::__t > ("unknown error"));
}
vector__ivy__error::domain::__t vector__ivy__error::domain::__t::next () const
{
    vector__ivy__error::domain::__t y;
    y = (*this) + vector__ivy__error::domain::__t (1);
    return y;
}
vector__ivy__error::domain::__t vector__ivy__error::domain::__t::prev () const
{
    vector__ivy__error::domain::__t y;
    y = (*this) - vector__ivy__error::domain::__t (1);
    return y;
}
vector__ivy__error::domain::__t vector__ivy__error::__t::begin () const
{
    vector__ivy__error::domain::__t res;
    res = vector__ivy__error::domain::__t (0);
    return res;
}
vector__ivy__error::__t vector__ivy__error::empty () {
    vector__ivy__error::__t res;
    {}
    return res;
}
void vector__ivy__error::__t::set  (const vector__ivy__error::domain::__t &i,const ivy::ptr< ivy::error::__t >
    &v) {
    (*this) . value (i) = v;
}
void vector__ivy__error::__t::append  (const ivy::ptr< ivy::error::__t > &c)
{
    (*this) . value ((*this) . end) = c;
    (*this) . end = (*this) . end . next();
}
void vector__ivy__error::__t::extend  (const vector__ivy__error::__t &x)
{
    vector__ivy__error::domain::__t idx;
    idx = x . begin();
    while (idx < x . end) {
        (*this) . append (x . value (idx));
        idx = idx . next();
    }
}
void vector__ivy__error::__t::resize  (const vector__ivy__error::domain::__t &end)
{
    ivy::resize ((*this) . value,end);
    (*this) . end = end;
}
ivy::ptr< ivy::error::__t > vector__ivy__error::__t::back () const
{
    ivy::ptr< ivy::error::__t > y;
    if ((*this) . end > vector__ivy__error::domain::__t (0))
    {
        y = (*this) . value ((*this) . end . prev());
    }
    return y;
}
void vector__ivy__error::__t::pop_back ()
{
    if ((*this) . end > vector__ivy__error::domain::__t (0))
    {
        vector__ivy__error::domain::__t size;
        size = (*this) . end . prev();
        (*this) . resize (size);
    }
}
vector__ivy__error::__t vector__ivy__error::__t::segment  (const vector__ivy__error::domain::__t &beg,const
    vector__ivy__error::domain::__t &en) const
{
    vector__ivy__error::__t res;
    {
        vector__ivy__error::domain::__t idx;
        idx = beg;
        while (idx < en & idx < (*this) . end)
        {
            res . append ((*this) . value (idx));
            idx = idx . next();
        }
    }
    return res;
}
void vector__ivy__error::__t::reverse ()
{
    vector__ivy__error::domain::__t idx;
    idx = (*this) . begin();
    vector__ivy__error::domain::__t jdx;
    jdx = (*this) . end . prev();
    while (idx < jdx)
    {
        ivy::ptr< ivy::error::__t > tmp;
        tmp = (*this) . value (idx);
        (*this) . value (idx) = (*this) . value (jdx);
        (*this) . value (jdx) = tmp;
        jdx = jdx . prev();
        idx = idx . next();
    }
}
void ivy::report_error  (const ivy::ptr< ivy::error::__t > &e,const ivy::ptr< annot::__t > &ann)
{
    pretty::__t b;
    b = pretty::make (pos::__t (100),pos::__t (4));
    b . extend (ann -> to_str());
    b . extend (ivy::from_str< str::__t > (":"));
    b . extend (ivy::from_str< str::__t > (" "));
    e -> encode (b);
    b . flush();
    stdio::write (b . output);
    ivy::errors . append (e);
}
ivy::type_clash::__t ivy::type_clash::make  (const ivy::ptr< ivy::expr::__t > &e,const ivy::ptr< ivy::expr::__t >
    &t1,const ivy::ptr< ivy::expr::__t > &t2)
{
    ivy::type_clash::__t res;
    {
        res . e = e;
        res . t1 = t1;
        res . t2 = t2;
    }
    return res;
}
void ivy::type_clash::__t::encode  (pretty::__t &b) const
{
    b . extend (ivy::from_str< str::__t > ("Cannot unify types"));
    b . extend (ivy::from_str< str::__t > (" "));
    (*this) . t1 -> encode (b,priority::__t (0));
    b . extend (ivy::from_str< str::__t > (" "));
    b . extend (ivy::from_str< str::__t > ("and"));
    b . extend (ivy::from_str< str::__t > (" "));
    (*this) . t2 -> encode (b,priority::__t (0));
    b . extend (ivy::from_str< str::__t > (" "));
    b . extend (ivy::from_str< str::__t > ("when typing this expression:"));
    b . extend (ivy::from_str< str::__t > (" "));
    (*this) . e -> encode (b,priority::__t (0));
    b . newline();
}
ivy::type_conversion::__t ivy::type_conversion::make  (const ivy::ptr< ivy::expr::__t > &e,const ivy::ptr< ivy::expr::__t >
    &t1,const ivy::ptr< ivy::expr::__t > &t2)
{
    ivy::type_conversion::__t res;
    {
        res . e = e;
        res . t1 = t1;
        res . t2 = t2;
    }
    return res;
}
void ivy::type_conversion::__t::encode  (pretty::__t &b) const
{
    b . extend (ivy::from_str< str::__t > ("Cannot cast the expression"));
    b . extend (ivy::from_str< str::__t > (" "));
    (*this) . e -> encode (b,priority::__t (0));
    b . extend (ivy::from_str< str::__t > (" "));
    b . extend (ivy::from_str< str::__t > ("of type"));
    b . extend (ivy::from_str< str::__t > (" "));
    (*this) . t1 -> encode (b,priority::__t (0));
    b . extend (ivy::from_str< str::__t > (" "));
    b . extend (ivy::from_str< str::__t > ("to type"));
    b . extend (ivy::from_str< str::__t > (" "));
    (*this) . t2 -> encode (b,priority::__t (0));
    b . newline();
}
ivy::untyped::__t ivy::untyped::make  (const ivy::ptr< ivy::expr::__t > &e,const ivy::ptr< ivy::expr::__t >
    &t1) {
    ivy::untyped::__t res;
    {
        res . e = e;
        res . t1 = t1;
    }
    return res;
}
void ivy::untyped::__t::encode  (pretty::__t &b) const
{
    b . extend (ivy::from_str< str::__t > ("Cannot infer the type of this term:"));
    b . extend (ivy::from_str< str::__t > (" "));
    (*this) . e -> encode (b,priority::__t (0));
    b . newline();
    if ((*this) . t1 -> get_verb() != ivy::verb::__t (ivy::verb::empty))
    {
        b . extend (ivy::from_str< str::__t > (" "));
        b . newline();
        b . extend (ivy::from_str< str::__t > ("Incomplete type:"));
        b . extend (ivy::from_str< str::__t > (" "));
        (*this) . t1 -> encode (b,priority::__t (0));
        b . newline();
    }
}
ivy::not_first_order::__t ivy::not_first_order::make  (const ivy::ptr< ivy::expr::__t > &e,const ivy::ptr< ivy::expr::__t >
    &t1) {
    ivy::not_first_order::__t res;
    {
        res . e = e;
        res . t1 = t1;
    }
    return res;
}
void ivy::not_first_order::__t::encode  (pretty::__t &b) const
{
    b . extend (ivy::from_str< str::__t > ("Expression should have simple type:"));
    b . newline();
    (*this) . e -> encode (b,priority::__t (0));
    b . newline();
    b . extend (ivy::from_str< str::__t > ("Actual type:"));
    b . extend (ivy::from_str< str::__t > (" "));
    (*this) . t1 -> encode (b,priority::__t (0));
    b . newline();
}
ivy::file_not_found::__t ivy::file_not_found::make  (const str::__t &n)
{
    ivy::file_not_found::__t res;
    res . n = n;
    return res;
}
void ivy::file_not_found::__t::encode  (pretty::__t &b) const
{
    b . extend (ivy::from_str< str::__t > ("File not found:"));
    b . extend (ivy::from_str< str::__t > (" "));
    b . extend ((*this) . n);
    b . newline();
}
ivy::cannot_write::__t ivy::cannot_write::make  (const str::__t &n)
{
    ivy::cannot_write::__t res;
    res . n = n;
    return res;
}
void ivy::cannot_write::__t::encode  (pretty::__t &b) const
{
    b . extend (ivy::from_str< str::__t > ("Failed to write file:"));
    b . extend (ivy::from_str< str::__t > (" "));
    b . extend ((*this) . n);
    b . newline();
}
ivy::undefined::__t ivy::undefined::make  (const ivy::ptr< ivy::ident::__t > &n)
{
    ivy::undefined::__t res;
    res . n = n;
    return res;
}
void ivy::undefined::__t::encode  (pretty::__t &b) const
{
    b . extend (ivy::from_str< str::__t > ("Undefined:"));
    b . extend (ivy::from_str< str::__t > (" "));
    (*this) . n -> encode (b,priority::__t (0));
    b . newline();
}
ivy::redefining::__t ivy::redefining::make  (const ivy::ptr< ivy::ident::__t > &n,const ivy::ptr< annot::__t >
    &ann) {
    ivy::redefining::__t res;
    {
        res . n = n;
        res . ann = ann;
    }
    return res;
}
void ivy::redefining::__t::encode  (pretty::__t &b) const
{
    b . extend (ivy::from_str< str::__t > ("Redefining "));
    (*this) . n -> encode (b,priority::__t (0));
    b . newline();
    b . extend ((*this) . ann -> to_str());
    b . extend (ivy::from_str< str::__t > (": previous definition"));
    b . newline();
}
ivy::wrong_number_params::__t ivy::wrong_number_params::make  (const vector__ivy__expr::domain::__t
    &n) {
    ivy::wrong_number_params::__t res;
    res . n = n;
    return res;
}
void ivy::wrong_number_params::__t::encode  (pretty::__t &b) const
{
    b . extend (ivy::from_str< str::__t > ("Wrong number of parameters given."));
    b . newline();
}
ivy::syntax_error::__t ivy::syntax_error::make  (const str::__t &tok)
{
    ivy::syntax_error::__t res;
    res . tok = tok;
    return res;
}
void ivy::syntax_error::__t::encode  (pretty::__t &b) const
{
    b . extend (ivy::from_str< str::__t > ("Syntax error at token"));
    b . extend (ivy::from_str< str::__t > (" "));
    b . extend ((*this) . tok);
    b . newline();
}
ivy::bad_syntax::__t ivy::bad_syntax::make  (const ivy::ptr< ivy::expr::__t > &e)
{
    ivy::bad_syntax::__t res;
    res . e = e;
    return res;
}
void ivy::bad_syntax::__t::encode  (pretty::__t &b) const
{
    b . extend (ivy::from_str< str::__t > ("Syntax error at expression"));
    b . extend (ivy::from_str< str::__t > (" "));
    (*this) . e -> encode (b,priority::__t (0));
    b . newline();
}
str::__t env::get  (const str::__t &name) {
    str::__t res;
    res = ivy::getenv (name);
    return res;
}
void ivy::file::read  (const str::__t &fname,str::__t &b,__bool &ok) {
    ivy::read_file (fname,b,ok);
}
__bool ivy::file::write  (const str::__t &fname,const str::__t &b)
{
    __bool ok;
    ok = ivy::__write_file (fname,b);
    return ok;
}
__bool ivy::file::exist  (const str::__t &fname) {
    __bool ok;
    ok = ivy::file_exists (fname);
    return ok;
}
void ivy::write_file  (const str::__t &name,const str::__t &buf)
{
    __bool ok;
    ok = ivy::file::write (name,buf);
    if (! ok) {
        ivy::ptr< annot::__t > ann;
        ivy::report_error (ivy::cannot_write::make (name),ann);
    }
}
void ivy::prog::find_include  (str::__t &name)
{
    name . extend (ivy::from_str< str::__t > (".ivy"));
    if (! ivy::file::exist (name))
    {
        vector__str::domain::__t idx;
        idx = ivy::include_path . begin();
        __bool found;
        found = ivy::native_bool (false);
        while (! found & idx < ivy::include_path . end)
        {
            str::__t pname;
            {
                pname = ivy::include_path . value (idx);
                ivy::path::concat (pname,name);
            }
            if (ivy::file::exist (pname)) {
                name = pname;
                found = ivy::native_bool (true);
            }
            idx = idx . next();
        }
    }
}
void ivy::prog::read_file_int  (const str::__t &name,const ivy::ptr< annot::__t > &ann,ivy::prog::__t
    &p,ivy::prog::readst &rst)
{
    str::__t text;
    __bool ok;
    ivy::file::read (name,text,ok);
    if (ok)
    {
        pstate::__t st;
        st = pstate::make (text);
        st . ann . file = name;
        ivy::prog::parse_to (st,priority::__t (0),p);
        ok = st . ok & st . tok . end == pos::__t (0);
        if (ok)
        {
            vector__ivy__decl::domain::__t idx;
            idx = p . decls . begin();
            while (idx < p . decls . end & ivy::errors . end == vector__ivy__error::domain::__t (0))
            {
                ivy::ptr< ivy::decl::__t > d;
                d = p . decls . value (idx);
                if (d . isa< ivy::includedc::__t >())
                {
                    ivy::ptr< ivy::expr::__t > sname;
                    sname = d -> get_expr();
                    if (! sname . isa< ivy::symbol::__t >())
                    {
                        ivy::report_error (ivy::bad_syntax::make (sname),sname -> get_ann());
                    } else
                    {
                        ivy::ptr< ivy::ident::__t > iname;
                        iname = sname -> get_name();
                        if (! rst . have_read . mem (iname))
                        {
                            str::__t fname;
                            {
                                fname = iname -> to_str();
                                ivy::prog::find_include (fname);
                            }
                            ivy::prog::__t subp;
                            ivy::prog::read_file_int (fname,d -> get_ann(),subp,rst);
                            p . decls . set (idx,ivy::groupdc::make (subp . decls));
                            rst . have_read . set (iname,ivy::native_bool (true));
                        }
                    }
                }
                idx = idx . next();
            }
        } else
        {
            ivy::syntax_error::__t foo;
            foo = ivy::syntax_error::make (st . tok);
            ivy::report_error (foo,st . ann);
        }
    } else
    {
        ivy::file_not_found::__t foo;
        foo = ivy::file_not_found::make (name);
        ivy::report_error (foo,ann);
    }
}
ivy::prog::__t ivy::prog::read_file  (const str::__t &name)
{
    ivy::prog::__t p;
    {
        ivy::ptr< annot::__t > ann;
        p . decls . append (ivy::includedc::make (ivy::symbol::makestr (ivy::from_str< str::__t > ("ivy"),ann),ann));
        ivy::prog::readst rst;
        ivy::prog::read_file_int (name,ann,p,rst);
    }
    return p;
}
void ivy::path::change_extension  (str::__t &path,const str::__t &ext)
{
    if (path . end > pos::__t (0))
    {
        pos::__t idx;
        idx = path . end . prev();
        while (idx > pos::__t (0) & path . value (idx) != __char::__t (46)) 
        // dot
        
        {
            idx = idx . prev();
        }
        if (path . value (idx) == __char::__t (46))
        {
            path = path . segment (path . begin(),idx);
            path . extend (ivy::from_str< str::__t > ("."));
            path . extend (ext);
        }
    }
}
void ivy::path::drop_extension  (str::__t &path)
{
    if (path . end > pos::__t (0))
    {
        pos::__t idx;
        idx = path . end . prev();
        while (idx > pos::__t (0) & path . value (idx) != __char::__t (46)) 
        // dot
        
        {
            idx = idx . prev();
        }
        if (path . value (idx) == __char::__t (46)) {
            path = path . segment (path . begin(),idx);
        }
    }
}
void ivy::path::concat  (str::__t &path1,const str::__t &path2)
{
    path1 . extend (ivy::from_str< str::__t > ("/"));
    path1 . extend (path2);
}
ivy::symeval::__t ivy::symeval::empty () {
    ivy::symeval::__t a;
    {}
    return a;
}
void ivy::symeval::__t::set  (const ivy::ptr< ivy::ident::__t > &x,const ivy::ptr< ivy::expr::__t >
    &y) {
    ivy::symeval::rec z;
    z . full = ivy::native_bool (true);
    z . val = y;
    (*this) . map (x) = z;
}
void ivy::symeval::__t::get  (const ivy::ptr< ivy::ident::__t > &x,ivy::ptr< ivy::expr::__t > &y)
    const {
    ivy::symeval::rec z;
    z = (*this) . map (x);
    if (z . full) {
        y = z . val;
    }
}
__bool ivy::symeval::__t::mem  (const ivy::ptr< ivy::ident::__t > &x) const
{
    __bool res;
    res = (*this) . map (x) . full;
    return res;
}
void ivy::symeval::__t::remove  (const ivy::ptr< ivy::ident::__t > &x)
{
    ivy::symeval::rec z;
    (*this) . map (x) = z;
}
ivy::ptr< ivy::expr::__t > ivy::symeval::__t::value  (const ivy::ptr< ivy::ident::__t > &x) const
{
    ivy::ptr< ivy::expr::__t > y;
    y = (*this) . map (x) . val;
    return y;
}
ivy::ptr< ivy::expr::__t > ivy::expr::__t::reduce  (const ivy::symeval::__t &smap) const
{
    ivy::ptr< ivy::expr::__t > res;
    {}
    return res;
}
__bool ivy::expr::__t::occurs  (const ivy::ptr< ivy::ident::__t > &n) const
{
    __bool res;
    res = ivy::native_bool (false);
    return res;
}
__bool ivy::expr::__t::has_numident () const {
    __bool res;
    res = ivy::native_bool (false);
    return res;
}
ivy::ptr< ivy::expr::__t > ivy::symbol::__t::reduce  (const ivy::symeval::__t &smap) const
{
    ivy::ptr< ivy::expr::__t > res;
    {
        ivy::ptr< ivy::expr::__t > e;
        e = (*this);
        res = e;
        smap . get ((*this) . name,res);
    }
    return res;
}
__bool ivy::symbol::__t::occurs  (const ivy::ptr< ivy::ident::__t > &n) const
{
    __bool res;
    res = (*this) . name == n;
    return res;
}
__bool ivy::symbol::__t::has_numident () const
{
    __bool res;
    res = (*this) . name . isa< ivy::numident::__t >();
    return res;
}
ivy::ptr< ivy::expr::__t > ivy::app::__t::reduce  (const ivy::symeval::__t &smap) const
{
    ivy::ptr< ivy::expr::__t > res;
    {
        ivy::app::__t resa;
        resa . func = (*this) . func -> reduce (smap);
        vector__ivy__expr::domain::__t idx;
        idx = (*this) . args . begin();
        while (idx < (*this) . args . end)
        {
            resa . args . append ((*this) . args . value (idx) -> reduce (smap));
            idx = idx . next();
        }
        res = resa;
    }
    return res;
}
__bool ivy::app::__t::occurs  (const ivy::ptr< ivy::ident::__t > &n) const
{
    __bool res;
    {
        res = (*this) . func -> occurs (n);
        vector__ivy__expr::domain::__t idx;
        idx = (*this) . args . begin();
        while (idx < (*this) . args . end)
        {
            res = res | (*this) . args . value (idx) -> occurs (n);
            idx = idx . next();
        }
    }
    return res;
}
__bool ivy::app::__t::has_numident () const
{
    __bool res;
    {
        res = (*this) . func -> has_numident();
        vector__ivy__expr::domain::__t idx;
        idx = (*this) . args . begin();
        while (idx < (*this) . args . end)
        {
            res = res | (*this) . args . value (idx) -> has_numident();
            idx = idx . next();
        }
    }
    return res;
}
void ivy::subst_vector  (vector__ivy__expr::__t &v,const ivy::symeval::__t &smap)
{
    vector__ivy__expr::domain::__t idx;
    idx = v . begin();
    while (idx < v . end) {
        v . set (idx,v . value (idx) -> reduce (smap));
        idx = idx . next();
    }
}
ivy::ident_to_moduledc::__t ivy::ident_to_moduledc::empty ()
{
    ivy::ident_to_moduledc::__t a;
    {}
    return a;
}
void ivy::ident_to_moduledc::__t::set  (const ivy::ptr< ivy::ident::__t > &x,const ivy::moduledc::__t
    &y)
{
    ivy::ident_to_moduledc::rec z;
    z . full = ivy::native_bool (true);
    z . val = y;
    (*this) . map (x) = z;
}
void ivy::ident_to_moduledc::__t::get  (const ivy::ptr< ivy::ident::__t > &x,ivy::moduledc::__t &y)
    const {
    ivy::ident_to_moduledc::rec z;
    z = (*this) . map (x);
    if (z . full) {
        y = z . val;
    }
}
__bool ivy::ident_to_moduledc::__t::mem  (const ivy::ptr< ivy::ident::__t > &x) const
{
    __bool res;
    res = (*this) . map (x) . full;
    return res;
}
void ivy::ident_to_moduledc::__t::remove  (const ivy::ptr< ivy::ident::__t > &x)
{
    ivy::ident_to_moduledc::rec z;
    (*this) . map (x) = z;
}
ivy::moduledc::__t ivy::ident_to_moduledc::__t::value  (const ivy::ptr< ivy::ident::__t > &x) const
{
    ivy::moduledc::__t y;
    y = (*this) . map (x) . val;
    return y;
}
ivy::moduledc::__t ivy::ident_to_moduledc::__t::get_def  (const ivy::ptr< ivy::ident::__t > &x,const
    ivy::ptr< annot::__t > &ann) const
{
    ivy::moduledc::__t y;
    if (! (*this) . mem (x)) {
        ivy::report_error (ivy::undefined::make (x),ann);
    } else {
        (*this) . get (x,y);
    }
    return y;
}
ivy::ident_to_ident::__t ivy::ident_to_ident::empty () {
    ivy::ident_to_ident::__t a;
    {}
    return a;
}
void ivy::ident_to_ident::__t::set  (const ivy::ptr< ivy::ident::__t > &x,const ivy::ptr< ivy::ident::__t >
    &y)
{
    ivy::ident_to_ident::rec z;
    z . full = ivy::native_bool (true);
    z . val = y;
    (*this) . map (x) = z;
}
void ivy::ident_to_ident::__t::get  (const ivy::ptr< ivy::ident::__t > &x,ivy::ptr< ivy::ident::__t >
    &y) const {
    ivy::ident_to_ident::rec z;
    z = (*this) . map (x);
    if (z . full) {
        y = z . val;
    }
}
__bool ivy::ident_to_ident::__t::mem  (const ivy::ptr< ivy::ident::__t > &x) const
{
    __bool res;
    res = (*this) . map (x) . full;
    return res;
}
void ivy::ident_to_ident::__t::remove  (const ivy::ptr< ivy::ident::__t > &x)
{
    ivy::ident_to_ident::rec z;
    (*this) . map (x) = z;
}
ivy::ptr< ivy::ident::__t > ivy::ident_to_ident::__t::value  (const ivy::ptr< ivy::ident::__t > &x)
    const {
    ivy::ptr< ivy::ident::__t > y;
    y = (*this) . map (x) . val;
    return y;
}
ivy::ident_to_instantiatedc::__t ivy::ident_to_instantiatedc::empty ()
{
    ivy::ident_to_instantiatedc::__t a;
    {}
    return a;
}
void ivy::ident_to_instantiatedc::__t::set  (const ivy::ptr< ivy::ident::__t > &x,const ivy::instantiatedc::__t
    &y)
{
    ivy::ident_to_instantiatedc::rec z;
    z . full = ivy::native_bool (true);
    z . val = y;
    (*this) . map (x) = z;
}
void ivy::ident_to_instantiatedc::__t::get  (const ivy::ptr< ivy::ident::__t > &x,ivy::instantiatedc::__t
    &y) const {
    ivy::ident_to_instantiatedc::rec z;
    z = (*this) . map (x);
    if (z . full) {
        y = z . val;
    }
}
__bool ivy::ident_to_instantiatedc::__t::mem  (const ivy::ptr< ivy::ident::__t > &x) const
{
    __bool res;
    res = (*this) . map (x) . full;
    return res;
}
void ivy::ident_to_instantiatedc::__t::remove  (const ivy::ptr< ivy::ident::__t > &x)
{
    ivy::ident_to_instantiatedc::rec z;
    (*this) . map (x) = z;
}
ivy::instantiatedc::__t ivy::ident_to_instantiatedc::__t::value  (const ivy::ptr< ivy::ident::__t >
    &x) const {
    ivy::instantiatedc::__t y;
    y = (*this) . map (x) . val;
    return y;
}
ivy::ident_to_annot::__t ivy::ident_to_annot::empty () {
    ivy::ident_to_annot::__t a;
    {}
    return a;
}
void ivy::ident_to_annot::__t::set  (const ivy::ptr< ivy::ident::__t > &x,const ivy::ptr< annot::__t >
    &y)
{
    ivy::ident_to_annot::rec z;
    z . full = ivy::native_bool (true);
    z . val = y;
    (*this) . map (x) = z;
}
void ivy::ident_to_annot::__t::get  (const ivy::ptr< ivy::ident::__t > &x,ivy::ptr< annot::__t > &y)
    const {
    ivy::ident_to_annot::rec z;
    z = (*this) . map (x);
    if (z . full) {
        y = z . val;
    }
}
__bool ivy::ident_to_annot::__t::mem  (const ivy::ptr< ivy::ident::__t > &x) const
{
    __bool res;
    res = (*this) . map (x) . full;
    return res;
}
void ivy::ident_to_annot::__t::remove  (const ivy::ptr< ivy::ident::__t > &x)
{
    ivy::ident_to_annot::rec z;
    (*this) . map (x) = z;
}
ivy::ptr< annot::__t > ivy::ident_to_annot::__t::value  (const ivy::ptr< ivy::ident::__t > &x) const
{
    ivy::ptr< annot::__t > y;
    y = (*this) . map (x) . val;
    return y;
}
ivy::ident_to_ident::__t ivy::prm_map  (const vector__ivy__expr::__t &fml,const vector__ivy__expr::__t
    &act,const ivy::ptr< annot::__t > &ann)
{
    ivy::ident_to_ident::__t res;
    if (fml . end != act . end) {
        ivy::report_error (ivy::wrong_number_params::make (fml . end),ann);
    } else
    {
        vector__ivy__expr::domain::__t idx;
        idx = fml . begin();
        while (idx < fml . end)
        {
            res . set (fml . value (idx) -> get_name(),act . value (idx) -> get_name());
            idx = idx . next();
        }
    }
    return res;
}
void ivy::expr::__t::flat  (ivy::flatst::__t &st,ivy::ptr< ivy::expr::__t > &res) const {}
ivy::ptr< ivy::expr::__t > ivy::applydot  (const ivy::ptr< ivy::expr::__t > &arg,const ivy::ptr< ivy::ident::__t >
    &member,const ivy::ptr< annot::__t > &ann,const ivy::flatst::__t &st)
{
    ivy::ptr< ivy::expr::__t > res;
    if (arg . isa< ivy::symbol::__t >())
    {
        ivy::ptr< ivy::ident::__t > name;
        name = member -> prefix (arg -> get_name());
        __bool __tmp0;
        __tmp0 = ivy::native_bool (false);
        st . defs . get (arg -> get_name(),__tmp0);
        if (st . absolute | st . defining | __tmp0 & ! st . locals . mem (arg -> get_name()) & !
        st . globals . mem (arg -> get_name()))
        {
            res = ivy::symbol::make (name,ann);
            ivy::check_defined (name,st,ann);
        } else {
            res = ivy::dot::make (arg,ivy::symbol::make (member,ann),ann);
        }
    } else {
        res = ivy::dot::make (arg,ivy::symbol::make (member,ann),ann);
    }
    return res;
}
void ivy::find_ident  (const ivy::ptr< ivy::ident::__t > &root,ivy::ptr< ivy::ident::__t > &s,const
    ivy::flatst::__t &st)
{
    ivy::ptr< ivy::ident::__t > cand;
    cand = s -> prefix (root);
    if (st . defs . mem (cand)) {
        s = cand;
    } else {
        if (root . isa< ivy::dotident::__t >()) {
            ivy::find_ident (root -> get_namesp(),s,st);
        }
    }
}
ivy::ptr< ivy::ident::__t > ivy::ident::__t::flat  (const __bool &rhs,const ivy::flatst::__t &st)
    const {
    ivy::ptr< ivy::ident::__t > res;
    res = (*this) . __upcast();
    return res;
}
ivy::ptr< ivy::ident::__t > ivy::strident::__t::flat  (const __bool &rhs,const ivy::flatst::__t &st)
    const
{
    ivy::ptr< ivy::ident::__t > res;
    {
        ivy::strident::__t s2;
        s2 = (*this);
        
        // workaround
        
        vector__ivy__ident::domain::__t idx;
        idx = s2 . subscrs . begin();
        while (idx < s2 . subscrs . end)
        {
            ivy::ptr< ivy::ident::__t > t;
            t = s2 . subscrs . value (idx);
            t = t -> flat (ivy::native_bool (false),st);
            s2 . subscrs . set (idx,t);
            idx = idx . next();
        }
        if (st . has_root & s2 . val == ivy::from_str< str::__t > ("this") & s2 . subscrs . end ==
        vector__ivy__ident::domain::__t (0)) {
            res = st . root;
        } else
        {
            res = s2;
            if (! rhs)
            {
                {
                    ivy::ptr< ivy::ident::__t > __tmp1;
                    __tmp1 = res;
                    st . prmvals . get (res,__tmp1);
                    res = __tmp1;
                }
                if (st . has_root)
                {
                    if (st . defining) {
                        res = res -> prefix (st . root);
                    } else {
                        ivy::find_ident (st . root,res,st);
                    }
                }
            }
        }
    }
    return res;
}
ivy::ptr< ivy::ident::__t > ivy::dotident::__t::flat  (const __bool &rhs,const ivy::flatst::__t &st)
    const
{
    ivy::ptr< ivy::ident::__t > res;
    res = ivy::dotident::make ((*this) . namesp -> flat (rhs,st),(*this) . member);
    return res;
}
void ivy::add_def_id  (const ivy::ptr< ivy::ident::__t > &id,ivy::flatst::__t &st,const __bool &is_global,const
    __bool &is_object,const ivy::ptr< annot::__t > &ann)
{
    st . defs . set (id,ivy::native_bool (true));
    if (! is_object)
    {
        if (st . non_objects . mem (id))
        {
            ivy::report_error (ivy::redefining::make (id,st . non_objects . value (id)),ann);
        }
    }
    if (! is_object) {
        st . non_objects . set (id,ann);
    }
    if (is_global) {
        st . globals . set (id,ivy::native_bool (true));
    }
}
void ivy::add_def  (const ivy::ptr< ivy::expr::__t > &s,ivy::flatst::__t &st,const __bool &is_global,const
    __bool &is_object)
{
    st . defining = ivy::native_bool (true);
    
    //        var id := s.get_name.flat(false,st);
    
    ivy::ptr< ivy::expr::__t > e;
    s -> flat (st,e);
    st . defining = ivy::native_bool (false);
    ivy::check_syntax_symbol (e);
    ivy::ptr< ivy::ident::__t > id;
    id = e -> get_name();
    ivy::add_def_id (id,st,is_global,is_object,s -> get_ann());
}
void ivy::check_defined  (const ivy::ptr< ivy::ident::__t > &name,const ivy::flatst::__t &st,const
    ivy::ptr< annot::__t > &ann)
{
    if (! st . defs . mem (name) & ! st . absolute & ! st . defining & ! st . no_undefined)
    {
        ivy::report_error (ivy::undefined::make (name),ann);
    }
}
void ivy::symbol::__t::flat  (ivy::flatst::__t &st,ivy::ptr< ivy::expr::__t > &res) const
{
    ivy::symbol::__t f;
    f = (*this);
    if ((*this) . vrb == ivy::verb::__t (ivy::verb::none))
    {
        if (! st . locals . mem (f . name))
        {
            f . name = f . name -> flat (ivy::native_bool (false),st);
            f . vrb = f . name -> get_verb();
            
            // name subst could change verb
            
            if (f . vrb == ivy::verb::__t (ivy::verb::none))
            {
                ivy::check_defined (f . name,st,(*this) . ann);
            }
        }
    }
    res = f;
}
void ivy::app::__t::flat  (ivy::flatst::__t &st,ivy::ptr< ivy::expr::__t > &res) const
{
    ivy::ptr< ivy::expr::__t > arg0;
    (*this) . args . value (vector__ivy__expr::domain::__t (0)) -> flat (st,arg0);
    if ((*this) . is (ivy::verb::__t (ivy::verb::dot)))
    {
        res =
            ivy::applydot (arg0,(*this) . args . value (vector__ivy__expr::domain::__t (1)) ->
                        get_name() -> flat (ivy::native_bool (true),st),(*this) . ann,st);
    } else
    {
        if ((*this) . is (ivy::verb::__t (ivy::verb::varv)))
        {
            ivy::flat_formal ((*this) . args . value (vector__ivy__expr::domain::__t (0)),st,res);
            res = ivy::varv::make (res,(*this) . ann);
        } else
        {
            vector__ivy__expr::__t args;
            args . append (arg0);
            vector__ivy__expr::domain::__t idx;
            idx = (*this) . args . begin() . next();
            while (idx < (*this) . args . end)
            {
                ivy::ptr< ivy::expr::__t > arg;
                (*this) . args . value (idx) -> flat (st,arg);
                args . append (arg);
                idx = idx . next();
            }
            ivy::ptr< ivy::expr::__t > func;
            (*this) . func -> flat (st,func);
            res = ivy::app::make (func,args,(*this) . ann);
        }
    }
}
void ivy::stmt::__t::flat  (ivy::flatst::__t &st,ivy::ptr< ivy::stmt::__t > &res) const
{
    res = (*this) . __upcast();
}
ivy::ptr< ivy::ident::__t > ivy::stmt::__t::get_ident () const
{
    ivy::ptr< ivy::ident::__t > res;
    {}
    return res;
}
void ivy::setup_local_vars  (const ivy::ptr< ivy::stmt::__t > &s,ivy::flatst::__t &st,vector__ivy__ident::__t
    &del)
{
    ivy::ptr< ivy::expr::__t > alhs;
    alhs = s -> get_lhs();
    vector__ivy__expr::__t lhs;
    lhs = ivy::comma::unfold_left (alhs);
    vector__ivy__expr::domain::__t idx;
    idx = lhs . begin();
    while (idx < lhs . end)
    {
        ivy::ptr< ivy::expr::__t > e;
        e = lhs . value (idx);
        if (e -> is (ivy::verb::__t (ivy::verb::varv)))
        {
            ivy::ptr< ivy::ident::__t > id;
            id = ivy::formal_ident (e -> get_arg (vector__ivy__expr::domain::__t (0)));
            if (! st . locals . mem (id))
            {
                del . append (id);
                st . locals . set (id,ivy::native_bool (true));
            }
        }
        idx = idx . next();
    }
}
void ivy::remove_local_vars  (const vector__ivy__ident::__t &del,ivy::flatst::__t &st)
{
    vector__ivy__ident::domain::__t idx;
    idx = del . begin();
    while (idx < del . end)
    {
        ivy::ptr< ivy::ident::__t > id;
        id = del . value (idx);
        st . locals . remove (id);
        idx = idx . next();
    }
}
void ivy::asgn::__t::flat  (ivy::flatst::__t &st,ivy::ptr< ivy::stmt::__t > &res) const
{
    ivy::asgn::__t t;
    (*this) . flat_int (st,t);
    t . ann = (*this) . ann;
    res = t;
}
void ivy::asgn::__t::flat_int  (ivy::flatst::__t &st,ivy::asgn::__t &res) const
{
    res = (*this);
    res . lhs -> flat (st,res . lhs);
    res . rhs -> flat (st,res . rhs);
}
void ivy::sequence::__t::flat  (ivy::flatst::__t &st,ivy::ptr< ivy::stmt::__t > &res) const
{
    ivy::sequence::__t t;
    (*this) . flat_int (st,t);
    t . ann = (*this) . ann;
    res = t;
}
void ivy::sequence::__t::flat_int  (ivy::flatst::__t &st,ivy::sequence::__t &res) const
{
    res = (*this);
    if (res . lhs . isa< ivy::asgn::__t >())
    {
        vector__ivy__ident::__t del;
        ivy::setup_local_vars (res . lhs,st,del);
        res . lhs -> flat (st,res . lhs);
        res . rhs -> flat (st,res . rhs);
        ivy::remove_local_vars (del,st);
    } else
    {
        res . lhs -> flat (st,res . lhs);
        if (res . lhs . isa< ivy::varst::__t >())
        {
            vector__ivy__ident::__t del;
            ivy::ptr< ivy::ident::__t > id;
            id = ivy::formal_ident (res . lhs -> get_expr());
            if (! st . locals . mem (id))
            {
                del . append (id);
                st . locals . set (id,ivy::native_bool (true));
            }
            res . rhs -> flat (st,res . rhs);
            ivy::remove_local_vars (del,st);
        } else {
            res . rhs -> flat (st,res . rhs);
        }
    }
}
void ivy::ifst::__t::flat  (ivy::flatst::__t &st,ivy::ptr< ivy::stmt::__t > &res) const
{
    ivy::ifst::__t t;
    (*this) . flat_int (st,t);
    t . ann = (*this) . ann;
    res = t;
}
void ivy::ifst::__t::flat_int  (ivy::flatst::__t &st,ivy::ifst::__t &res) const
{
    res = (*this);
    res . cond -> flat (st,res . cond);
    res . thenst -> flat (st,res . thenst);
    res . elsest -> flat (st,res . elsest);
}
void ivy::whilest::__t::flat  (ivy::flatst::__t &st,ivy::ptr< ivy::stmt::__t > &res) const
{
    ivy::whilest::__t t;
    (*this) . flat_int (st,t);
    t . ann = (*this) . ann;
    res = t;
}
void ivy::whilest::__t::flat_int  (ivy::flatst::__t &st,ivy::whilest::__t &res) const
{
    res = (*this);
    res . cond -> flat (st,res . cond);
    res . body -> flat (st,res . body);
}
void ivy::flat_formal  (const ivy::ptr< ivy::expr::__t > &s,ivy::flatst::__t &st,ivy::ptr< ivy::expr::__t >
    &res)
{
    res = s;
    if (res -> is (ivy::verb::__t (ivy::verb::colon)))
    {
        ivy::ptr< ivy::expr::__t > ty;
        res -> get_arg (vector__ivy__expr::domain::__t (1)) -> flat (st,ty);
        res =
            ivy::colon::make (res -> get_arg (vector__ivy__expr::domain::__t (0)),ty,res -> get_ann());
    }
}
ivy::ptr< ivy::ident::__t > ivy::formal_ident  (const ivy::ptr< ivy::expr::__t > &s)
{
    ivy::ptr< ivy::ident::__t > res;
    res = s -> is (ivy::verb::__t (ivy::verb::colon)) ?
        s -> get_arg (vector__ivy__expr::domain::__t (0)) -> get_name() : s -> get_name();
    return res;
}
void ivy::varst::__t::flat  (ivy::flatst::__t &st,ivy::ptr< ivy::stmt::__t > &res) const
{
    ivy::varst::__t t;
    (*this) . flat_int (st,t);
    t . ann = (*this) . ann;
    res = t;
}
void ivy::varst::__t::flat_int  (ivy::flatst::__t &st,ivy::varst::__t &res) const
{
    res = (*this);
    ivy::flat_formal (res . name,st,res . name);
}
ivy::ptr< ivy::ident::__t > ivy::varst::__t::get_ident () const
{
    ivy::ptr< ivy::ident::__t > res;
    res = ivy::formal_ident ((*this) . name);
    return res;
}
void ivy::decl::__t::flat  (ivy::flatst::__t &st) const {}
void ivy::decl::__t::defd  (ivy::flatst::__t &st) const {}
void ivy::flat_exprvec  (vector__ivy__expr::__t &es,ivy::flatst::__t &st)
{
    vector__ivy__expr::domain::__t idx;
    idx = es . begin();
    while (idx < es . end)
    {
        ivy::ptr< ivy::expr::__t > e;
        e = es . value (idx);
        {
            ivy::ptr< ivy::expr::__t > __tmp2;
            e -> flat (st,__tmp2);
            e = __tmp2;
        }
        es . set (idx,e);
        idx = idx . next();
    }
}
void ivy::flat_formalvec  (vector__ivy__expr::__t &es,ivy::flatst::__t &st)
{
    vector__ivy__expr::domain::__t idx;
    idx = es . begin();
    while (idx < es . end)
    {
        ivy::ptr< ivy::expr::__t > e;
        e = es . value (idx);
        {
            ivy::ptr< ivy::expr::__t > __tmp3;
            ivy::flat_formal (e,st,__tmp3);
            e = __tmp3;
        }
        es . set (idx,e);
        idx = idx . next();
    }
}
void ivy::local_vec  (const vector__ivy__expr::__t &es,const __bool &val,ivy::flatst::__t &st)
{
    vector__ivy__expr::domain::__t idx;
    idx = es . begin();
    while (idx < es . end)
    {
        ivy::ptr< ivy::expr::__t > e;
        e = es . value (idx);
        ivy::ptr< ivy::ident::__t > fe;
        fe = ivy::formal_ident (e);
        if (val) {
            st . locals . set (fe,ivy::native_bool (true));
        } else {
            st . locals . remove (fe);
        }
        idx = idx . next();
    }
}
void ivy::actdc::__t::flat  (ivy::flatst::__t &st) const
{
    ivy::actdc::__t t;
    (*this) . flat_int (st,t);
    t . ann = (*this) . ann;
    st . decls . append (t);
}
void ivy::actdc::__t::flat_int  (ivy::flatst::__t &st,ivy::actdc::__t &res) const
{
    if ((*this) . kind == ivy::action_kind::__t (ivy::action_kind::external))
    {
        st . absolute = ivy::native_bool (true);
    }
    (*this) . name -> flat (st,res . name);
    st . absolute = ivy::native_bool (false);
    res . kind = (*this) . kind;
    {
        res . inputs = (*this) . inputs;
        ivy::flat_formalvec (res . inputs,st);
    }
    {
        res . outputs = (*this) . outputs;
        ivy::flat_formalvec (res . outputs,st);
    }
    ivy::local_vec (res . inputs,ivy::native_bool (true),st);
    ivy::local_vec (res . outputs,ivy::native_bool (true),st);
    res . has_body = (*this) . has_body;
    (*this) . body -> flat (st,res . body);
    ivy::local_vec (res . inputs,ivy::native_bool (false),st);
    ivy::local_vec (res . outputs,ivy::native_bool (false),st);
}
void ivy::actdc::__t::defd  (ivy::flatst::__t &st) const
{
    if ((*this) . kind == ivy::action_kind::__t (ivy::action_kind::external))
    {
        st . absolute = ivy::native_bool (true);
    }
    ivy::add_def ((*this) . name,st,ivy::native_bool (false),ivy::native_bool (false));
    st . absolute = ivy::native_bool (false);
}
void ivy::initdc::__t::flat  (ivy::flatst::__t &st) const
{
    ivy::initdc::__t t;
    (*this) . flat_int (st,t);
    t . ann = (*this) . ann;
    st . decls . append (t);
}
void ivy::initdc::__t::flat_int  (ivy::flatst::__t &st,ivy::initdc::__t &res) const
{
    (*this) . body -> flat (st,res . body);
}
void ivy::typespec::__t::flat  (ivy::flatst::__t &st,ivy::ptr< ivy::typespec::__t > &res) const {}
void ivy::typespec::__t::defd  (ivy::flatst::__t &st,const ivy::ptr< ivy::ident::__t > &id) const {}
void ivy::typespec::__t::to_destrs  (ivy::flatst::__t &st,const ivy::ptr< ivy::expr::__t > &ty)
    const {}
void ivy::typespec::__t::auto_flat_spec  (ivy::flatst::__t &st,const ivy::ptr< ivy::expr::__t > &ty)
    const {}
void ivy::enumspec::__t::flat  (ivy::flatst::__t &st,ivy::ptr< ivy::typespec::__t > &res) const
{
    ivy::enumspec::__t t;
    t = (*this);
    vector__ivy__expr::domain::__t idx;
    idx = t . constructors . begin();
    while (idx < t . constructors . end)
    {
        ivy::ptr< ivy::expr::__t > e;
        e = t . constructors . value (idx);
        ivy::check_syntax_symbol (e);
        {
            ivy::ptr< ivy::expr::__t > __tmp4;
            e -> flat (st,__tmp4);
            e = __tmp4;
        }
        t . constructors . set (idx,e);
        idx = idx . next();
    }
    res = t;
}
void ivy::enumspec::__t::defd  (ivy::flatst::__t &st,const ivy::ptr< ivy::ident::__t > &id) const
{
    vector__ivy__expr::domain::__t idx;
    idx = (*this) . constructors . begin();
    while (idx < (*this) . constructors . end)
    {
        ivy::add_def ((*this) . constructors . value (idx),st,ivy::native_bool (false),ivy::native_bool
                    (false));
        idx = idx . next();
    }
}
void ivy::canon_typing  (ivy::ptr< ivy::expr::__t > &typing)
{
    if (typing -> is (ivy::verb::__t (ivy::verb::colon)))
    {
        ivy::ptr< ivy::expr::__t > lhs;
        lhs = typing -> get_arg (vector__ivy__expr::domain::__t (0));
        if (lhs . isa< ivy::app::__t >())
        {
            vector__ivy__expr::__t args;
            args = lhs -> get_args();
            vector__ivy__expr::__t dom;
            vector__ivy__expr::domain::__t idx;
            idx = args . begin();
            while (idx < args . end)
            {
                dom . append (args . value (idx) -> get_arg (vector__ivy__expr::domain::__t (1)));
                idx = idx . next();
            }
            ivy::ptr< ivy::expr::__t > domty;
            domty = ivy::times::fold_left (dom,lhs -> get_ann());
            ivy::ptr< ivy::expr::__t > ty;
            ty =
                ivy::arrow::make (domty,typing -> get_arg (vector__ivy__expr::domain::__t (1)),typing
                        -> get_ann());
            typing = ivy::colon::make (lhs -> get_func(),ty -> uncurry(),typing -> get_ann());
        }
    } else
    {
        if (typing . isa< ivy::app::__t >())
        {
            typing = typing -> get_func();
            ivy::canon_typing (typing);
        }
    }
}
void ivy::make_auto_key  (const ivy::ptr< ivy::ident::__t > &id,const __bool &rev,ivy::ptr< ivy::ident::__t >
    &key,ivy::symeval::__t &pmap)
{
    ivy::strident::__t skey;
    skey = id -> get_last();
    vector__ivy__ident::domain::__t idx;
    idx = skey . subscrs . begin();
    pos::__t num;
    num = pos::__t (0);
    while (idx < skey . subscrs . end)
    {
        ivy::ptr< ivy::ident::__t > nv;
        nv = ivy::numident::make (num);
        ivy::ptr< annot::__t > ann;
        if (rev) {
            pmap . set (nv,ivy::symbol::make (skey . subscrs . value (idx),ann));
        } else {
            pmap . set (skey . subscrs . value (idx),ivy::symbol::make (nv,ann));
        }
        skey . subscrs . set (idx,nv);
        idx = idx . next();
        num = num . next();
    }
    key = skey;
    if (id . isa< ivy::dotident::__t >()) {
        key = key -> prefix (id -> get_namesp());
    }
}
void ivy::find_auto_inst  (const ivy::ptr< ivy::ident::__t > &id,const ivy::flatst::__t &st,ivy::instantiatedc::__t
    &idc,__bool &ok)
{
    ivy::ptr< ivy::ident::__t > key;
    ivy::symeval::__t pmap;
    ivy::make_auto_key (id,ivy::native_bool (true),key,pmap);
    if (st . autodefs . mem (key))
    {
        idc = st . autodefs . value (key);
        ivy::ptr< ivy::decl::__t > foo;
        foo = idc;
        ivy::subst_vector (idc . prms,pmap);
        ok = ivy::native_bool (true);
    }
}
void ivy::auto_defd_rec  (const ivy::ptr< ivy::expr::__t > &s,ivy::flatst::__t &st)
{
    if (s -> is (ivy::verb::__t (ivy::verb::dot)))
    {
        ivy::auto_defd_rec (s -> get_arg (vector__ivy__expr::domain::__t (0)),st);
    }
    if (s -> is (ivy::verb::__t (ivy::verb::dot)) | s . isa< ivy::symbol::__t >())
    {
        ivy::ptr< ivy::expr::__t > e;
        st . no_undefined = ivy::native_bool (true);
        s -> flat (st,e);
        st . no_undefined = ivy::native_bool (false);
        ivy::ptr< ivy::ident::__t > id;
        id = e -> get_name();
        if (! st . defs . mem (id))
        {
            __bool ok;
            ivy::instantiatedc::__t idc;
            ivy::find_auto_inst (id,st,idc,ok);
            if (ok)
            {
                st . defs . set (id,ivy::native_bool (true));
                ivy::objectdc::__t odc;
                odc . name = ivy::symbol::make (id,idc . ann);
                odc . ann = idc . ann;
                st . decls . append (odc);
                st . autos_pending . set (id,ivy::native_bool (true));
                __bool old_has_root;
                old_has_root = st . has_root;
                ivy::ptr< ivy::ident::__t > old_root;
                old_root = st . root;
                st . has_root = ivy::native_bool (true);
                st . root = id;
                idc . defd (st);
                st . has_root = old_has_root;
                st . root = old_root;
            }
        }
    }
}
void ivy::auto_defd  (const ivy::ptr< ivy::expr::__t > &s,ivy::flatst::__t &st)
{
    if (s -> is (ivy::verb::__t (ivy::verb::colon)))
    {
        ivy::auto_defd_rec (s -> get_arg (vector__ivy__expr::domain::__t (1)),st);
    }
}
void ivy::auto_flat_rec  (const ivy::ptr< ivy::expr::__t > &s,ivy::flatst::__t &st)
{
    if (s -> is (ivy::verb::__t (ivy::verb::dot)))
    {
        ivy::auto_flat_rec (s -> get_arg (vector__ivy__expr::domain::__t (0)),st);
    }
    if (s -> is (ivy::verb::__t (ivy::verb::dot)) | s . isa< ivy::symbol::__t >())
    {
        ivy::ptr< ivy::expr::__t > e;
        st . no_undefined = ivy::native_bool (true);
        s -> flat (st,e);
        st . no_undefined = ivy::native_bool (false);
        ivy::ptr< ivy::ident::__t > id;
        id = e -> get_name();
        if (st . autos_pending . mem (id))
        {
            st . autos_pending . remove (id);
            __bool ok;
            ivy::instantiatedc::__t idc;
            ivy::find_auto_inst (id,st,idc,ok);
            if (ok)
            {
                __bool old_has_root;
                old_has_root = st . has_root;
                ivy::ptr< ivy::ident::__t > old_root;
                old_root = st . root;
                st . has_root = ivy::native_bool (true);
                st . root = id;
                idc . flat (st);
                st . has_root = old_has_root;
                st . root = old_root;
            }
        }
    }
}
void ivy::auto_flat  (const ivy::ptr< ivy::expr::__t > &s,ivy::flatst::__t &st)
{
    if (s -> is (ivy::verb::__t (ivy::verb::colon)))
    {
        ivy::auto_flat_rec (s -> get_arg (vector__ivy__expr::domain::__t (1)),st);
    }
}
void ivy::structspec::__t::defd  (ivy::flatst::__t &st,const ivy::ptr< ivy::ident::__t > &id) const
{
    vector__ivy__expr::domain::__t idx;
    idx = (*this) . destructors . begin();
    while (idx < (*this) . destructors . end)
    {
        ivy::ptr< ivy::expr::__t > e;
        e = (*this) . destructors . value (idx);
        ivy::auto_defd (e,st);
        ivy::ptr< ivy::expr::__t > lhs;
        lhs = e -> get_arg (vector__ivy__expr::domain::__t (0));
        if (lhs . isa< ivy::app::__t >()) {
            lhs = lhs -> get_func();
        }
        ivy::add_def_id (lhs -> get_name() -> prefix (id),st,ivy::native_bool (false),ivy::native_bool
                    (false),lhs -> get_ann());
        idx = idx . next();
    }
}
void ivy::structspec::__t::auto_flat_spec  (ivy::flatst::__t &st,const ivy::ptr< ivy::expr::__t > &ty)
    const
{
    vector__ivy__expr::domain::__t idx;
    idx = (*this) . destructors . begin();
    while (idx < (*this) . destructors . end)
    {
        ivy::ptr< ivy::expr::__t > e;
        e = (*this) . destructors . value (idx);
        ivy::auto_flat (e,st);
        idx = idx . next();
    }
}
void ivy::structspec::__t::to_destrs  (ivy::flatst::__t &st,const ivy::ptr< ivy::expr::__t > &ty)
    const
{
    vector__ivy__expr::domain::__t idx;
    idx = (*this) . destructors . begin();
    while (idx < (*this) . destructors . end)
    {
        ivy::ptr< ivy::expr::__t > e;
        e = (*this) . destructors . value (idx);
        __bool old_has_root;
        old_has_root = st . has_root;
        ivy::ptr< ivy::ident::__t > old_root;
        old_root = st . root;
        st . root = ty -> get_name();
        st . has_root = ivy::native_bool (true);
        {
            ivy::ptr< ivy::expr::__t > __tmp5;
            e -> flat (st,__tmp5);
            e = __tmp5;
        }
        ivy::check_syntax_typing (e,ivy::native_bool (false));
        st . has_root = old_has_root;
        st . root = old_root;
        ivy::canon_typing (e);
        ivy::ptr< ivy::expr::__t > fty;
        fty = ivy::arrow::make (ty,e -> get_arg (vector__ivy__expr::domain::__t (1)),e -> get_ann());
        ivy::ptr< ivy::expr::__t > typing;
        typing =
            ivy::colon::make (e -> get_arg (vector__ivy__expr::domain::__t (0)),fty -> uncurry(),e
                    -> get_ann());
        ivy::ptr< ivy::decl::__t > dstr;
        dstr =
            ivy::vardc::make (typing,ivy::native_bool (true),e -> get_arg (vector__ivy__expr::domain::__t
                            (0)) -> get_ann());
        st . decls . append (dstr);
        idx = idx . next();
    }
}
ivy::ptr< ivy::expr::__t > ivy::expr::__t::uncurry () const
{
    ivy::ptr< ivy::expr::__t > res;
    {
        vector__ivy__expr::__t dom;
        dom = ivy::times::unfold_left ((*this) . get_arg (vector__ivy__expr::domain::__t (0)));
        ivy::ptr< ivy::expr::__t > rng;
        rng = (*this) . get_arg (vector__ivy__expr::domain::__t (1));
        if (rng -> is (ivy::verb::__t (ivy::verb::arrow)))
        {
            vector__ivy__expr::__t dom2;
            dom2 = ivy::times::unfold_left (rng -> get_arg (vector__ivy__expr::domain::__t (0)));
            dom . extend (dom2);
            rng = rng -> get_arg (vector__ivy__expr::domain::__t (1));
        }
        res =
            ivy::arrow::make (ivy::times::fold_left (dom,(*this) . get_ann()),rng,(*this) . get_ann());
    }
    return res;
}
void ivy::check_syntax_symbol  (const ivy::ptr< ivy::expr::__t > &e)
{
    if (! e . isa< ivy::symbol::__t >())
    {
        ivy::report_error (ivy::bad_syntax::make (e),e -> get_ann());
    }
}
void ivy::typedc::__t::flat  (ivy::flatst::__t &st) const
{
    ivy::typedc::__t res;
    res = (*this);
    (*this) . sort -> flat (st,res . sort);
    res . has_super = (*this) . has_super;
    if (res . has_super)
    {
        (*this) . super -> flat (st,res . super);
        ivy::check_syntax_symbol (res . super);
    }
    if (res . has_spec)
    {
        if ((*this) . spec . isa< ivy::structspec::__t >())
        {
            res . has_spec = ivy::native_bool (false);
        } else {
            (*this) . spec -> flat (st,res . spec);
        }
    }
    if ((*this) . has_spec) {
        (*this) . spec -> auto_flat_spec (st,res . sort);
    }
    st . decls . append (res);
    if ((*this) . has_spec) {
        (*this) . spec -> to_destrs (st,res . sort);
    }
}
void ivy::typedc::__t::defd  (ivy::flatst::__t &st) const
{
    ivy::add_def ((*this) . sort,st,ivy::native_bool (false),ivy::native_bool (false));
    if ((*this) . has_spec)
    {
        st . defining = ivy::native_bool (true);
        ivy::ptr< ivy::ident::__t > id;
        id = (*this) . sort -> get_name() -> flat (ivy::native_bool (false),st);
        st . defining = ivy::native_bool (false);
        (*this) . spec -> defd (st,id);
    }
}
ivy::ptr< ivy::expr::__t > ivy::get_typed_symbol  (const ivy::ptr< ivy::expr::__t > &typing)
{
    ivy::ptr< ivy::expr::__t > res;
    if (typing . isa< ivy::app::__t >())
    {
        if (typing -> is (ivy::verb::__t (ivy::verb::colon)))
        {
            res = ivy::get_typed_symbol (typing -> get_arg (vector__ivy__expr::domain::__t (0)));
        } else
        {
            if (typing -> is (ivy::verb::__t (ivy::verb::dot))) {
                res = typing;
            } else {
                res = ivy::get_typed_symbol (typing -> get_func());
            }
        }
    } else {
        res = typing;
    }
    return res;
}
void ivy::is_typing_lhs_syntax  (const ivy::ptr< ivy::expr::__t > &lhs,__bool &res,ivy::ptr< ivy::expr::__t >
    &bad)
{
    res = ivy::native_bool (false);
    bad = lhs;
    if (lhs . isa< ivy::symbol::__t >()) {
        res = ivy::native_bool (true);
    } else
    {
        if (lhs . isa< ivy::app::__t >())
        {
            if (lhs -> get_func() . isa< ivy::symbol::__t >())
            {
                res = ivy::native_bool (true);
                vector__ivy__expr::__t args;
                args = lhs -> get_args();
                vector__ivy__expr::domain::__t idx;
                idx = args . begin();
                while (res & idx < args . end)
                {
                    bad = args . value (idx);
                    if (! bad -> is (ivy::verb::__t (ivy::verb::colon)))
                    {
                        res = ivy::native_bool (false);
                    } else
                    {
                        ivy::ptr< ivy::expr::__t > v;
                        v = bad -> get_arg (vector__ivy__expr::domain::__t (0));
                        if (!
                        (v . isa< ivy::symbol::__t >() & v -> get_verb() ==
                            ivy::verb::__t (ivy::verb::logvar) &
                            bad -> get_arg (vector__ivy__expr::domain::__t (1)) . isa< ivy::symbol::__t >()))
                        {
                            res = ivy::native_bool (false);
                        }
                    }
                    idx = idx . next();
                }
            }
        }
    }
}
void ivy::is_typing_rhs_syntax  (const ivy::ptr< ivy::expr::__t > &rhs,__bool &res,ivy::ptr< ivy::expr::__t >
    &bad)
{
    res = ivy::native_bool (false);
    bad = rhs;
    if (rhs . isa< ivy::symbol::__t >()) {
        res = ivy::native_bool (true);
    } else
    {
        if (rhs -> is (ivy::verb::__t (ivy::verb::arrow)))
        {
            res = ivy::native_bool (true);
            vector__ivy__expr::__t dom;
            dom = ivy::times::unfold_left (rhs -> get_arg (vector__ivy__expr::domain::__t (0)));
            vector__ivy__expr::domain::__t idx;
            idx = dom . begin();
            while (res & idx < dom . end)
            {
                bad = dom . value (idx);
                if (! bad . isa< ivy::symbol::__t >()) {
                    res = ivy::native_bool (false);
                }
                idx = idx . next();
            }
            if (res & !
            rhs -> get_arg (vector__ivy__expr::domain::__t (1)) . isa< ivy::symbol::__t >())
            {
                res = ivy::native_bool (false);
                bad = rhs -> get_arg (vector__ivy__expr::domain::__t (1));
            }
        } else {
            bad = rhs;
        }
    }
}
void ivy::check_syntax_typing  (const ivy::ptr< ivy::expr::__t > &typing,const __bool &has_def)
{
    __bool ok;
    ivy::ptr< ivy::expr::__t > bad;
    if (typing -> is (ivy::verb::__t (ivy::verb::colon)))
    {
        ivy::is_typing_lhs_syntax (typing -> get_arg (vector__ivy__expr::domain::__t (0)),ok,bad);
        if (ok)
        {
            if (typing -> get_arg (vector__ivy__expr::domain::__t (1)) -> is (ivy::verb::__t (ivy::verb::arrow))
            & ! typing -> get_arg (vector__ivy__expr::domain::__t (0)) . isa< ivy::symbol::__t >())
            {
                ok = ivy::native_bool (false);
                bad = typing -> get_arg (vector__ivy__expr::domain::__t (1));
            } else
            {
                ivy::is_typing_rhs_syntax (typing -> get_arg (vector__ivy__expr::domain::__t (1)),ok,bad);
            }
        }
    } else
    {
        if (has_def) {
            ivy::is_typing_lhs_syntax (typing,ok,bad);
        } else {
            ok = ivy::native_bool (false);
            bad = typing;
        }
    }
    if (! ok) {
        ivy::report_error (ivy::bad_syntax::make (bad),bad -> get_ann());
    }
}
void ivy::vardc::__t::flat  (ivy::flatst::__t &st) const
{
    ivy::vardc::__t t;
    (*this) . flat_int (st,t);
    t . ann = (*this) . ann;
    st . decls . append (t);
}
void ivy::vardc::__t::flat_int  (ivy::flatst::__t &st,ivy::vardc::__t &res) const
{
    ivy::auto_flat ((*this) . typing,st);
    res . is_destructor = (*this) . is_destructor;
    (*this) . typing -> flat (st,res . typing);
    res . has_def = (*this) . has_def;
    ivy::check_syntax_typing (res . typing,res . has_def);
    if (res . has_def) {
        (*this) . def -> flat (st,res . def);
    } else {
        ivy::canon_typing (res . typing);
    }
}
void ivy::vardc::__t::defd  (ivy::flatst::__t &st) const
{
    ivy::auto_defd ((*this) . typing,st);
    ivy::add_def (ivy::get_typed_symbol ((*this) . typing),st,ivy::native_bool (true),ivy::native_bool
                (false));
}
void ivy::header::__t::flat  (ivy::flatst::__t &st) const
{
    ivy::header::__t t;
    (*this) . flat_int (st,t);
    t . ann = (*this) . ann;
    st . decls . append (t);
}
void ivy::header::__t::flat_int  (ivy::flatst::__t &st,ivy::header::__t &res) const
{
    res . filename = (*this) . filename;
}
void ivy::interpdc::__t::flat  (ivy::flatst::__t &st) const
{
    ivy::interpdc::__t t;
    (*this) . flat_int (st,t);
    t . ann = (*this) . ann;
    st . decls . append (t);
}
void ivy::interpdc::__t::flat_int  (ivy::flatst::__t &st,ivy::interpdc::__t &res) const
{
    (*this) . itype -> flat (st,res . itype);
    ivy::check_syntax_symbol (res . itype);
    st . absolute = ivy::native_bool (true);
    (*this) . ctype -> flat (st,res . ctype);
    ivy::check_syntax_symbol (res . ctype);
    st . absolute = ivy::native_bool (false);
}
void ivy::check_syntax_symbol_vec  (const vector__ivy__expr::__t &s)
{
    vector__ivy__expr::domain::__t idx;
    idx = s . begin();
    while (idx < s . end) {
        ivy::check_syntax_symbol (s . value (idx));
        idx = idx . next();
    }
}
void ivy::moduledc::__t::defd  (ivy::flatst::__t &st) const
{
    ivy::ptr< ivy::expr::__t > name;
    st . defining = ivy::native_bool (true);
    (*this) . name -> flat (st,name);
    vector__ivy__expr::domain::__t idx;
    idx = (*this) . prms . begin();
    ivy::check_syntax_symbol_vec ((*this) . prms);
    st . defining = ivy::native_bool (false);
    st . moddecls . set (name -> get_name(),(*this));
    ivy::add_def ((*this) . name,st,ivy::native_bool (false),ivy::native_bool (false));
}
void ivy::instantiatedc::__t::setup  (ivy::flatst::__t &st,const __bool &check,ivy::moduledc::__t &mod)
    const
{
    ivy::ptr< ivy::expr::__t > name;
    vector__ivy__expr::__t prms;
    (*this) . name -> flat (st,name);
    {
        prms = (*this) . prms;
        ivy::flat_exprvec (prms,st);
    }
    if (check) {
        ivy::check_syntax_symbol (name);
        ivy::check_syntax_symbol_vec (prms);
    }
    if (name . isa< ivy::symbol::__t >())
    {
        mod = st . moddecls . get_def (name -> get_name(),(*this) . ann);
        st . prmvals = ivy::prm_map (mod . prms,prms,(*this) . ann);
    }
}
void ivy::instantiatedc::__t::flat  (ivy::flatst::__t &st) const
{
    ivy::moduledc::__t mod;
    ivy::ident_to_ident::__t old_prmvals;
    old_prmvals = st . prmvals;
    (*this) . setup (st,ivy::native_bool (true),mod);
    mod . body -> flat (st);
    st . prmvals = old_prmvals;
}
void ivy::instantiatedc::__t::defd  (ivy::flatst::__t &st) const
{
    ivy::moduledc::__t mod;
    ivy::ident_to_ident::__t old_prmvals;
    old_prmvals = st . prmvals;
    (*this) . setup (st,ivy::native_bool (false),mod);
    mod . body -> defd (st);
    st . prmvals = old_prmvals;
}
void ivy::set_root  (ivy::flatst::__t &st,const ivy::ptr< ivy::expr::__t > &s)
{
    ivy::ptr< ivy::expr::__t > root;
    s -> flat (st,root);
    st . root = root -> get_name();
    st . has_root = ivy::native_bool (true);
}
void ivy::objectdc::__t::flat  (ivy::flatst::__t &st) const
{
    __bool old_has_root;
    old_has_root = st . has_root;
    ivy::ptr< ivy::ident::__t > old_root;
    old_root = st . root;
    ivy::set_root (st,(*this) . name);
    ivy::objectdc::__t odc;
    odc . name = ivy::symbol::make (st . root,(*this) . name -> get_ann());
    odc . ann = (*this) . ann;
    st . decls . append (odc);
    (*this) . body -> flat (st);
    st . has_root = old_has_root;
    st . root = old_root;
}
void ivy::objectdc::__t::defd  (ivy::flatst::__t &st) const
{
    ivy::add_def ((*this) . name,st,ivy::native_bool (false),ivy::native_bool (true));
    __bool old_has_root;
    old_has_root = st . has_root;
    ivy::ptr< ivy::ident::__t > old_root;
    old_root = st . root;
    ivy::set_root (st,(*this) . name);
    (*this) . body -> defd (st);
    st . has_root = old_has_root;
    st . root = old_root;
}
void ivy::auto_instance_defd  (const ivy::instancedc::__t &s,ivy::flatst::__t &st)
{
    st . defining = ivy::native_bool (true);
    ivy::ptr< ivy::ident::__t > id;
    id = s . objname -> get_name() -> flat (ivy::native_bool (false),st);
    st . defining = ivy::native_bool (false);
    ivy::symeval::__t pmap;
    ivy::ptr< ivy::ident::__t > key;
    ivy::make_auto_key (id,ivy::native_bool (false),key,pmap);
    vector__ivy__expr::__t prms;
    {
        vector__ivy__expr::domain::__t idx;
        idx = s . prms . begin();
        while (idx < s . prms . end)
        {
            {
                ivy::ptr< ivy::expr::__t > __tmp6;
                __tmp6 = s . prms . value (idx);
                pmap . get (s . prms . value (idx) -> get_name(),__tmp6);
                prms . append (__tmp6);
            }
            idx = idx . next();
        }
    }
    ivy::instantiatedc::__t body;
    body . ann = s . ann;
    body . name = s . modname;
    body . prms = prms;
    st . autodefs . set (key,body);
}
ivy::ptr< ivy::decl::__t > ivy::instancedc::__t::desugar () const
{
    ivy::ptr< ivy::decl::__t > res;
    {
        ivy::ptr< ivy::decl::__t > body;
        body = ivy::instantiatedc::make ((*this) . modname,(*this) . prms,(*this) . ann);
        res = ivy::objectdc::make ((*this) . objname,body,(*this) . ann);
    }
    return res;
}
void ivy::instancedc::__t::flat  (ivy::flatst::__t &st) const
{
    if (! (*this) . is_auto)
    {
        ivy::ptr< ivy::decl::__t > ds;
        ds = (*this) . desugar();
        ds -> flat (st);
    }
}
void ivy::instancedc::__t::defd  (ivy::flatst::__t &st) const
{
    if ((*this) . is_auto) {
        ivy::auto_instance_defd ((*this),st);
    } else {
        ivy::ptr< ivy::decl::__t > ds;
        ds = (*this) . desugar();
        ds -> defd (st);
    }
}
void ivy::groupdc::__t::flat  (ivy::flatst::__t &st) const
{
    vector__ivy__decl::domain::__t idx;
    idx = (*this) . decls . begin();
    while (idx < (*this) . decls . end)
    {
        (*this) . decls . value (idx) -> flat (st);
        idx = idx . next();
    }
    {}
}
void ivy::groupdc::__t::defd  (ivy::flatst::__t &st) const
{
    vector__ivy__decl::domain::__t idx;
    idx = (*this) . decls . begin();
    while (idx < (*this) . decls . end)
    {
        (*this) . decls . value (idx) -> defd (st);
        idx = idx . next();
    }
    {}
}
void ivy::prog::__t::flat ()
{
    ivy::flatst::__t st;
    
    // A pass to record all the defined identifiers, We need to
    // know which identifiers are defined to determine the
    // scope of an object reference and to disambiguate
    // hierarchical names from "dot" operators.
    
    vector__ivy__decl::domain::__t idx;
    idx = (*this) . decls . begin();
    while (idx < (*this) . decls . end)
    {
        (*this) . decls . value (idx) -> defd (st);
        idx = idx . next();
    }
    
    // A pass to flatten. This pass expands module
    // instantiations and expands hieracharical names of object
    // members, so that all declarations are in global scope.
    // Object declarations remain, but their bodies are empty.
    
    idx = (*this) . decls . begin();
    while (idx < (*this) . decls . end)
    {
        (*this) . decls . value (idx) -> flat (st);
        idx = idx . next();
    }
    (*this) . decls = st . decls;
}
ivy::ident_to_exprs::__t ivy::ident_to_exprs::empty () {
    ivy::ident_to_exprs::__t a;
    {}
    return a;
}
void ivy::ident_to_exprs::__t::add  (const ivy::ptr< ivy::ident::__t > &x,const ivy::ptr< ivy::expr::__t >
    &y) {
    (*this) . value (x) . append (y);
}
vector__ivy__expr::__t ivy::ident_to_exprs::__t::get  (const ivy::ptr< ivy::ident::__t > &x) const
{
    vector__ivy__expr::__t res;
    res = (*this) . value (x);
    return res;
}
__bool ivy::ident_to_exprs::__t::mem  (const ivy::ptr< ivy::ident::__t > &x) const
{
    __bool res;
    res = (*this) . value (x) . end > vector__ivy__expr::domain::__t (0);
    return res;
}
__bool ivy::subtypes::__t::is_subtype  (const ivy::ptr< ivy::expr::__t > &sub,const ivy::ptr< ivy::expr::__t >
    &super) const
{
    __bool res;
    if (sub . isa< ivy::symbol::__t >())
    {
        ivy::ptr< ivy::ident::__t > name;
        name = sub -> get_name();
        if ((*this) . supertype_of . mem (name))
        {
            res = (*this) . supertype_of . value (name) -> get_name() == super -> get_name();
        }
    }
    return res;
}
ivy::subtypes::__t ivy::prog::__t::get_subtypes () const
{
    ivy::subtypes::__t s;
    {
        vector__ivy__decl::domain::__t idx;
        idx = (*this) . decls . begin();
        while (idx < (*this) . decls . end)
        {
            (*this) . decls . value (idx) -> build_subtypes (s);
            idx = idx . next();
        }
    }
    return s;
}
void ivy::decl::__t::build_subtypes  (ivy::subtypes::__t &st) const {}
void ivy::typedc::__t::build_subtypes  (ivy::subtypes::__t &st) const
{
    if ((*this) . has_super)
    {
        st . subtypes_of . add ((*this) . super -> get_name(),(*this) . sort);
        st . supertype_of . set ((*this) . sort -> get_name(),(*this) . super);
    }
}
ivy::global_types::__t ivy::prog::__t::get_global_types  (const __bool &curried) const
{
    ivy::global_types::__t s;
    {
        s . curried = curried;
        vector__ivy__decl::domain::__t idx;
        idx = (*this) . decls . begin();
        while (idx < (*this) . decls . end)
        {
            (*this) . decls . value (idx) -> build_global_types (s);
            idx = idx . next();
        }
    }
    return s;
}
void ivy::decl::__t::build_global_types  (ivy::global_types::__t &st) const {}
__bool ivy::is_typing_complete  (const ivy::ptr< ivy::expr::__t > &typing)
{
    __bool res;
    if (typing -> is (ivy::verb::__t (ivy::verb::colon)))
    {
        ivy::ptr< ivy::expr::__t > lhs;
        lhs = typing -> get_arg (vector__ivy__expr::domain::__t (0));
        if (lhs . isa< ivy::symbol::__t >()) {
            res = ivy::native_bool (true);
        } else
        {
            if (lhs . isa< ivy::app::__t >())
            {
                if (lhs -> get_func() -> is (ivy::verb::__t (ivy::verb::colon)))
                {
                    res = ivy::native_bool (true);
                } else
                {
                    res = ivy::native_bool (true);
                    vector__ivy__expr::__t args;
                    args = lhs -> get_args();
                    vector__ivy__expr::domain::__t idx;
                    idx = args . begin();
                    while (idx < args . end)
                    {
                        if (! args . value (idx) -> is (ivy::verb::__t (ivy::verb::colon)))
                        {
                            res = ivy::native_bool (false);
                        }
                        idx = idx . next();
                    }
                }
            }
        }
    } else
    {
        if (typing . isa< ivy::app::__t >())
        {
            if (typing -> get_func() -> is (ivy::verb::__t (ivy::verb::colon)))
            {
                res = ivy::native_bool (true);
            }
        }
    }
    return res;
}
void ivy::vardc::__t::build_global_types  (ivy::global_types::__t &st) const
{
    if (ivy::is_typing_complete ((*this) . typing))
    {
        ivy::ptr< ivy::expr::__t > typing;
        {
            typing = (*this) . typing;
            ivy::canon_typing (typing);
        }
        str::__t thing;
        thing = typing -> enc();
        ivy::ptr< ivy::expr::__t > ty;
        ty = typing -> get_arg (vector__ivy__expr::domain::__t (1));
        ivy::ptr< ivy::ident::__t > id;
        id = typing -> get_arg (vector__ivy__expr::domain::__t (0)) -> get_name();
        if ((*this) . is_destructor & st . curried)
        {
            ty = ty -> curry();
            st . is_destructor (id) = ivy::native_bool (true);
        }
        st . type_of . set (id,ty);
    }
}
ivy::ptr< ivy::expr::__t > ivy::get_formal_type  (const vector__ivy__expr::__t &typings,const ivy::ptr< annot::__t >
    &ann)
{
    ivy::ptr< ivy::expr::__t > res;
    if (typings . end == vector__ivy__expr::domain::__t (0)) {
        res = ivy::empty::make (ann);
    } else
    {
        vector__ivy__expr::__t tys;
        vector__ivy__expr::domain::__t idx;
        idx = typings . begin();
        while (idx < typings . end)
        {
            ivy::ptr< ivy::expr::__t > ty;
            ty = typings . value (idx) -> get_arg (vector__ivy__expr::domain::__t (1));
            tys . append (ty);
            idx = idx . next();
        }
        res = ivy::times::fold_left (tys,ann);
    }
    return res;
}
void ivy::typedc::__t::build_global_types  (ivy::global_types::__t &st) const
{
    if ((*this) . has_spec)
    {
        if ((*this) . spec . isa< ivy::enumspec::__t >())
        {
            ivy::ptr< ivy::decl::__t > foobar;
            foobar = (*this);
            vector__ivy__expr::__t conss;
            conss = (*this) . spec -> get_elems();
            vector__ivy__expr::domain::__t idx;
            idx = conss . begin();
            while (idx < conss . end)
            {
                st . type_of . set (conss . value (idx) -> get_name(),(*this) . sort);
                idx = idx . next();
            }
        }
    }
}
void ivy::actdc::__t::build_global_types  (ivy::global_types::__t &st) const
{
    ivy::ptr< ivy::expr::__t > ty;
    ty = ivy::get_formal_type ((*this) . outputs,(*this) . ann);
    if ((*this) . inputs . end > vector__ivy__expr::domain::__t (0))
    {
        ivy::ptr< ivy::expr::__t > inpty;
        inpty = ivy::get_formal_type ((*this) . inputs,(*this) . ann);
        ty = ivy::arrow::make (inpty,ty,(*this) . ann);
    }
    if ((*this) . is_member() & st . curried) {
        ty = ty -> curry();
    }
    st . type_of . set ((*this) . name -> get_name(),ty);
    st . is_action . set ((*this) . name -> get_name(),ivy::native_bool (true));
}
__bool ivy::is_virtual_action  (const ivy::actdc::__t &s,const ivy::global_types::__t &gl,const ivy::subtypes::__t
    &st)
{
    __bool res;
    {
        ivy::ptr< ivy::ident::__t > tyid;
        tyid = s . name -> get_name() -> get_namesp();
        ivy::ptr< ivy::ident::__t > memid;
        memid = s . name -> get_name() -> get_member();
        if (st . subtypes_of . mem (tyid))
        {
            vector__ivy__expr::__t subtys;
            subtys = st . subtypes_of . value (tyid);
            vector__ivy__expr::domain::__t idx;
            idx = subtys . begin();
            while (! res & idx < subtys . end)
            {
                if (gl . is_action . mem (memid -> prefix (subtys . value (idx) -> get_name())))
                {
                    res = ivy::native_bool (true);
                }
                idx = idx . next();
            }
        }
        if (! res & st . supertype_of . mem (tyid))
        {
            if (gl . is_action . mem (memid -> prefix (st . supertype_of . value (tyid) -> get_name())))
            {
                res = ivy::native_bool (true);
            }
        }
    }
    return res;
}
__bool ivy::prototype::__t::any_non_const_ref () const
{
    __bool res;
    {
        vector__ivy__prototype_argument::domain::__t idx;
        idx = (*this) . args . begin();
        while (! res & idx < (*this) . args . end)
        {
            ivy::prototype_argument::__t arg;
            arg = (*this) . args . value (idx);
            res = arg . is_ref & ! arg . is_const;
            idx = idx . next();
        }
    }
    return res;
}
ivy::param_map::__t ivy::param_map::empty () {
    ivy::param_map::__t a;
    {}
    return a;
}
void ivy::param_map::__t::set  (const ivy::ptr< ivy::ident::__t > &x,const vector__ivy__expr::domain::__t
    &y) {
    ivy::param_map::rec z;
    z . full = ivy::native_bool (true);
    z . val = y;
    (*this) . map (x) = z;
}
void ivy::param_map::__t::get  (const ivy::ptr< ivy::ident::__t > &x,vector__ivy__expr::domain::__t
    &y) const {
    ivy::param_map::rec z;
    z = (*this) . map (x);
    if (z . full) {
        y = z . val;
    }
}
__bool ivy::param_map::__t::mem  (const ivy::ptr< ivy::ident::__t > &x) const
{
    __bool res;
    res = (*this) . map (x) . full;
    return res;
}
void ivy::param_map::__t::remove  (const ivy::ptr< ivy::ident::__t > &x)
{
    ivy::param_map::rec z;
    (*this) . map (x) = z;
}
vector__ivy__expr::domain::__t ivy::param_map::__t::value  (const ivy::ptr< ivy::ident::__t > &x)
    const {
    vector__ivy__expr::domain::__t y;
    y = (*this) . map (x) . val;
    return y;
}
ivy::param_map::__t ivy::param_set  (const vector__ivy__expr::__t &ps)
{
    ivy::param_map::__t res;
    {
        vector__ivy__expr::domain::__t idx;
        idx = ps . begin();
        while (idx < ps . end)
        {
            res . set (ps . value (idx) -> get_arg (vector__ivy__expr::domain::__t (0)) -> get_name(),idx);
            idx = idx . next();
        }
    }
    return res;
}
ivy::prototype::__t ivy::actdc::__t::get_proto  (const ivy::global_types::__t &gl,const ivy::subtypes::__t
    &st) const
{
    ivy::prototype::__t res;
    if ((*this) . has_proto) {
        res = (*this) . proto;
    } else
    {
        ivy::param_map::__t inps;
        inps = ivy::param_set ((*this) . inputs);
        ivy::param_map::__t outs;
        outs = ivy::param_set ((*this) . outputs);
        vector__ivy__expr::domain::__t idx;
        idx = (*this) . inputs . begin();
        ivy::root_mod_ref::__t mods;
        if ((*this) . has_body) {
            (*this) . body -> mod_roots (mods);
        }
        __bool is_member;
        is_member = (*this) . is_member();
        while (idx < (*this) . inputs . end)
        {
            ivy::prototype_argument::__t arg;
            arg . name = (*this) . inputs . value (idx);
            ivy::ptr< ivy::ident::__t > id;
            id = arg . name -> get_arg (vector__ivy__expr::domain::__t (0)) -> get_name();
            arg . is_input = ivy::native_bool (true);
            arg . inpos = idx;
            arg . is_output = outs . mem (id);
            arg . is_ref = ivy::native_bool (true);
            if (arg . is_output) {
                arg . outpos = outs . value (id);
            } else
            {
                if (mods . mod . mem (id))
                {
                    if (is_member)
                    {
                        if (ivy::is_virtual_action ((*this),gl,st))
                        {
                            arg . is_const = ivy::native_bool (true);
                            arg . is_copy = ivy::native_bool (true);
                        } else
                        {
                            if (idx != vector__ivy__expr::domain::__t (0))
                            {
                                arg . is_ref = ivy::native_bool (false);
                            }
                        }
                    } else {
                        arg . is_ref = ivy::native_bool (false);
                    }
                } else {
                    arg . is_const = ivy::native_bool (true);
                }
            }
            res . args . append (arg);
            idx = idx . next();
        }
        if ((*this) . outputs . end == vector__ivy__expr::domain::__t (1) & !
        inps . mem ((*this) . outputs . value (vector__ivy__expr::domain::__t (0)) -> get_arg (vector__ivy__expr::domain::__t
                        (0)) -> get_name()))
        {
            res . has_ret = ivy::native_bool (true);
            res . ret . name = (*this) . outputs . value (vector__ivy__expr::domain::__t (0));
            res . ret . is_output = ivy::native_bool (true);
            res . ret . outpos = vector__ivy__expr::domain::__t (0);
        } else
        {
            idx = vector__ivy__expr::domain::__t (0);
            while (idx < (*this) . outputs . end)
            {
                ivy::prototype_argument::__t arg;
                arg . name = (*this) . outputs . value (idx);
                ivy::ptr< ivy::ident::__t > id;
                id = arg . name -> get_arg (vector__ivy__expr::domain::__t (0)) -> get_name();
                if (! inps . mem (id))
                {
                    arg . is_output = ivy::native_bool (true);
                    arg . outpos = idx;
                    arg . is_ref = ivy::native_bool (true);
                    res . args . append (arg);
                }
                idx = idx . next();
            }
        }
    }
    return res;
}
ivy::ptr< ivy::expr::__t > ivy::expr::__t::curry () const
{
    ivy::ptr< ivy::expr::__t > res;
    {
        vector__ivy__expr::__t dom;
        dom = ivy::times::unfold_left ((*this) . get_arg (vector__ivy__expr::domain::__t (0)));
        vector__ivy__expr::__t dom2;
        dom2 = dom . segment (vector__ivy__expr::domain::__t (1),dom . end);
        ivy::ptr< ivy::expr::__t > rng;
        rng = (*this) . get_arg (vector__ivy__expr::domain::__t (1));
        ivy::ptr< ivy::expr::__t > ty2;
        ty2 = dom2 . end == vector__ivy__expr::domain::__t (0) ? rng :
            ivy::arrow::make (ivy::times::fold_left (dom2,(*this) . get_arg (vector__ivy__expr::domain::__t
                                (0)) -> get_ann()),rng,(*this) . get_ann());
        res =
            ivy::arrow::make (dom . value (vector__ivy__expr::domain::__t (0)),ty2,(*this) . get_ann()
                    -> strip());
    }
    return res;
}
ivy::ptr< ivy::expr::__t > ivy::uncurry_func  (const ivy::ptr< ivy::expr::__t > &func)
{
    ivy::ptr< ivy::expr::__t > res;
    {
        ivy::ptr< ivy::expr::__t > ty;
        ty =
            func -> get_arg (vector__ivy__expr::domain::__t (1)) -> get_arg (vector__ivy__expr::domain::__t
                    (0));
        ivy::ptr< ivy::ident::__t > fid;
        fid =
            func -> get_arg (vector__ivy__expr::domain::__t (0)) -> get_name() -> prefix (ty ->
                    get_name());
        ivy::ptr< ivy::expr::__t > sym;
        sym = ivy::symbol::make (fid,func -> get_ann());
        res =
            ivy::colon::make (sym,func -> get_arg (vector__ivy__expr::domain::__t (1)) -> uncurry(),func
                    -> get_ann());
    }
    return res;
}
ivy::ptr< ivy::expr::__t > ivy::get_dom0  (const ivy::ptr< ivy::expr::__t > &ty)
{
    ivy::ptr< ivy::expr::__t > res;
    {
        res = ty -> get_arg (vector__ivy__expr::domain::__t (0));
        __bool b;
        b = res -> is (ivy::verb::__t (ivy::verb::times));
        while (b)
        {
            res = res -> get_arg (vector__ivy__expr::domain::__t (0));
            b = res -> is (ivy::verb::__t (ivy::verb::times));
        }
        {}
    }
    return res;
}
__bool ivy::func_is_member  (const ivy::ptr< ivy::expr::__t > &func)
{
    __bool res;
    {
        ivy::ptr< ivy::expr::__t > ty;
        ty = func -> get_arg (vector__ivy__expr::domain::__t (1));
        if (ty -> is (ivy::verb::__t (ivy::verb::arrow)))
        {
            ivy::ptr< ivy::ident::__t > fid;
            fid = func -> get_arg (vector__ivy__expr::domain::__t (0)) -> get_name();
            if (fid . isa< ivy::dotident::__t >())
            {
                ivy::ptr< ivy::expr::__t > dom;
                dom = ivy::get_dom0 (ty);
                res = fid -> get_namesp() == dom -> get_name();
            }
        }
    }
    return res;
}
void ivy::get_app  (const ivy::ptr< ivy::expr::__t > &s,ivy::ptr< ivy::expr::__t > &func,vector__ivy__expr::__t
    &args)
{
    if (s -> is (ivy::verb::__t (ivy::verb::dot)))
    {
        ivy::ptr< ivy::expr::__t > lhs;
        lhs = s -> get_arg (vector__ivy__expr::domain::__t (0));
        ivy::ptr< ivy::expr::__t > ty;
        ty = lhs -> get_type();
        func = ivy::uncurry_func (s -> get_arg (vector__ivy__expr::domain::__t (1)));
        args . append (lhs);
    } else
    {
        func = s -> get_func();
        if (func -> is (ivy::verb::__t (ivy::verb::dot)))
        {
            ivy::ptr< ivy::expr::__t > tmp;
            tmp = func;
            ivy::get_app (tmp,func,args);
        }
        args . extend (s -> get_args());
    }
}
__bool ivy::is_functional  (const ivy::ptr< ivy::expr::__t > &s,const ivy::global_types::__t &gl)
{
    __bool res;
    if (s -> is (ivy::verb::__t (ivy::verb::colon)))
    {
        res = ivy::is_functional (s -> get_arg (vector__ivy__expr::domain::__t (0)),gl);
    } else
    {
        if (s . isa< ivy::app::__t >())
        {
            ivy::ptr< ivy::expr::__t > func;
            vector__ivy__expr::__t args;
            ivy::get_app (s,func,args);
            res = ivy::is_functional (func,gl);
            vector__ivy__expr::domain::__t idx;
            idx = args . begin();
            while (res & idx < args . end)
            {
                res = ivy::is_functional (args . value (idx),gl);
                idx = idx . next();
            }
        } else {
            if (s . isa< ivy::symbol::__t >()) {
                res = ! gl . is_action . mem (s -> get_name());
            }
        }
    }
    return res;
}
void ivy::canon_app  (ivy::ptr< ivy::expr::__t > &s)
{
    if (s -> is (ivy::verb::__t (ivy::verb::dot)))
    {
        vector__ivy__expr::__t args;
        {
            ivy::ptr< ivy::expr::__t > __tmp7;
            ivy::get_app (s,__tmp7,args);
            s = __tmp7;
        }
        if (args . end > vector__ivy__expr::domain::__t (0))
        {
            s = ivy::app::make (s,args,s -> get_ann());
        }
    }
}
ivy::push_pop_locals::map_t::__t ivy::push_pop_locals::map_t::empty ()
{
    ivy::push_pop_locals::map_t::__t a;
    {}
    return a;
}
void ivy::push_pop_locals::map_t::__t::set  (const ivy::ptr< ivy::ident::__t > &x,const ivy::local_info::__t
    &y)
{
    ivy::push_pop_locals::map_t::rec z;
    z . full = ivy::native_bool (true);
    z . val = y;
    (*this) . map (x) = z;
}
void ivy::push_pop_locals::map_t::__t::get  (const ivy::ptr< ivy::ident::__t > &x,ivy::local_info::__t
    &y) const {
    ivy::push_pop_locals::map_t::rec z;
    z = (*this) . map (x);
    if (z . full) {
        y = z . val;
    }
}
__bool ivy::push_pop_locals::map_t::__t::mem  (const ivy::ptr< ivy::ident::__t > &x) const
{
    __bool res;
    res = (*this) . map (x) . full;
    return res;
}
void ivy::push_pop_locals::map_t::__t::remove  (const ivy::ptr< ivy::ident::__t > &x)
{
    ivy::push_pop_locals::map_t::rec z;
    (*this) . map (x) = z;
}
ivy::local_info::__t ivy::push_pop_locals::map_t::__t::value  (const ivy::ptr< ivy::ident::__t > &x)
    const {
    ivy::local_info::__t y;
    y = (*this) . map (x) . val;
    return y;
}
pos::__t ivy::push_pop_locals::vec_t::__t::begin () const
{
    pos::__t res;
    res = pos::__t (0);
    return res;
}
ivy::push_pop_locals::vec_t::__t ivy::push_pop_locals::vec_t::empty ()
{
    ivy::push_pop_locals::vec_t::__t res;
    {}
    return res;
}
void ivy::push_pop_locals::vec_t::__t::set  (const pos::__t &i,const ivy::push_pop_locals::undo &v)
{
    (*this) . value (i) = v;
}
void ivy::push_pop_locals::vec_t::__t::append  (const ivy::push_pop_locals::undo &c)
{
    (*this) . value ((*this) . end) = c;
    (*this) . end = (*this) . end . next();
}
void ivy::push_pop_locals::vec_t::__t::extend  (const ivy::push_pop_locals::vec_t::__t &x)
{
    pos::__t idx;
    idx = x . begin();
    while (idx < x . end) {
        (*this) . append (x . value (idx));
        idx = idx . next();
    }
}
void ivy::push_pop_locals::vec_t::__t::resize  (const pos::__t &end)
{
    ivy::resize ((*this) . value,end);
    (*this) . end = end;
}
ivy::push_pop_locals::undo ivy::push_pop_locals::vec_t::__t::back () const
{
    ivy::push_pop_locals::undo y;
    if ((*this) . end > pos::__t (0)) {
        y = (*this) . value ((*this) . end . prev());
    }
    return y;
}
void ivy::push_pop_locals::vec_t::__t::pop_back ()
{
    if ((*this) . end > pos::__t (0))
    {
        pos::__t size;
        size = (*this) . end . prev();
        (*this) . resize (size);
    }
}
ivy::push_pop_locals::vec_t::__t ivy::push_pop_locals::vec_t::__t::segment  (const pos::__t &beg,const
    pos::__t &en) const
{
    ivy::push_pop_locals::vec_t::__t res;
    {
        pos::__t idx;
        idx = beg;
        while (idx < en & idx < (*this) . end)
        {
            res . append ((*this) . value (idx));
            idx = idx . next();
        }
    }
    return res;
}
void ivy::push_pop_locals::vec_t::__t::reverse ()
{
    pos::__t idx;
    idx = (*this) . begin();
    pos::__t jdx;
    jdx = (*this) . end . prev();
    while (idx < jdx)
    {
        ivy::push_pop_locals::undo tmp;
        tmp = (*this) . value (idx);
        (*this) . value (idx) = (*this) . value (jdx);
        (*this) . value (jdx) = tmp;
        jdx = jdx . prev();
        idx = idx . next();
    }
}
void ivy::push_pop_locals::__t::set  (const ivy::ptr< ivy::ident::__t > &id,const ivy::local_info::__t
    &v)
{
    ivy::push_pop_locals::undo und;
    und . id = id;
    und . present = (*this) . map . mem (id);
    if (und . present) {
        und . value = (*this) . map . value (id);
    }
    (*this) . del . append (und);
    (*this) . map . set (id,v);
}
__bool ivy::push_pop_locals::__t::mem  (const ivy::ptr< ivy::ident::__t > &id) const
{
    __bool res;
    res = (*this) . map . mem (id);
    return res;
}
ivy::local_info::__t ivy::push_pop_locals::__t::value  (const ivy::ptr< ivy::ident::__t > &id) const
{
    ivy::local_info::__t res;
    res = (*this) . map . value (id);
    return res;
}
void ivy::push_pop_locals::__t::push () {
    (*this) . stack . append ((*this) . del . end);
}
void ivy::push_pop_locals::__t::pop ()
{
    pos::__t begin;
    begin = (*this) . stack . back();
    (*this) . stack . pop_back();
    while ((*this) . del . end > begin)
    {
        ivy::push_pop_locals::undo x;
        x = (*this) . del . back();
        if (x . present) {
            (*this) . map . set (x . id,x . value);
        } else {
            (*this) . map . remove (x . id);
        }
        (*this) . del . pop_back();
    }
}
void ivy::local_tracker::__t::push () {
    (*this) . map . push();
}
void ivy::local_tracker::__t::add_var  (const ivy::ptr< ivy::expr::__t > &typing,const __bool &is_ref,const
    pos::__t &loop_nesting)
{
    ivy::ptr< ivy::expr::__t > v;
    v = typing -> is (ivy::verb::__t (ivy::verb::colon)) ?
        typing -> get_arg (vector__ivy__expr::domain::__t (0)) : typing;
    ivy::local_info::__t li;
    li . is_ref = is_ref;
    li . loop_nesting = loop_nesting;
    (*this) . map . set (v -> get_name(),li);
}
void ivy::local_tracker::__t::push_vars  (const vector__ivy__expr::__t &typings)
{
    (*this) . map . push();
    vector__ivy__expr::domain::__t idx;
    idx = typings . begin();
    while (idx < typings . end)
    {
        ivy::ptr< ivy::expr::__t > typing;
        typing = typings . value (idx);
        ivy::ptr< ivy::expr::__t > v;
        v = typing -> is (ivy::verb::__t (ivy::verb::colon)) ?
            typing -> get_arg (vector__ivy__expr::domain::__t (0)) : typing;
        ivy::local_info::__t li;
        (*this) . map . set (v -> get_name(),li);
        idx = idx . next();
    }
}
void ivy::local_tracker::__t::push_stmt  (const ivy::ptr< ivy::stmt::__t > &stm,const pos::__t &loop_nesting)
{
    (*this) . map . push();
    if (stm . isa< ivy::varst::__t >())
    {
        (*this) . add_var (stm -> get_expr(),ivy::native_bool (false),loop_nesting);
    }
}
void ivy::local_tracker::__t::pop () {
    (*this) . map . push();
}
__bool ivy::local_tracker::__t::mem  (const ivy::ptr< ivy::ident::__t > &id) const
{
    __bool res;
    res = (*this) . map . mem (id);
    return res;
}
ivy::local_info::__t ivy::local_tracker::__t::value  (const ivy::ptr< ivy::ident::__t > &id) const
{
    ivy::local_info::__t res;
    res = (*this) . map . value (id);
    return res;
}
void ivy::local_tracker::__t::set  (const ivy::ptr< ivy::ident::__t > &id,const ivy::local_info::__t
    &value) {
    (*this) . map . set (id,value);
}
void ivy::get_lhs_roots  (const ivy::ptr< ivy::expr::__t > &s,ivy::root_mod_ref::__t &st)
{
    if (s . isa< ivy::app::__t >())
    {
        if (s -> is (ivy::verb::__t (ivy::verb::dot)) | s -> is (ivy::verb::__t (ivy::verb::colon)))
        {
            ivy::get_lhs_roots (s -> get_arg (vector__ivy__expr::domain::__t (0)),st);
        } else
        {
            if (s -> is (ivy::verb::__t (ivy::verb::comma)))
            {
                ivy::get_lhs_roots (s -> get_arg (vector__ivy__expr::domain::__t (0)),st);
                ivy::get_lhs_roots (s -> get_arg (vector__ivy__expr::domain::__t (1)),st);
            } else
            {
                ivy::ptr< ivy::expr::__t > func;
                func = s -> get_func();
                if (func -> is (ivy::verb::__t (ivy::verb::colon)))
                {
                    func = func -> get_arg (vector__ivy__expr::domain::__t (0));
                }
                ivy::get_lhs_roots (func,st);
            }
        }
    } else
    {
        if (s . isa< ivy::symbol::__t >())
        {
            ivy::ptr< ivy::ident::__t > id;
            id = s -> get_name();
            if (! st . ignore . mem (id)) {
                st . mod . set (id,ivy::native_bool (true));
            }
        }
    }
}
void ivy::stmt::__t::mod_roots  (ivy::root_mod_ref::__t &st) const {}
void ivy::sequence::__t::mod_roots  (ivy::root_mod_ref::__t &st) const
{
    st . ignore . push_stmt ((*this) . lhs,pos::__t (0));
    (*this) . lhs -> mod_roots (st);
    (*this) . rhs -> mod_roots (st);
    st . ignore . pop();
}
void ivy::asgn::__t::mod_roots  (ivy::root_mod_ref::__t &st) const
{
    ivy::get_lhs_roots ((*this) . lhs,st);
}
void ivy::ifst::__t::mod_roots  (ivy::root_mod_ref::__t &st) const
{
    (*this) . thenst -> mod_roots (st);
    (*this) . elsest -> mod_roots (st);
}
void ivy::whilest::__t::mod_roots  (ivy::root_mod_ref::__t &st) const
{
    (*this) . body -> mod_roots (st);
}
void ivy::set_built_in_type  (const ivy::verb::__t &vrb,const str::__t &ty,const __bool &m,const
    __bool &io,const __bool &oi,const __bool &fi)
{
    ivy::optypes (vrb) = ivy::expr::dec (ty);
    ivy::verb_mono (vrb) = m;
    ivy::verb_in_to_out (vrb) = io;
    ivy::verb_out_to_in (vrb) = oi;
    ivy::verb_first_to_in (vrb) = fi;
}
__bool ivy::verb_det_type  (const ivy::verb::__t &vrb)
{
    __bool res;
    res = ivy::native_bool (true);
    return res;
}
ivy::decost::map::__t ivy::decost::map::empty () {
    ivy::decost::map::__t a;
    {}
    return a;
}
void ivy::decost::map::__t::set  (const ivy::ptr< ivy::ident::__t > &x,const ivy::ptr< ivy::expr::__t >
    &y)
{
    ivy::decost::map::rec z;
    z . full = ivy::native_bool (true);
    z . val = y;
    (*this) . map (x) = z;
}
void ivy::decost::map::__t::get  (const ivy::ptr< ivy::ident::__t > &x,ivy::ptr< ivy::expr::__t > &y)
    const {
    ivy::decost::map::rec z;
    z = (*this) . map (x);
    if (z . full) {
        y = z . val;
    }
}
__bool ivy::decost::map::__t::mem  (const ivy::ptr< ivy::ident::__t > &x) const
{
    __bool res;
    res = (*this) . map (x) . full;
    return res;
}
void ivy::decost::map::__t::remove  (const ivy::ptr< ivy::ident::__t > &x)
{
    ivy::decost::map::rec z;
    (*this) . map (x) = z;
}
ivy::ptr< ivy::expr::__t > ivy::decost::map::__t::value  (const ivy::ptr< ivy::ident::__t > &x)
    const {
    ivy::ptr< ivy::expr::__t > y;
    y = (*this) . map (x) . val;
    return y;
}
ivy::decost::__t ivy::decost::make ()
{
    ivy::decost::__t res;
    res . ok = ivy::native_bool (true);
    return res;
}
void ivy::decost::__t::newvar  (const ivy::ptr< annot::__t > &ann,ivy::ptr< ivy::expr::__t > &res)
{
    res = ivy::symbol::makenum ((*this) . counter,ann);
    (*this) . counter = (*this) . counter . next();
}
void ivy::decost::__t::find  (const ivy::ptr< ivy::expr::__t > &x,ivy::ptr< ivy::expr::__t > &res)
{
    res = x;
    if (x . isa< ivy::symbol::__t >())
    {
        ivy::ptr< ivy::ident::__t > nx;
        nx = x -> get_name();
        (*this) . m . get (nx,res);
        if (res != x)
        {
            {
                ivy::ptr< ivy::expr::__t > __tmp8;
                (*this) . find (res,__tmp8);
                res = __tmp8;
            }
            (*this) . m . set (nx,res);
        }
    }
    {}
}
void ivy::decost::typeinf_show_str  (const str::__t &s) {}
void ivy::decost::__t::unification_failed  (const ivy::ptr< ivy::expr::__t > &x,const ivy::ptr< ivy::expr::__t >
    &y)
{
    (*this) . ok = ivy::native_bool (false);
    (*this) . failed . append (x);
    (*this) . failed . append (y);
    ivy::decost::typeinf_show_str (x -> enc());
    ivy::decost::typeinf_show_str (y -> enc());
}
void ivy::decost::show_unifying  (const str::__t &x,const str::__t &y) {}
void ivy::decost::show_ok  (const __bool &res) {}
void ivy::decost::__t::unify  (const ivy::ptr< ivy::expr::__t > &x0,const ivy::ptr< ivy::expr::__t >
    &y0)
{
    ivy::ptr< ivy::expr::__t > x;
    ivy::ptr< ivy::expr::__t > y;
    (*this) . find (x0,x);
    (*this) . find (y0,y);
    if (x . isa< ivy::symbol::__t >())
    {
        ivy::ptr< ivy::ident::__t > nx;
        nx = x -> get_name();
        if (nx . isa< ivy::numident::__t >())
        {
            if (y -> occurs (nx)) {
                (*this) . unification_failed (x,y);
            } else {
                (*this) . m . set (nx,y);
            }
        } else
        {
            if (y . isa< ivy::symbol::__t >())
            {
                ivy::ptr< ivy::ident::__t > ny;
                ny = y -> get_name();
                if (ny . isa< ivy::numident::__t >()) {
                    (*this) . unify (y,x);
                } else {
                    if (nx != ny) {
                        (*this) . unification_failed (x,y);
                    }
                }
            } else {
                (*this) . unification_failed (x,y);
            }
        }
    } else
    {
        if (y . isa< ivy::symbol::__t >()) {
            (*this) . unify (y,x);
        } else
        {
            if (x -> is (ivy::verb::__t (ivy::verb::times)) &
            y -> is (ivy::verb::__t (ivy::verb::times)) |
            x -> is (ivy::verb::__t (ivy::verb::arrow)) &
            y -> is (ivy::verb::__t (ivy::verb::arrow)))
            {
                (*this) . unify (x -> get_arg (vector__ivy__expr::domain::__t (0)),y -> get_arg (vector__ivy__expr::domain::__t
                                (0)));
                if ((*this) . ok)
                {
                    (*this) . unify (x -> get_arg (vector__ivy__expr::domain::__t (1)),y -> get_arg
                                (vector__ivy__expr::domain::__t (1)));
                }
            } else {
                (*this) . unification_failed (x,y);
            }
        }
    }
    {}
}
ivy::elidest::map::__t ivy::elidest::map::empty () {
    ivy::elidest::map::__t a;
    {}
    return a;
}
void ivy::elidest::map::__t::set  (const ivy::ptr< ivy::ident::__t > &x,const __bool &y)
{
    ivy::elidest::map::rec z;
    z . full = ivy::native_bool (true);
    z . val = y;
    (*this) . map (x) = z;
}
void ivy::elidest::map::__t::get  (const ivy::ptr< ivy::ident::__t > &x,__bool &y) const
{
    ivy::elidest::map::rec z;
    z = (*this) . map (x);
    if (z . full) {
        y = z . val;
    }
}
__bool ivy::elidest::map::__t::mem  (const ivy::ptr< ivy::ident::__t > &x) const
{
    __bool res;
    res = (*this) . map (x) . full;
    return res;
}
void ivy::elidest::map::__t::remove  (const ivy::ptr< ivy::ident::__t > &x)
{
    ivy::elidest::map::rec z;
    (*this) . map (x) = z;
}
__bool ivy::elidest::map::__t::value  (const ivy::ptr< ivy::ident::__t > &x) const
{
    __bool y;
    y = (*this) . map (x) . val;
    return y;
}
void ivy::type_error  (const ivy::ptr< ivy::expr::__t > &e,ivy::decost::__t &st)
{
    if (! st . error_reported)
    {
        ivy::report_error (ivy::type_clash::make (e,st . failed . value (vector__ivy__expr::domain::__t
                            (0)),st . failed . value (vector__ivy__expr::domain::__t (1))),e ->
                    get_ann());
        st . error_reported = ivy::native_bool (true);
    }
}
void ivy::expr::__t::type_decorate  (ivy::decost::__t &st,const ivy::symeval::__t &m,ivy::ptr< ivy::expr::__t >
    &res,ivy::ptr< ivy::expr::__t > &ty) const {}
void ivy::expr::__t::type_fill_in  (ivy::decost::__t &st,ivy::ptr< ivy::expr::__t > &res) const {}
void ivy::expr::__t::type_elide_int  (const __bool &b,const ivy::symeval::__t &m,ivy::elidest::__t &st,ivy::ptr< ivy::expr::__t >
    &res) const {}
void ivy::symbol::__t::type_decorate  (ivy::decost::__t &st,const ivy::symeval::__t &m,ivy::ptr< ivy::expr::__t >
    &res,ivy::ptr< ivy::expr::__t > &ty) const
{
    if ((*this) . vrb != ivy::verb::__t (ivy::verb::none) & (*this) . vrb !=
    ivy::verb::__t (ivy::verb::numeral) & (*this) . vrb != ivy::verb::__t (ivy::verb::string) &
    (*this) . vrb != ivy::verb::__t (ivy::verb::logvar) & (*this) . vrb !=
    ivy::verb::__t (ivy::verb::empty) & (*this) . vrb != ivy::verb::__t (ivy::verb::fltnum))
    {
        ivy::symeval::__t mm;
        ivy::ptr< ivy::expr::__t > v;
        st . newvar ((*this) . ann,v);
        mm . set (ivy::strident::make (ivy::from_str< str::__t > ("alpha")),v);
        st . newvar ((*this) . ann,v);
        mm . set (ivy::strident::make (ivy::from_str< str::__t > ("beta")),v);
        ty = ivy::optypes ((*this) . vrb);
        ty = ty -> reduce (mm);
    } else
    {
        if (st . member) {
            st . newvar ((*this) . ann,ty);
        } else
        {
            if (st . ty . mem ((*this) . name)) {
                ty = st . ty . value ((*this) . name);
            } else
            {
                st . newvar ((*this) . ann,ty);
                if ((*this) . vrb == ivy::verb::__t (ivy::verb::none) | (*this) . vrb ==
                ivy::verb::__t (ivy::verb::logvar))
                {
                    m . get ((*this) . name,ty);
                    st . ty . set ((*this) . name,ty);
                }
            }
        }
    }
    res = ivy::colon::make ((*this),ty,(*this) . ann);
}
void ivy::symbol::__t::type_fill_in  (ivy::decost::__t &st,ivy::ptr< ivy::expr::__t > &res) const
{
    ivy::ptr< ivy::expr::__t > ee;
    ee = (*this);
    st . find (ee,res);
    
    // workaround
    
    if (res != ee) {
        ivy::ptr< ivy::expr::__t > __tmp9;
        res -> type_fill_in (st,__tmp9);
        res = __tmp9;
    }
}
void ivy::symbol::__t::type_elide_int  (const __bool &b,const ivy::symeval::__t &m,ivy::elidest::__t
    &st,ivy::ptr< ivy::expr::__t > &res) const {
    res = (*this);
}
void ivy::app::__t::type_decorate  (ivy::decost::__t &st,const ivy::symeval::__t &m,ivy::ptr< ivy::expr::__t >
    &res,ivy::ptr< ivy::expr::__t > &ty) const
{
    ivy::ptr< ivy::expr::__t > arg;
    ivy::ptr< ivy::expr::__t > argty;
    if ((*this) . is (ivy::verb::__t (ivy::verb::colon)))
    {
        (*this) . args . value (vector__ivy__expr::domain::__t (0)) -> type_decorate (st,m,res,argty);
        ty = (*this) . args . value (vector__ivy__expr::domain::__t (1));
        st . unify (argty,ty);
        if (! st . ok) {
            ivy::type_error ((*this),st);
        }
    } else
    {
        if ((*this) . is (ivy::verb::__t (ivy::verb::dot)))
        {
            
            // dot operator acts like curried function application
            
            ivy::ptr< ivy::expr::__t > argty;
            ivy::ptr< ivy::expr::__t > arg;
            (*this) . get_arg (vector__ivy__expr::domain::__t (0)) -> type_decorate (st,m,arg,argty);
            st . newvar ((*this) . ann,ty);
            ivy::ptr< ivy::expr::__t > fty;
            fty = ivy::arrow::make (argty,ty,(*this) . ann);
            ivy::ptr< ivy::expr::__t > func;
            st . member = ivy::native_bool (true);
            (*this) . get_arg (vector__ivy__expr::domain::__t (1)) -> type_decorate (st,m,func,argty);
            st . member = ivy::native_bool (false);
            st . unify (argty,fty);
            if (! st . ok) {
                ivy::type_error ((*this),st);
            }
            res = ivy::dot::make (arg,func,(*this) . ann);
        } else
        {
            if ((*this) . is (ivy::verb::__t (ivy::verb::isav)))
            {
                (*this) . args . value (vector__ivy__expr::domain::__t (0)) -> type_decorate (st,m,res,argty);
                ty = ivy::symbol::makestr (ivy::from_str< str::__t > ("bool"),(*this) . ann);
                res =
                    ivy::isaop::make (res,(*this) . args . value (vector__ivy__expr::domain::__t (1)),(*this)
                        . ann);
            } else
            {
                vector__ivy__expr::__t argtys;
                vector__ivy__expr::__t newargs;
                vector__ivy__expr::domain::__t idx;
                idx = (*this) . args . begin();
                while (idx < (*this) . args . end)
                {
                    (*this) . args . value (idx) -> type_decorate (st,m,arg,argty);
                    argtys . append (argty);
                    newargs . append (arg);
                    idx = idx . next();
                }
                st . newvar ((*this) . ann,ty);
                ivy::ptr< ivy::expr::__t > fty;
                fty =
                    ivy::arrow::make (ivy::times::fold_left (argtys,(*this) . ann),ty,(*this) . ann);
                (*this) . func -> type_decorate (st,m,arg,argty);
                st . unify (argty,fty);
                if (! st . ok) {
                    ivy::type_error ((*this),st);
                }
                res = ivy::app::make (arg,newargs,(*this) . ann);
            }
        }
    }
}
void ivy::app::__t::type_fill_in  (ivy::decost::__t &st,ivy::ptr< ivy::expr::__t > &res) const
{
    ivy::ptr< ivy::expr::__t > func;
    (*this) . func -> type_fill_in (st,func);
    vector__ivy__expr::__t newargs;
    vector__ivy__expr::domain::__t idx;
    idx = (*this) . args . begin();
    while (idx < (*this) . args . end)
    {
        ivy::ptr< ivy::expr::__t > arg;
        (*this) . args . value (idx) -> type_fill_in (st,arg);
        newargs . append (arg);
        idx = idx . next();
    }
    if ((*this) . is (ivy::verb::__t (ivy::verb::colon)))
    {
        if (newargs . value (vector__ivy__expr::domain::__t (1)) -> has_numident())
        {
            ivy::cannot_infer ((*this),newargs . value (vector__ivy__expr::domain::__t (1)));
            st . ok = ivy::native_bool (false);
        }
    }
    res = ivy::app::make (func,newargs,(*this) . ann);
}
void ivy::app::__t::type_elide_int  (const __bool &b0,const ivy::symeval::__t &m,ivy::elidest::__t &st,ivy::ptr< ivy::expr::__t >
    &res) const
{
    __bool b;
    b = b0;
    if ((*this) . is (ivy::verb::__t (ivy::verb::colon)))
    {
        ivy::ptr< ivy::expr::__t > arg;
        arg = (*this) . args . value (vector__ivy__expr::domain::__t (0));
        arg -> type_elide_int (b,m,st,res);
        if (! b)
        {
            if (arg . isa< ivy::app::__t >()) {
                b = ivy::verb_in_to_out (arg -> app_verb());
            } else
            {
                __bool __tmp10;
                __tmp10 = ivy::native_bool (false);
                st . seen . get (arg -> get_name(),__tmp10);
                b = ivy::verb_mono (arg -> get_verb()) & (__tmp10 | m . mem (arg -> get_name()));
            }
        }
        if (! b)
        {
            res =
                ivy::colon::make (res,(*this) . args . value (vector__ivy__expr::domain::__t (1)),(*this)
                    . ann);
        }
        if (arg . isa< ivy::symbol::__t >())
        {
            st . seen . set (arg -> get_name(),ivy::native_bool (true));
        }
    } else
    {
        ivy::ptr< ivy::expr::__t > func;
        (*this) . func -> type_elide_int (ivy::native_bool (true),m,st,func);
        ivy::verb::__t vrb;
        vrb = (*this) . func -> get_verb();
        b = b & ivy::verb_out_to_in (vrb) | ivy::verb_mono (vrb);
        vector__ivy__expr::__t newargs;
        vector__ivy__expr::domain::__t idx;
        idx = (*this) . args . begin();
        while (idx < (*this) . args . end)
        {
            ivy::ptr< ivy::expr::__t > arg;
            __bool ba;
            ba = b | ivy::verb_first_to_in (vrb) & idx > vector__ivy__expr::domain::__t (0);
            (*this) . args . value (idx) -> type_elide_int (ba,m,st,arg);
            newargs . append (arg);
            idx = idx . next();
        }
        res = ivy::app::make (func,newargs,(*this) . ann);
    }
}
void ivy::cannot_infer  (const ivy::ptr< ivy::expr::__t > &e,const ivy::ptr< ivy::expr::__t > &t)
{
    ivy::report_cannot_infer (e -> enc(),t -> enc());
}
void ivy::report_cannot_infer  (const str::__t &s1,const str::__t &s2) {}
void ivy::type_infer_vec  (vector__ivy__expr::__t &es,const ivy::symeval::__t &tc)
{
    ivy::decost::__t st;
    st = ivy::decost::make();
    vector__ivy__expr::domain::__t idx;
    idx = es . begin();
    while (idx < es . end)
    {
        ivy::ptr< ivy::expr::__t > e;
        e = es . value (idx);
        ivy::ptr< ivy::expr::__t > ty;
        
        // ignored
        
        {
            ivy::ptr< ivy::expr::__t > __tmp11;
            e -> type_decorate (st,tc,__tmp11,ty);
            e = __tmp11;
        }
        es . set (idx,e);
        idx = idx . next();
    }
    idx = es . begin();
    while (idx < es . end)
    {
        ivy::ptr< ivy::expr::__t > e;
        e = es . value (idx);
        {
            ivy::ptr< ivy::expr::__t > __tmp12;
            e -> type_fill_in (st,__tmp12);
            e = __tmp12;
        }
        es . set (idx,e);
        idx = idx . next();
    }
}
void ivy::type_infer_known  (ivy::ptr< ivy::expr::__t > &e,const ivy::ptr< ivy::expr::__t > &ty,const
    ivy::symeval::__t &tc)
{
    ivy::decost::__t st;
    st = ivy::decost::make();
    ivy::ptr< ivy::expr::__t > ty2;
    
    // ignored
    
    {
        ivy::ptr< ivy::expr::__t > __tmp13;
        e -> type_decorate (st,tc,__tmp13,ty2);
        e = __tmp13;
    }
    st . unify (ty,ty2);
    if (! st . ok) {
        ivy::type_error (e,st);
    }
    ivy::ptr< ivy::expr::__t > __tmp14;
    e -> type_fill_in (st,__tmp14);
    e = __tmp14;
}
void ivy::type_unify_exprs  (ivy::ptr< ivy::expr::__t > &e1,ivy::ptr< ivy::expr::__t > &e2,const ivy::symeval::__t
    &tc)
{
    ivy::decost::__t st;
    st = ivy::decost::make();
    ivy::ptr< ivy::expr::__t > e1ty;
    {
        ivy::ptr< ivy::expr::__t > __tmp15;
        e1 -> type_decorate (st,tc,__tmp15,e1ty);
        e1 = __tmp15;
    }
    ivy::ptr< ivy::expr::__t > e2ty;
    {
        ivy::ptr< ivy::expr::__t > __tmp16;
        e2 -> type_decorate (st,tc,__tmp16,e2ty);
        e2 = __tmp16;
    }
    st . unify (e1ty,e2ty);
    if (! st . ok) {
        ivy::type_error (e2,st);
    }
    {
        ivy::ptr< ivy::expr::__t > __tmp17;
        e1 -> type_fill_in (st,__tmp17);
        e1 = __tmp17;
    }
    ivy::ptr< ivy::expr::__t > __tmp18;
    e2 -> type_fill_in (st,__tmp18);
    e2 = __tmp18;
}
ivy::ptr< ivy::expr::__t > ivy::expr::__t::get_type () const
{
    ivy::ptr< ivy::expr::__t > res;
    {}
    return res;
}
void ivy::range_type  (ivy::ptr< ivy::expr::__t > &s)
{
    if (s -> is (ivy::verb::__t (ivy::verb::arrow)))
    {
        s = s -> get_arg (vector__ivy__expr::domain::__t (1));
    }
}
ivy::ptr< ivy::expr::__t > ivy::app::__t::get_type () const
{
    ivy::ptr< ivy::expr::__t > res;
    if ((*this) . is (ivy::verb::__t (ivy::verb::colon)))
    {
        res = (*this) . args . value (vector__ivy__expr::domain::__t (1));
    } else
    {
        if ((*this) . is (ivy::verb::__t (ivy::verb::dot)))
        {
            res =
                (*this) . args . value (vector__ivy__expr::domain::__t (1)) -> get_arg (vector__ivy__expr::domain::__t
                            (1)) -> get_arg (vector__ivy__expr::domain::__t (1));
            ivy::range_type (res);
        } else
        {
            res =
                (*this) . func -> get_arg (vector__ivy__expr::domain::__t (1)) -> get_arg (vector__ivy__expr::domain::__t
                        (1));
            ivy::range_type (res);
        }
    }
    return res;
}
vector__ivy__type_context__stack_entry::domain::__t vector__ivy__type_context__stack_entry::domain::__t::next
    () const
{
    vector__ivy__type_context__stack_entry::domain::__t y;
    y = (*this) + vector__ivy__type_context__stack_entry::domain::__t (1);
    return y;
}
vector__ivy__type_context__stack_entry::domain::__t vector__ivy__type_context__stack_entry::domain::__t::prev
    () const
{
    vector__ivy__type_context__stack_entry::domain::__t y;
    y = (*this) - vector__ivy__type_context__stack_entry::domain::__t (1);
    return y;
}
vector__ivy__type_context__stack_entry::domain::__t vector__ivy__type_context__stack_entry::__t::begin
    () const
{
    vector__ivy__type_context__stack_entry::domain::__t res;
    res = vector__ivy__type_context__stack_entry::domain::__t (0);
    return res;
}
vector__ivy__type_context__stack_entry::__t vector__ivy__type_context__stack_entry::empty ()
{
    vector__ivy__type_context__stack_entry::__t res;
    {}
    return res;
}
void vector__ivy__type_context__stack_entry::__t::set  (const vector__ivy__type_context__stack_entry::domain::__t
    &i,const ivy::type_context::stack_entry &v) {
    (*this) . value (i) = v;
}
void vector__ivy__type_context__stack_entry::__t::append  (const ivy::type_context::stack_entry &c)
{
    (*this) . value ((*this) . end) = c;
    (*this) . end = (*this) . end . next();
}
void vector__ivy__type_context__stack_entry::__t::extend  (const
    vector__ivy__type_context__stack_entry::__t &x)
{
    vector__ivy__type_context__stack_entry::domain::__t idx;
    idx = x . begin();
    while (idx < x . end) {
        (*this) . append (x . value (idx));
        idx = idx . next();
    }
}
void vector__ivy__type_context__stack_entry::__t::resize  (const
    vector__ivy__type_context__stack_entry::domain::__t &end)
{
    ivy::resize ((*this) . value,end);
    (*this) . end = end;
}
ivy::type_context::stack_entry vector__ivy__type_context__stack_entry::__t::back () const
{
    ivy::type_context::stack_entry y;
    if ((*this) . end > vector__ivy__type_context__stack_entry::domain::__t (0))
    {
        y = (*this) . value ((*this) . end . prev());
    }
    return y;
}
void vector__ivy__type_context__stack_entry::__t::pop_back ()
{
    if ((*this) . end > vector__ivy__type_context__stack_entry::domain::__t (0))
    {
        vector__ivy__type_context__stack_entry::domain::__t size;
        size = (*this) . end . prev();
        (*this) . resize (size);
    }
}
vector__ivy__type_context__stack_entry::__t vector__ivy__type_context__stack_entry::__t::segment  (const
    vector__ivy__type_context__stack_entry::domain::__t &beg,const
    vector__ivy__type_context__stack_entry::domain::__t &en) const
{
    vector__ivy__type_context__stack_entry::__t res;
    {
        vector__ivy__type_context__stack_entry::domain::__t idx;
        idx = beg;
        while (idx < en & idx < (*this) . end)
        {
            res . append ((*this) . value (idx));
            idx = idx . next();
        }
    }
    return res;
}
void vector__ivy__type_context__stack_entry::__t::reverse ()
{
    vector__ivy__type_context__stack_entry::domain::__t idx;
    idx = (*this) . begin();
    vector__ivy__type_context__stack_entry::domain::__t jdx;
    jdx = (*this) . end . prev();
    while (idx < jdx)
    {
        ivy::type_context::stack_entry tmp;
        tmp = (*this) . value (idx);
        (*this) . value (idx) = (*this) . value (jdx);
        (*this) . value (jdx) = tmp;
        jdx = jdx . prev();
        idx = idx . next();
    }
}
void ivy::type_context::__t::set  (const ivy::ptr< ivy::expr::__t > &typing)
{
    (*this) . m . set (typing -> get_arg (vector__ivy__expr::domain::__t (0)) -> get_name(),typing
                -> get_arg (vector__ivy__expr::domain::__t (1)));
}
void ivy::type_context::__t::push  (const ivy::ptr< ivy::expr::__t > &typing)
{
    ivy::type_context::stack_entry ent;
    ent . id = typing -> get_arg (vector__ivy__expr::domain::__t (0)) -> get_name();
    ent . any = (*this) . m . mem (ent . id);
    if (ent . any) {
        ent . val = (*this) . m . value (ent . id);
    }
    (*this) . stack . append (ent);
    (*this) . m . set (ent . id,typing -> get_arg (vector__ivy__expr::domain::__t (1)));
}
void ivy::type_context::__t::pop ()
{
    ivy::type_context::stack_entry ent;
    ent = (*this) . stack . back();
    (*this) . stack . pop_back();
    if (ent . any) {
        (*this) . m . set (ent . id,ent . val);
    } else {
        (*this) . m . remove (ent . id);
    }
}
void ivy::stmt::__t::typeinfer  (ivy::typeinferst::__t &st,ivy::ptr< ivy::stmt::__t > &res) const
{
    res = (*this) . __upcast();
}
void ivy::stmt::__t::typeinfer_desugar  (const __bool &desugar,ivy::typeinferst::__t &st,ivy::ptr< ivy::stmt::__t >
    &ress) const {}
void ivy::bottom_up_type  (ivy::ptr< ivy::expr::__t > &e,const ivy::typeinferst::__t &st,__bool &ok)
{
    if (e . isa< ivy::symbol::__t >())
    {
        if (e -> get_verb() == ivy::verb::__t (ivy::verb::none) | e -> get_verb() ==
        ivy::verb::__t (ivy::verb::logvar))
        {
            ivy::ptr< ivy::ident::__t > name;
            name = e -> get_name();
            if (st . tc . m . mem (name))
            {
                e = ivy::colon::make (e,st . tc . m . value (name),e -> get_ann());
            }
        } else 
        //                else {
        //		    call report_error(undefined.make(name),e.get_ann);
        //		    ok := false;
        //		}
        
        {
            if (e -> get_verb() == ivy::verb::__t (ivy::verb::empty))
            {
                e = ivy::colon::make (e,e,e -> get_ann());
            }
        }
    } else
    {
        if (e . isa< ivy::app::__t >())
        {
            if (e -> is (ivy::verb::__t (ivy::verb::colon)))
            {
                ivy::ptr< ivy::expr::__t > arg;
                {
                    arg = e -> get_arg (vector__ivy__expr::domain::__t (0));
                    ivy::bottom_up_type (arg,st,ok);
                }
                e =
                    ivy::colon::make (arg,e -> get_arg (vector__ivy__expr::domain::__t (1)),e ->
                            get_ann());
            } else
            {
                if (e -> is (ivy::verb::__t (ivy::verb::dot)))
                {
                    ivy::ptr< ivy::expr::__t > lhs;
                    {
                        lhs = e -> get_arg (vector__ivy__expr::domain::__t (0));
                        ivy::bottom_up_type (lhs,st,ok);
                    }
                    ivy::ptr< ivy::expr::__t > rhs;
                    rhs = e -> get_arg (vector__ivy__expr::domain::__t (1));
                    e = ivy::dot::make (lhs,rhs,e -> get_ann());
                    if (lhs -> is (ivy::verb::__t (ivy::verb::colon)))
                    {
                        ivy::ptr< ivy::expr::__t > ty;
                        ty = lhs -> get_arg (vector__ivy__expr::domain::__t (1));
                        if (ty . isa< ivy::symbol::__t >())
                        {
                            ivy::ptr< ivy::ident::__t > name;
                            name = rhs -> get_name() -> prefix (ty -> get_name());
                            if (st . tc . m . mem (name))
                            {
                                ivy::ptr< ivy::expr::__t > fty;
                                fty = st . tc . m . value (name) -> curry();
                                rhs = ivy::colon::make (rhs,fty,rhs -> get_ann());
                                e = ivy::dot::make (lhs,rhs,e -> get_ann());
                                if (fty -> is (ivy::verb::__t (ivy::verb::arrow)))
                                {
                                    e =
                                        ivy::colon::make (e,fty -> get_arg (vector__ivy__expr::domain::__t
                                                    (1)),e -> get_ann());
                                }
                            } else
                            {
                                ivy::report_error (ivy::undefined::make (name),e -> get_ann());
                                ok = ivy::native_bool (false);
                            }
                        } else
                        {
                            ivy::report_error (ivy::not_first_order::make (lhs,ty),lhs -> get_ann());
                            ok = ivy::native_bool (false);
                        }
                    } else
                    {
                        ivy::report_error (ivy::untyped::make (lhs,ivy::empty::make (lhs -> get_ann())),lhs
                                    -> get_ann());
                        ok = ivy::native_bool (false);
                    }
                    {}
                } else
                {
                    ivy::ptr< ivy::expr::__t > func;
                    {
                        func = e -> get_func();
                        ivy::bottom_up_type (func,st,ok);
                    }
                    vector__ivy__expr::__t args;
                    {
                        args = e -> get_args();
                        ivy::bottom_up_types (args,func,st,ok);
                    }
                    e = ivy::app::make (func,args,e -> get_ann());
                    if (func -> is (ivy::verb::__t (ivy::verb::colon)))
                    {
                        ivy::ptr< ivy::expr::__t > ty;
                        ty = func -> get_arg (vector__ivy__expr::domain::__t (1));
                        if (ty -> is (ivy::verb::__t (ivy::verb::arrow)))
                        {
                            e =
                                ivy::colon::make (e,ty -> get_arg (vector__ivy__expr::domain::__t (1)),e
                                        -> get_ann());
                        }
                    }
                }
            }
        }
    }
}
void ivy::bottom_up_types  (vector__ivy__expr::__t &es,const ivy::ptr< ivy::expr::__t > &func,const
    ivy::typeinferst::__t &st,__bool &ok)
{
    vector__ivy__expr::__t argtypes;
    if (func -> is (ivy::verb::__t (ivy::verb::colon)))
    {
        ivy::ptr< ivy::expr::__t > ftype;
        ftype = func -> get_arg (vector__ivy__expr::domain::__t (1));
        if (ftype -> is (ivy::verb::__t (ivy::verb::arrow)))
        {
            argtypes =
                ivy::times::unfold_left (ftype -> get_arg (vector__ivy__expr::domain::__t (0)));
        }
    }
    vector__ivy__expr::domain::__t idx;
    idx = es . begin();
    while (idx < es . end)
    {
        ivy::ptr< ivy::expr::__t > e;
        {
            e = es . value (idx);
            ivy::bottom_up_type (e,st,ok);
        }
        if (idx < argtypes . end) {
            ivy::make_cast (argtypes . value (idx),e,st);
        }
        es . set (idx,e);
        idx = idx . next();
    }
}
__bool ivy::is_subtype  (const ivy::ptr< ivy::expr::__t > &rhsty,const ivy::ptr< ivy::expr::__t > &lhsty,const
    ivy::typeinferst::__t &st)
{
    __bool res;
    if (rhsty -> is (ivy::verb::__t (ivy::verb::comma)))
    {
        if (lhsty -> is (ivy::verb::__t (ivy::verb::comma)))
        {
            res =
                ivy::is_subtype (rhsty -> get_arg (vector__ivy__expr::domain::__t (0)),lhsty ->
                        get_arg (vector__ivy__expr::domain::__t (0)),st) &
                ivy::is_subtype (rhsty -> get_arg (vector__ivy__expr::domain::__t (1)),lhsty ->
                        get_arg (vector__ivy__expr::domain::__t (1)),st);
        }
    } else
    {
        if (! lhsty -> is (ivy::verb::__t (ivy::verb::comma)))
        {
            res = st . subtype_rel . is_subtype (rhsty,lhsty);
        }
    }
    return res;
}
void ivy::make_cast  (const ivy::ptr< ivy::expr::__t > &lhsty,ivy::ptr< ivy::expr::__t > &rhs,const
    ivy::typeinferst::__t &st)
{
    if (rhs -> is (ivy::verb::__t (ivy::verb::colon)))
    {
        ivy::ptr< ivy::expr::__t > rhsty;
        rhsty = rhs -> get_arg (vector__ivy__expr::domain::__t (1));
        if (! lhsty -> eq (rhsty))
        {
            if (! ivy::is_subtype (rhsty,lhsty,st))
            {
                ivy::report_error (ivy::type_conversion::make (rhs,rhsty,lhsty),rhs -> get_ann());
            }
            ivy::ptr< ivy::expr::__t > castty;
            castty = ivy::arrow::make (rhsty,lhsty,rhs -> get_ann());
            ivy::ptr< ivy::expr::__t > castop;
            castop =
                ivy::colon::make (ivy::symbol::makestr (ivy::from_str< str::__t > ("cast"),rhs ->
                            get_ann()),castty,rhs -> get_ann());
            rhs = ivy::app::make1 (castop,rhs,rhs -> get_ann());
        }
    }
}
void ivy::desugar_asgn  (ivy::ptr< ivy::stmt::__t > &s,vector__ivy__stmt::__t &varsts)
{
    ivy::ptr< ivy::expr::__t > tlhs;
    tlhs = s -> get_lhs();
    vector__ivy__expr::__t lhs;
    lhs = ivy::comma::unfold_left (tlhs);
    vector__ivy__expr::domain::__t idx;
    idx = lhs . begin();
    vector__ivy__expr::__t es;
    while (idx < lhs . end)
    {
        ivy::ptr< ivy::expr::__t > e;
        e = lhs . value (idx);
        if (e . isa< ivy::app::__t >())
        {
            ivy::ptr< ivy::expr::__t > f;
            f = e -> get_func();
            if (f -> is (ivy::verb::__t (ivy::verb::colon)) &
            f -> get_arg (vector__ivy__expr::domain::__t (0)) -> get_verb() ==
            ivy::verb::__t (ivy::verb::varv))
            {
                ivy::varst::__t vst;
                vst . ann = e -> get_ann();
                vst . name = e -> get_arg (vector__ivy__expr::domain::__t (0));
                varsts . append (vst);
                es . append (vst . name);
            } else {
                es . append (e);
            }
        } else {
            es . append (e);
        }
        idx = idx . next();
    }
    if (varsts . end > vector__ivy__stmt::domain::__t (0))
    {
        ivy::ptr< ivy::expr::__t > things;
        things = ivy::comma::fold_left (es,s -> get_lhs() -> get_ann());
        s = ivy::asgn::make (things,s -> get_rhs(),s -> get_ann());
    }
}
void ivy::asgn::__t::typeinfer_desugar  (const __bool &desugar,ivy::typeinferst::__t &st,ivy::ptr< ivy::stmt::__t >
    &ress) const
{
    ivy::asgn::__t res;
    res = (*this);
    __bool ok;
    ok = ivy::native_bool (true);
    ivy::bottom_up_type (res . lhs,st,ok);
    ivy::bottom_up_type (res . rhs,st,ok);
    if (ok) 
    // avoid cascading errors
    
    {
        ivy::ptr< ivy::expr::__t > lhs;
        lhs = res . lhs -> is_typed (ivy::verb::__t (ivy::verb::varv)) ?
            res . lhs -> get_arg (vector__ivy__expr::domain::__t (0)) : res . lhs;
        if (lhs -> is (ivy::verb::__t (ivy::verb::colon)))
        {
            ivy::make_cast (lhs -> get_arg (vector__ivy__expr::domain::__t (1)),res . rhs,st);
        }
        ivy::type_unify_exprs (res . lhs,res . rhs,st . tc . m);
    }
    ress = res;
    if (desugar)
    {
        vector__ivy__stmt::__t vsts;
        ivy::desugar_asgn (ress,vsts);
        if (vsts . end > vector__ivy__stmt::domain::__t (0))
        {
            vsts . append (ress);
            ress = ivy::sequence::fold_right (vsts,res . lhs -> get_ann());
        }
    }
}
void ivy::asgn::__t::typeinfer  (ivy::typeinferst::__t &st,ivy::ptr< ivy::stmt::__t > &ress) const
{
    (*this) . typeinfer_desugar (ivy::native_bool (true),st,ress);
}
void ivy::sequence::__t::typeinfer  (ivy::typeinferst::__t &st,ivy::ptr< ivy::stmt::__t > &ress)
    const
{
    ivy::sequence::__t res;
    res = (*this);
    if (res . lhs . isa< ivy::asgn::__t >())
    {
        res . lhs -> typeinfer_desugar (ivy::native_bool (false),st,res . lhs);
        vector__ivy__stmt::__t vsts;
        ivy::desugar_asgn (res . lhs,vsts);
        vector__ivy__stmt::domain::__t idx;
        idx = vsts . begin();
        while (idx < vsts . end)
        {
            st . tc . push (vsts . value (idx) -> get_expr());
            idx = idx . next();
        }
        res . rhs -> typeinfer (st,res . rhs);
        idx = vsts . begin();
        while (idx < vsts . end) {
            st . tc . pop();
            idx = idx . next();
        }
        ress = res;
        if (vsts . end > vector__ivy__stmt::domain::__t (0))
        {
            vsts . append (ress);
            ress = ivy::sequence::fold_right (vsts,res . lhs -> get_ann());
        }
    } else
    {
        res . lhs -> typeinfer (st,res . lhs);
        if (res . lhs . isa< ivy::varst::__t >())
        {
            st . tc . push (res . lhs -> get_expr());
            res . rhs -> typeinfer (st,res . rhs);
            st . tc . pop();
        } else {
            res . rhs -> typeinfer (st,res . rhs);
        }
        ress = res;
    }
}
void ivy::ifst::__t::typeinfer  (ivy::typeinferst::__t &st,ivy::ptr< ivy::stmt::__t > &res) const
{
    ivy::ifst::__t t;
    (*this) . typeinfer_int (st,t);
    t . ann = (*this) . ann;
    res = t;
}
void ivy::ifst::__t::typeinfer_int  (ivy::typeinferst::__t &st,ivy::ifst::__t &res) const
{
    res = (*this);
    __bool ok;
    ok = ivy::native_bool (true);
    ivy::bottom_up_type (res . cond,st,ok);
    if (ok)
    {
        ivy::type_infer_known (res . cond,ivy::symbol::makestr (ivy::from_str< str::__t > ("bool"),(*this)
                    . ann),st . tc . m);
    }
    ivy::ptr< ivy::stmt::__t > ts;
    res . thenst -> typeinfer (st,ts);
    res . thenst = ts;
    ivy::ptr< ivy::stmt::__t > es;
    res . elsest -> typeinfer (st,es);
    res . elsest = es;
}
void ivy::whilest::__t::typeinfer  (ivy::typeinferst::__t &st,ivy::ptr< ivy::stmt::__t > &res) const
{
    ivy::whilest::__t t;
    (*this) . typeinfer_int (st,t);
    t . ann = (*this) . ann;
    res = t;
}
void ivy::whilest::__t::typeinfer_int  (ivy::typeinferst::__t &st,ivy::whilest::__t &res) const
{
    res = (*this);
    __bool ok;
    ok = ivy::native_bool (true);
    ivy::bottom_up_type (res . cond,st,ok);
    if (ok)
    {
        ivy::type_infer_known (res . cond,ivy::symbol::makestr (ivy::from_str< str::__t > ("bool"),(*this)
                    . ann),st . tc . m);
    }
    ivy::ptr< ivy::stmt::__t > body;
    res . body -> typeinfer (st,body);
    res . body = body;
}
void ivy::decl::__t::typeinfer  (ivy::typeinferst::__t &st,ivy::ptr< ivy::decl::__t > &res) const
{
    res = (*this) . __upcast();
}
void ivy::setup_formals  (const vector__ivy__expr::__t &es,const __bool &val,ivy::typeinferst::__t &st)
{
    vector__ivy__expr::domain::__t idx;
    idx = es . begin();
    while (idx < es . end)
    {
        ivy::ptr< ivy::expr::__t > e;
        e = es . value (idx);
        if (e -> is (ivy::verb::__t (ivy::verb::colon)))
        {
            if (val) {
                st . tc . push (e);
            } else {
                st . tc . pop();
            }
            {}
        }
        idx = idx . next();
    }
}
void ivy::actdc::__t::typeinfer  (ivy::typeinferst::__t &st,ivy::ptr< ivy::decl::__t > &res) const
{
    ivy::actdc::__t t;
    (*this) . typeinfer_int (st,t);
    t . ann = (*this) . ann;
    res = t;
}
void ivy::actdc::__t::typeinfer_int  (ivy::typeinferst::__t &st,ivy::actdc::__t &res) const
{
    res . name = (*this) . name;
    res . kind = (*this) . kind;
    res . inputs = (*this) . inputs;
    res . outputs = (*this) . outputs;
    ivy::setup_formals (res . inputs,ivy::native_bool (true),st);
    ivy::setup_formals (res . outputs,ivy::native_bool (true),st);
    res . has_body = (*this) . has_body;
    (*this) . body -> typeinfer (st,res . body);
    ivy::setup_formals (res . inputs,ivy::native_bool (false),st);
    ivy::setup_formals (res . outputs,ivy::native_bool (false),st);
}
void ivy::initdc::__t::typeinfer  (ivy::typeinferst::__t &st,ivy::ptr< ivy::decl::__t > &res) const
{
    ivy::initdc::__t t;
    (*this) . typeinfer_int (st,t);
    t . ann = (*this) . ann;
    res = t;
}
void ivy::initdc::__t::typeinfer_int  (ivy::typeinferst::__t &st,ivy::initdc::__t &res) const
{
    (*this) . body -> typeinfer (st,res . body);
}
vector__ivy__expr::__t ivy::get_func_params  (const ivy::ptr< ivy::expr::__t > &typing)
{
    vector__ivy__expr::__t res;
    {
        ivy::ptr< ivy::expr::__t > ty;
        ty = typing;
        if (ty -> is (ivy::verb::__t (ivy::verb::colon)))
        {
            ty = ty -> get_arg (vector__ivy__expr::domain::__t (0));
        }
        if (ty . isa< ivy::app::__t >()) {
            res = ty -> get_args();
        }
    }
    return res;
}
void ivy::vardc::__t::typeinfer  (ivy::typeinferst::__t &st,ivy::ptr< ivy::decl::__t > &res) const
{
    ivy::vardc::__t t;
    (*this) . typeinfer_int (st,t);
    t . ann = (*this) . ann;
    res = t;
}
void ivy::vardc::__t::typeinfer_int  (ivy::typeinferst::__t &st,ivy::vardc::__t &res) const
{
    res = (*this);
    if (res . has_def)
    {
        vector__ivy__expr::__t prms;
        prms = ivy::get_func_params (res . typing);
        ivy::setup_formals (prms,ivy::native_bool (true),st);
        __bool ok;
        ok = ivy::native_bool (true);
        ivy::bottom_up_type (res . def,st,ok);
        ivy::setup_formals (prms,ivy::native_bool (false),st);
        if (ok)
        {
            
            // avoid cascading errors
            
            if (res . typing -> is (ivy::verb::__t (ivy::verb::colon)))
            {
                ivy::make_cast (res . typing -> get_arg (vector__ivy__expr::domain::__t (1)),res .
                        def,st);
            }
            ivy::type_unify_exprs (res . typing,res . def,st . tc . m);
            ivy::ptr< ivy::expr::__t > __tmp19;
            __tmp19 = res . typing;
            ivy::canon_typing (__tmp19);
            st . tc . set (__tmp19);
        }
    }
}
void ivy::prog::__t::typeinfer ()
{
    ivy::typeinferst::__t st;
    
    // Get the subtype relation
    
    st . subtype_rel = (*this) . get_subtypes();
    
    // Get the global typing as initial typing context
    
    ivy::global_types::__t gt;
    gt = (*this) . get_global_types (ivy::native_bool (false));
    
    // don't curry member types
    
    st . tc . m = gt . type_of;
    
    // TODO: bottom-up inference
    // A pass to typeinfer types with Hindley-Milner
    
    vector__ivy__decl::domain::__t idx;
    idx = (*this) . decls . begin();
    while (idx < (*this) . decls . end)
    {
        ivy::ptr< ivy::decl::__t > d;
        (*this) . decls . value (idx) -> typeinfer (st,d);
        (*this) . decls . set (idx,d);
        idx = idx . next();
    }
    {}
}
__bool cpp::is_logvar_name  (const str::__t &name)
{
    __bool res;
    if (name . value (pos::__t (0)) . is_capital())
    {
        res = ivy::native_bool (true);
        pos::__t idx;
        idx = name . begin() . next();
        while (res & idx < name . end) {
            res = name . value (idx) . is_digit();
        }
        idx = idx . next();
    }
    return res;
}
cpp::verb::__t cpp::verb_from_name  (const str::__t &name)
{
    cpp::verb::__t vrb;
    if (name . value (pos::__t (0)) . is_digit())
    {
        vrb = cpp::verb::__t (cpp::verb::numeral);
        pos::__t idx;
        idx = name . begin();
        while (idx < name . end)
        {
            if (name . value (idx) == __char::__t (46)) {
                vrb = cpp::verb::__t (cpp::verb::fltnum);
            }
            idx = idx . next();
        }
    } else
    {
        if (name . value (pos::__t (0)) == __char::__t (34))
        {
            vrb = cpp::verb::__t (cpp::verb::string);
        } else
        {
            if (cpp::is_logvar_name (name)) {
                vrb = cpp::verb::__t (cpp::verb::logvar);
            } else {
                vrb = cpp::str_to_verb (name);
            }
        }
    }
    return vrb;
}
void cpp::ident::__t::encode  (pretty::__t &b,const priority::__t &prio) const {}
str::__t cpp::ident::__t::to_str () const {
    str::__t res;
    {}
    return res;
}
ivy::ptr< cpp::ident::__t > cpp::ident::__t::get_namesp () const
{
    ivy::ptr< cpp::ident::__t > res;
    {}
    return res;
}
ivy::ptr< cpp::ident::__t > cpp::ident::__t::get_member () const
{
    ivy::ptr< cpp::ident::__t > res;
    {}
    return res;
}
vector__cpp__ident::__t cpp::ident::__t::get_subscripts () const
{
    vector__cpp__ident::__t res;
    {}
    return res;
}
ivy::ptr< cpp::ident::__t > cpp::ident::__t::prefix  (const ivy::ptr< cpp::ident::__t > &pref) const
{
    ivy::ptr< cpp::ident::__t > res;
    res = (*this) . __upcast();
    return res;
}
cpp::strident::__t cpp::ident::__t::get_last () const {
    cpp::strident::__t res;
    {}
    return res;
}
cpp::verb::__t cpp::ident::__t::get_verb () const
{
    cpp::verb::__t vrb;
    vrb = cpp::verb::__t (cpp::verb::none);
    return vrb;
}
vector__cpp__ident::domain::__t vector__cpp__ident::domain::__t::next () const
{
    vector__cpp__ident::domain::__t y;
    y = (*this) + vector__cpp__ident::domain::__t (1);
    return y;
}
vector__cpp__ident::domain::__t vector__cpp__ident::domain::__t::prev () const
{
    vector__cpp__ident::domain::__t y;
    y = (*this) - vector__cpp__ident::domain::__t (1);
    return y;
}
vector__cpp__ident::domain::__t vector__cpp__ident::__t::begin () const
{
    vector__cpp__ident::domain::__t res;
    res = vector__cpp__ident::domain::__t (0);
    return res;
}
vector__cpp__ident::__t vector__cpp__ident::empty () {
    vector__cpp__ident::__t res;
    {}
    return res;
}
void vector__cpp__ident::__t::set  (const vector__cpp__ident::domain::__t &i,const ivy::ptr< cpp::ident::__t >
    &v) {
    (*this) . value (i) = v;
}
void vector__cpp__ident::__t::append  (const ivy::ptr< cpp::ident::__t > &c)
{
    (*this) . value ((*this) . end) = c;
    (*this) . end = (*this) . end . next();
}
void vector__cpp__ident::__t::extend  (const vector__cpp__ident::__t &x)
{
    vector__cpp__ident::domain::__t idx;
    idx = x . begin();
    while (idx < x . end) {
        (*this) . append (x . value (idx));
        idx = idx . next();
    }
}
void vector__cpp__ident::__t::resize  (const vector__cpp__ident::domain::__t &end)
{
    ivy::resize ((*this) . value,end);
    (*this) . end = end;
}
ivy::ptr< cpp::ident::__t > vector__cpp__ident::__t::back () const
{
    ivy::ptr< cpp::ident::__t > y;
    if ((*this) . end > vector__cpp__ident::domain::__t (0))
    {
        y = (*this) . value ((*this) . end . prev());
    }
    return y;
}
void vector__cpp__ident::__t::pop_back ()
{
    if ((*this) . end > vector__cpp__ident::domain::__t (0))
    {
        vector__cpp__ident::domain::__t size;
        size = (*this) . end . prev();
        (*this) . resize (size);
    }
}
vector__cpp__ident::__t vector__cpp__ident::__t::segment  (const vector__cpp__ident::domain::__t &beg,const
    vector__cpp__ident::domain::__t &en) const
{
    vector__cpp__ident::__t res;
    {
        vector__cpp__ident::domain::__t idx;
        idx = beg;
        while (idx < en & idx < (*this) . end)
        {
            res . append ((*this) . value (idx));
            idx = idx . next();
        }
    }
    return res;
}
void vector__cpp__ident::__t::reverse ()
{
    vector__cpp__ident::domain::__t idx;
    idx = (*this) . begin();
    vector__cpp__ident::domain::__t jdx;
    jdx = (*this) . end . prev();
    while (idx < jdx)
    {
        ivy::ptr< cpp::ident::__t > tmp;
        tmp = (*this) . value (idx);
        (*this) . value (idx) = (*this) . value (jdx);
        (*this) . value (jdx) = tmp;
        jdx = jdx . prev();
        idx = idx . next();
    }
}
void cpp::strident::__t::encode  (pretty::__t &b,const priority::__t &prio) const
{
    b . extend ((*this) . val);
    if (ivy::native_bool (true))
    {
        if ((*this) . subscrs . end > vector__cpp__ident::domain::__t (0))
        {
            b . extend (ivy::from_str< str::__t > ("< "));
            vector__cpp__ident::domain::__t idx;
            idx = (*this) . subscrs . begin();
            while (idx < (*this) . subscrs . end)
            {
                if (idx > vector__cpp__ident::domain::__t (0))
                {
                    b . extend (ivy::from_str< str::__t > (","));
                }
                (*this) . subscrs . value (idx) -> encode (b,priority::__t (0));
                idx = idx . next();
            }
            b . extend (ivy::from_str< str::__t > (" >"));
        }
    } else
    {
        vector__cpp__ident::domain::__t idx;
        idx = (*this) . subscrs . begin();
        while (idx < (*this) . subscrs . end)
        {
            b . extend (ivy::from_str< str::__t > ("["));
            (*this) . subscrs . value (idx) -> encode (b,priority::__t (0));
            b . extend (ivy::from_str< str::__t > ("]"));
            idx = idx . next();
        }
    }
}
ivy::ptr< cpp::ident::__t > cpp::strident::make  (const str::__t &val)
{
    ivy::ptr< cpp::ident::__t > res;
    {
        cpp::strident::__t s;
        s . val = val;
        res = s;
    }
    return res;
}
ivy::ptr< cpp::ident::__t > cpp::strident::make1  (const str::__t &val,const ivy::ptr< cpp::ident::__t >
    &arg)
{
    ivy::ptr< cpp::ident::__t > res;
    {
        cpp::strident::__t s;
        s . val = val;
        s . subscrs . append (arg);
        res = s;
    }
    return res;
}
str::__t cpp::strident::__t::to_str () const
{
    str::__t b;
    {
        b = (*this) . val;
        if (ivy::native_bool (true))
        {
            if ((*this) . subscrs . end > vector__cpp__ident::domain::__t (0))
            {
                b . extend (ivy::from_str< str::__t > ("< "));
                vector__cpp__ident::domain::__t idx;
                idx = (*this) . subscrs . begin();
                while (idx < (*this) . subscrs . end)
                {
                    if (idx > vector__cpp__ident::domain::__t (0))
                    {
                        b . extend (ivy::from_str< str::__t > (","));
                    }
                    b . extend ((*this) . subscrs . value (idx) -> to_str());
                    idx = idx . next();
                }
                b . extend (ivy::from_str< str::__t > (" >"));
            }
        } else
        {
            vector__cpp__ident::domain::__t idx;
            idx = (*this) . subscrs . begin();
            while (idx < (*this) . subscrs . end)
            {
                b . extend (ivy::from_str< str::__t > ("["));
                b . extend ((*this) . subscrs . value (idx) -> to_str());
                b . extend (ivy::from_str< str::__t > ("]"));
                idx = idx . next();
            }
        }
    }
    return b;
}
ivy::ptr< cpp::ident::__t > cpp::strident::__t::prefix  (const ivy::ptr< cpp::ident::__t > &pref)
    const {
    ivy::ptr< cpp::ident::__t > res;
    res = cpp::dotident::make (pref,(*this));
    return res;
}
void cpp::strident::parse  (pstate::__t &st,cpp::strident::__t &id)
{
    if (st . ok & st . tok . end != pos::__t (0))
    {
        id . val = st . tok;
        st . consume();
        while (st . ok & st . tok == ivy::from_str< str::__t > ("["))
        {
            st . consume();
            cpp::strident::__t mid;
            cpp::strident::parse (st,mid);
            ivy::ptr< cpp::ident::__t > sid;
            sid = mid;
            while (st . ok & st . tok == ivy::from_str< str::__t > ("."))
            {
                st . consume();
                cpp::strident::parse (st,mid);
                sid = cpp::dotident::make (sid,mid);
            }
            if (st . ok & st . tok == ivy::from_str< str::__t > ("]"))
            {
                st . consume();
                id . subscrs . append (sid);
            } else {
                st . ok = ivy::native_bool (false);
            }
        }
    } else {
        st . ok = ivy::native_bool (false);
    }
}
cpp::strident::__t cpp::strident::__t::get_last () const
{
    cpp::strident::__t res;
    res = (*this);
    return res;
}
cpp::verb::__t cpp::strident::__t::get_verb () const
{
    cpp::verb::__t vrb;
    vrb = cpp::verb_from_name ((*this) . val);
    return vrb;
}
void cpp::numident::__t::encode  (pretty::__t &b,const priority::__t &prio) const
{
    b . extend (ivy::from_str< str::__t > ("["));
    b . extend ((*this) . val . to_str());
    b . extend (ivy::from_str< str::__t > ("]"));
}
ivy::ptr< cpp::ident::__t > cpp::numident::make  (const pos::__t &val)
{
    ivy::ptr< cpp::ident::__t > res;
    {
        cpp::numident::__t s;
        s . val = val;
        res = s;
    }
    return res;
}
void cpp::dotident::__t::encode  (pretty::__t &b,const priority::__t &prio) const
{
    (*this) . namesp -> encode (b,priority::__t (0));
    b . extend (ivy::native_bool (true) ? ivy::from_str< str::__t > ("::") :
            ivy::from_str< str::__t > ("."));
    (*this) . member . encode (b,priority::__t (0));
}
ivy::ptr< cpp::ident::__t > cpp::dotident::make  (const ivy::ptr< cpp::ident::__t > &namesp,const
    cpp::strident::__t &member)
{
    ivy::ptr< cpp::ident::__t > res;
    {
        cpp::dotident::__t s;
        s . namesp = namesp;
        s . member = member;
        res = s;
    }
    return res;
}
str::__t cpp::dotident::__t::to_str () const
{
    str::__t res;
    {
        res = (*this) . namesp -> to_str();
        res . extend (ivy::native_bool (true) ? ivy::from_str< str::__t > ("::") :
                ivy::from_str< str::__t > ("."));
        res . extend ((*this) . member . to_str());
    }
    return res;
}
ivy::ptr< cpp::ident::__t > cpp::dotident::__t::get_namesp () const
{
    ivy::ptr< cpp::ident::__t > res;
    res = (*this) . namesp;
    return res;
}
ivy::ptr< cpp::ident::__t > cpp::dotident::__t::get_member () const
{
    ivy::ptr< cpp::ident::__t > res;
    res = (*this) . member;
    return res;
}
ivy::ptr< cpp::ident::__t > cpp::dotident::__t::prefix  (const ivy::ptr< cpp::ident::__t > &pref)
    const
{
    ivy::ptr< cpp::ident::__t > res;
    res = cpp::dotident::make ((*this) . namesp -> prefix (pref),(*this) . member);
    return res;
}
cpp::strident::__t cpp::dotident::__t::get_last () const
{
    cpp::strident::__t res;
    res = (*this) . member;
    return res;
}
void cpp::expr::__t::encode  (pretty::__t &b,const priority::__t &prio) const {}
str::__t cpp::expr::__t::enc () const
{
    str::__t s;
    {
        pretty::__t p;
        p = pretty::make (pos::__t (100),pos::__t (4));
        p . cppstyle = ivy::native_bool (true);
        (*this) . encode (p,priority::__t (0));
        p . flush();
        s = p . output;
    }
    return s;
}
ivy::ptr< cpp::expr::__t > cpp::expr::dec  (const str::__t &s)
{
    ivy::ptr< cpp::expr::__t > e;
    {
        pstate::__t st;
        st = pstate::make (s);
        cpp::expr::parse (st,priority::__t (0),e);
        if (! st . ok | st . tok . end != pos::__t (0)) {
            parse_error (st . ann . line,st . tok);
        }
    }
    return e;
}
str::__t cpp::expr::encdec  (const str::__t &s)
{
    str::__t res;
    {
        ivy::ptr< cpp::expr::__t > e;
        e = cpp::expr::dec (s);
        res = e -> enc();
    }
    return res;
}
cpp::verb::__t cpp::expr::__t::get_verb () const
{
    cpp::verb::__t vrb;
    vrb = cpp::verb::__t (cpp::verb::none);
    return vrb;
}
cpp::verb::__t cpp::expr::__t::get_verb_typed () const
{
    cpp::verb::__t vrb;
    if ((*this) . is (cpp::verb::__t (cpp::verb::colon)))
    {
        vrb = (*this) . get_arg (vector__cpp__expr::domain::__t (0)) -> get_verb();
    } else {
        vrb = (*this) . get_verb();
    }
    return vrb;
}
__bool cpp::expr::__t::is  (const cpp::verb::__t &vrb) const
{
    __bool res;
    res = ivy::native_bool (false);
    return res;
}
__bool cpp::expr::__t::is_typed  (const cpp::verb::__t &vrb) const
{
    __bool res;
    res = ivy::native_bool (false);
    return res;
}
ivy::ptr< cpp::expr::__t > cpp::expr::__t::get_arg  (const vector__cpp__expr::domain::__t &p) const
{
    ivy::ptr< cpp::expr::__t > res;
    {}
    return res;
}
ivy::ptr< cpp::ident::__t > cpp::expr::__t::get_name () const
{
    ivy::ptr< cpp::ident::__t > res;
    {}
    return res;
}
cpp::verb::__t cpp::expr::__t::app_verb () const {
    cpp::verb::__t res;
    {}
    return res;
}
ivy::ptr< annot::__t > cpp::expr::__t::get_ann () const {
    ivy::ptr< annot::__t > res;
    {}
    return res;
}
ivy::ptr< cpp::expr::__t > cpp::expr::__t::get_func () const
{
    ivy::ptr< cpp::expr::__t > res;
    {}
    return res;
}
vector__cpp__expr::__t cpp::expr::__t::get_args () const {
    vector__cpp__expr::__t res;
    {}
    return res;
}
ivy::ptr< cpp::expr::__t > cpp::expr::__t::prefix  (const ivy::ptr< cpp::ident::__t > &pref) const
{
    ivy::ptr< cpp::expr::__t > res;
    {}
    return res;
}
__bool cpp::expr::__t::eq  (const ivy::ptr< cpp::expr::__t > &e2) const
{
    __bool res;
    if (ivy::isa< cpp::symbol::__t > ((*this)))
    {
        if (e2 . isa< cpp::symbol::__t >()) {
            res = (*this) . get_name() == e2 -> get_name();
        }
    } else
    {
        if (ivy::isa< cpp::app::__t > ((*this)))
        {
            if ((*this) . get_func() -> eq (e2 -> get_func()))
            {
                vector__cpp__expr::__t args1;
                args1 = (*this) . get_args();
                vector__cpp__expr::__t args2;
                args2 = e2 -> get_args();
                if (args1 . end == args2 . end)
                {
                    res = ivy::native_bool (true);
                    vector__cpp__expr::domain::__t idx;
                    idx = args1 . begin();
                    while (res & idx < args1 . end)
                    {
                        if (! args1 . value (idx) -> eq (args2 . value (idx)))
                        {
                            res = ivy::native_bool (false);
                        }
                        idx = idx . next();
                    }
                }
            }
        }
    }
    return res;
}
ivy::ptr< cpp::expr::__t > cpp::symbol::make  (const ivy::ptr< cpp::ident::__t > &name,const ivy::ptr< annot::__t >
    &ann)
{
    ivy::ptr< cpp::expr::__t > res;
    {
        cpp::symbol::__t s;
        s . name = name;
        s . vrb = cpp::verb::__t (cpp::verb::none);
        s . ann = ann;
        res = s;
    }
    return res;
}
ivy::ptr< cpp::expr::__t > cpp::symbol::makestr  (const str::__t &name,const ivy::ptr< annot::__t >
    &ann)
{
    ivy::ptr< cpp::expr::__t > res;
    {
        cpp::symbol::__t s;
        s . name = cpp::strident::make (name);
        s . vrb = cpp::verb_from_name (name);
        s . ann = ann;
        res = s;
    }
    return res;
}
ivy::ptr< cpp::expr::__t > cpp::symbol::makestr1  (const str::__t &name,const ivy::ptr< cpp::ident::__t >
    &arg,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< cpp::expr::__t > res;
    {
        cpp::symbol::__t s;
        s . name = cpp::strident::make1 (name,arg);
        s . vrb = cpp::verb_from_name (name);
        s . ann = ann;
        res = s;
    }
    return res;
}
ivy::ptr< cpp::expr::__t > cpp::symbol::makenum  (const pos::__t &num,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< cpp::expr::__t > res;
    {
        cpp::symbol::__t s;
        s . name = cpp::numident::make (num);
        s . vrb = cpp::verb::__t (cpp::verb::none);
        s . ann = ann;
        res = s;
    }
    return res;
}
void cpp::symbol::__t::encode  (pretty::__t &b,const priority::__t &prio) const
{
    (*this) . ann -> encode (b);
    (*this) . name -> encode (b,priority::__t (0));
}
void cpp::symbol::parse  (pstate::__t &st,ivy::ptr< cpp::expr::__t > &res)
{
    if (st . ok & st . tok . end != pos::__t (0))
    {
        cpp::symbol::__t s;
        s . vrb = cpp::verb_from_name (st . tok);
        st . get_ann (s . ann);
        cpp::strident::__t id;
        cpp::strident::parse (st,id);
        s . name = id;
        res = s;
    } else {
        st . ok = ivy::native_bool (false);
    }
}
cpp::verb::__t cpp::symbol::__t::get_verb () const
{
    cpp::verb::__t res;
    res = (*this) . vrb;
    return res;
}
ivy::ptr< cpp::ident::__t > cpp::symbol::__t::get_name () const
{
    ivy::ptr< cpp::ident::__t > res;
    res = (*this) . name;
    return res;
}
ivy::ptr< annot::__t > cpp::symbol::__t::get_ann () const
{
    ivy::ptr< annot::__t > res;
    res = (*this) . ann;
    return res;
}
ivy::ptr< cpp::expr::__t > cpp::symbol::__t::prefix  (const ivy::ptr< cpp::ident::__t > &pref) const
{
    ivy::ptr< cpp::expr::__t > res;
    res = cpp::symbol::make ((*this) . get_name() -> prefix (pref),(*this) . get_ann());
    return res;
}
vector__cpp__expr::domain::__t vector__cpp__expr::domain::__t::next () const
{
    vector__cpp__expr::domain::__t y;
    y = (*this) + vector__cpp__expr::domain::__t (1);
    return y;
}
vector__cpp__expr::domain::__t vector__cpp__expr::domain::__t::prev () const
{
    vector__cpp__expr::domain::__t y;
    y = (*this) - vector__cpp__expr::domain::__t (1);
    return y;
}
vector__cpp__expr::domain::__t vector__cpp__expr::__t::begin () const
{
    vector__cpp__expr::domain::__t res;
    res = vector__cpp__expr::domain::__t (0);
    return res;
}
vector__cpp__expr::__t vector__cpp__expr::empty () {
    vector__cpp__expr::__t res;
    {}
    return res;
}
void vector__cpp__expr::__t::set  (const vector__cpp__expr::domain::__t &i,const ivy::ptr< cpp::expr::__t >
    &v) {
    (*this) . value (i) = v;
}
void vector__cpp__expr::__t::append  (const ivy::ptr< cpp::expr::__t > &c)
{
    (*this) . value ((*this) . end) = c;
    (*this) . end = (*this) . end . next();
}
void vector__cpp__expr::__t::extend  (const vector__cpp__expr::__t &x)
{
    vector__cpp__expr::domain::__t idx;
    idx = x . begin();
    while (idx < x . end) {
        (*this) . append (x . value (idx));
        idx = idx . next();
    }
}
void vector__cpp__expr::__t::resize  (const vector__cpp__expr::domain::__t &end)
{
    ivy::resize ((*this) . value,end);
    (*this) . end = end;
}
ivy::ptr< cpp::expr::__t > vector__cpp__expr::__t::back () const
{
    ivy::ptr< cpp::expr::__t > y;
    if ((*this) . end > vector__cpp__expr::domain::__t (0))
    {
        y = (*this) . value ((*this) . end . prev());
    }
    return y;
}
void vector__cpp__expr::__t::pop_back ()
{
    if ((*this) . end > vector__cpp__expr::domain::__t (0))
    {
        vector__cpp__expr::domain::__t size;
        size = (*this) . end . prev();
        (*this) . resize (size);
    }
}
vector__cpp__expr::__t vector__cpp__expr::__t::segment  (const vector__cpp__expr::domain::__t &beg,const
    vector__cpp__expr::domain::__t &en) const
{
    vector__cpp__expr::__t res;
    {
        vector__cpp__expr::domain::__t idx;
        idx = beg;
        while (idx < en & idx < (*this) . end)
        {
            res . append ((*this) . value (idx));
            idx = idx . next();
        }
    }
    return res;
}
void vector__cpp__expr::__t::reverse ()
{
    vector__cpp__expr::domain::__t idx;
    idx = (*this) . begin();
    vector__cpp__expr::domain::__t jdx;
    jdx = (*this) . end . prev();
    while (idx < jdx)
    {
        ivy::ptr< cpp::expr::__t > tmp;
        tmp = (*this) . value (idx);
        (*this) . value (idx) = (*this) . value (jdx);
        (*this) . value (jdx) = tmp;
        jdx = jdx . prev();
        idx = idx . next();
    }
}
ivy::ptr< cpp::expr::__t > cpp::app::make  (const ivy::ptr< cpp::expr::__t > &func,const
    vector__cpp__expr::__t &args,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< cpp::expr::__t > res;
    {
        cpp::app::__t s;
        s . func = func;
        s . args = args;
        s . ann = ann;
        res = s;
    }
    return res;
}
ivy::ptr< cpp::expr::__t > cpp::app::make1  (const ivy::ptr< cpp::expr::__t > &func,const ivy::ptr< cpp::expr::__t >
    &arg0,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< cpp::expr::__t > res;
    {
        cpp::app::__t s;
        s . func = func;
        s . args . append (arg0);
        s . ann = ann;
        res = s;
    }
    return res;
}
ivy::ptr< cpp::expr::__t > cpp::app::make2  (const ivy::ptr< cpp::expr::__t > &func,const ivy::ptr< cpp::expr::__t >
    &arg0,const ivy::ptr< cpp::expr::__t > &arg1,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< cpp::expr::__t > res;
    {
        cpp::app::__t s;
        s . func = func;
        s . args . append (arg0);
        s . args . append (arg1);
        s . ann = ann;
        res = s;
    }
    return res;
}
void cpp::app::__t::encode  (pretty::__t &b,const priority::__t &prio) const
{
    (*this) . ann -> encode (b);
    cpp::verb::__t vrb;
    vrb = (*this) . func -> get_verb();
    if (vrb != cpp::verb::__t (cpp::verb::none))
    {
        priority::__t opprio;
        opprio = cpp::verb_to_prio (vrb);
        if (opprio < prio) {
            b . nest();
            b . extend (ivy::from_str< str::__t > ("("));
        }
        if ((*this) . args . end == vector__cpp__expr::domain::__t (1))
        {
            b . extend (cpp::verb_to_str (vrb));
            b . extend (ivy::from_str< str::__t > (" "));
            (*this) . args . value (vector__cpp__expr::domain::__t (0)) -> encode (b,opprio);
        } else
        {
            (*this) . args . value (vector__cpp__expr::domain::__t (0)) -> encode (b,opprio);
            b . extend (ivy::from_str< str::__t > (" "));
            b . extend (cpp::verb_to_str (vrb));
            b . extend (ivy::from_str< str::__t > (" "));
            (*this) . args . value (vector__cpp__expr::domain::__t (1)) -> encode (b,opprio +
                    priority::__t (1));
            if (vrb == cpp::verb::__t (cpp::verb::ite))
            {
                b . extend (ivy::from_str< str::__t > (" "));
                b . extend (ivy::native_bool (true) ? ivy::from_str< str::__t > (":") :
                        ivy::from_str< str::__t > ("else"));
                b . extend (ivy::from_str< str::__t > (" "));
                (*this) . args . value (vector__cpp__expr::domain::__t (2)) -> encode (b,opprio +
                        priority::__t (1));
            }
        }
        if (opprio < prio) {
            b . extend (ivy::from_str< str::__t > (")"));
            b . unnest();
        }
    } else
    {
        b . nest();
        (*this) . func -> encode (b,priority::__t (99));
        if ((*this) . args . end == vector__cpp__expr::domain::__t (0))
        {
            b . extend (ivy::from_str< str::__t > ("()"));
        } else {
            cpp::expr::tup::encode ((*this) . args,b,priority::__t (0));
        }
        b . unnest();
    }
}
__bool cpp::app::__t::is  (const cpp::verb::__t &vrb) const
{
    __bool res;
    res = (*this) . func -> get_verb() == vrb;
    return res;
}
__bool cpp::app::__t::is_typed  (const cpp::verb::__t &vrb) const
{
    __bool res;
    res = (*this) . is (vrb) | (*this) . func -> is (cpp::verb::__t (cpp::verb::colon)) &
        (*this) . func -> get_arg (vector__cpp__expr::domain::__t (0)) -> get_verb() == vrb;
    return res;
}
cpp::verb::__t cpp::app::__t::app_verb () const
{
    cpp::verb::__t res;
    res = (*this) . func -> get_verb();
    return res;
}
ivy::ptr< cpp::expr::__t > cpp::app::__t::get_func () const
{
    ivy::ptr< cpp::expr::__t > res;
    res = (*this) . func;
    return res;
}
vector__cpp__expr::__t cpp::app::__t::get_args () const
{
    vector__cpp__expr::__t res;
    res = (*this) . args;
    return res;
}
ivy::ptr< cpp::expr::__t > cpp::app::__t::get_arg  (const vector__cpp__expr::domain::__t &p) const
{
    ivy::ptr< cpp::expr::__t > res;
    res = (*this) . args . value (p);
    return res;
}
ivy::ptr< annot::__t > cpp::app::__t::get_ann () const
{
    ivy::ptr< annot::__t > res;
    res = (*this) . ann;
    return res;
}
ivy::ptr< cpp::expr::__t > cpp::variable::make  (const pos::__t &idx)
{
    ivy::ptr< cpp::expr::__t > res;
    {
        cpp::variable::__t s;
        s . idx = idx;
        res = s;
    }
    return res;
}
ivy::ptr< cpp::expr::__t > cpp::pi::make  (const vector__cpp__expr::__t &vars,const ivy::ptr< cpp::expr::__t >
    &body,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< cpp::expr::__t > res;
    {
        cpp::pi::__t s;
        s . vars = vars;
        s . ann = ann;
        res = s;
    }
    return res;
}
void cpp::pi::__t::encode  (pretty::__t &b,const priority::__t &prio) const
{
    (*this) . ann -> encode (b);
    b . nest();
    b . extend (ivy::from_str< str::__t > ("pi"));
    b . extend (ivy::from_str< str::__t > (" "));
    cpp::expr::tup::encode ((*this) . vars,b,priority::__t (0));
    b . extend (ivy::from_str< str::__t > ("."));
    b . extend (ivy::from_str< str::__t > (" "));
    (*this) . body -> encode (b,priority::__t (0));
    b . extend (ivy::from_str< str::__t > (";"));
    b . unnest();
}
ivy::ptr< cpp::expr::__t > cpp::iff::make  (const ivy::ptr< cpp::expr::__t > &lhs,const ivy::ptr< cpp::expr::__t >
    &rhs,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< cpp::expr::__t > res;
    {
        cpp::app::__t s;
        s . func = cpp::symbol::makestr (ivy::from_str< str::__t > ("<->"),ann);
        s . args . append (lhs);
        s . args . append (rhs);
        s . ann = ann;
        res = s;
    }
    return res;
}
ivy::ptr< cpp::expr::__t > cpp::iff::fold_left  (const vector__cpp__expr::__t &args,const ivy::ptr< annot::__t >
    &ann)
{
    ivy::ptr< cpp::expr::__t > res;
    if (args . end > vector__cpp__expr::domain::__t (0))
    {
        res = args . value (vector__cpp__expr::domain::__t (0));
        vector__cpp__expr::domain::__t idx;
        idx = args . begin() . next();
        while (idx < args . end)
        {
            res = cpp::iff::make (res,args . value (idx),ann);
            idx = idx . next();
        }
    } else {
        res = cpp::empty::make (ann);
    }
    return res;
}
vector__cpp__expr::__t cpp::iff::unfold_left  (const ivy::ptr< cpp::expr::__t > &s)
{
    vector__cpp__expr::__t args;
    {
        ivy::ptr< cpp::expr::__t > e;
        e = s;
        __bool b;
        b = e -> is_typed (cpp::verb::__t (cpp::verb::iff));
        while (b)
        {
            args . append (e -> get_arg (vector__cpp__expr::domain::__t (1)));
            e = e -> get_arg (vector__cpp__expr::domain::__t (0));
            b = e -> is_typed (cpp::verb::__t (cpp::verb::iff));
        }
        args . append (e);
        args . reverse();
    }
    return args;
}
ivy::ptr< cpp::expr::__t > cpp::__or::make  (const ivy::ptr< cpp::expr::__t > &lhs,const ivy::ptr< cpp::expr::__t >
    &rhs,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< cpp::expr::__t > res;
    {
        cpp::app::__t s;
        s . func = cpp::symbol::makestr (ivy::from_str< str::__t > ("|"),ann);
        s . args . append (lhs);
        s . args . append (rhs);
        s . ann = ann;
        res = s;
    }
    return res;
}
ivy::ptr< cpp::expr::__t > cpp::__or::fold_left  (const vector__cpp__expr::__t &args,const ivy::ptr< annot::__t >
    &ann)
{
    ivy::ptr< cpp::expr::__t > res;
    if (args . end > vector__cpp__expr::domain::__t (0))
    {
        res = args . value (vector__cpp__expr::domain::__t (0));
        vector__cpp__expr::domain::__t idx;
        idx = args . begin() . next();
        while (idx < args . end)
        {
            res = cpp::__or::make (res,args . value (idx),ann);
            idx = idx . next();
        }
    } else {
        res = cpp::empty::make (ann);
    }
    return res;
}
vector__cpp__expr::__t cpp::__or::unfold_left  (const ivy::ptr< cpp::expr::__t > &s)
{
    vector__cpp__expr::__t args;
    {
        ivy::ptr< cpp::expr::__t > e;
        e = s;
        __bool b;
        b = e -> is_typed (cpp::verb::__t (cpp::verb::__or));
        while (b)
        {
            args . append (e -> get_arg (vector__cpp__expr::domain::__t (1)));
            e = e -> get_arg (vector__cpp__expr::domain::__t (0));
            b = e -> is_typed (cpp::verb::__t (cpp::verb::__or));
        }
        args . append (e);
        args . reverse();
    }
    return args;
}
ivy::ptr< cpp::expr::__t > cpp::__and::make  (const ivy::ptr< cpp::expr::__t > &lhs,const ivy::ptr< cpp::expr::__t >
    &rhs,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< cpp::expr::__t > res;
    {
        cpp::app::__t s;
        s . func = cpp::symbol::makestr (ivy::from_str< str::__t > ("&"),ann);
        s . args . append (lhs);
        s . args . append (rhs);
        s . ann = ann;
        res = s;
    }
    return res;
}
ivy::ptr< cpp::expr::__t > cpp::__and::fold_left  (const vector__cpp__expr::__t &args,const ivy::ptr< annot::__t >
    &ann)
{
    ivy::ptr< cpp::expr::__t > res;
    if (args . end > vector__cpp__expr::domain::__t (0))
    {
        res = args . value (vector__cpp__expr::domain::__t (0));
        vector__cpp__expr::domain::__t idx;
        idx = args . begin() . next();
        while (idx < args . end)
        {
            res = cpp::__and::make (res,args . value (idx),ann);
            idx = idx . next();
        }
    } else {
        res = cpp::empty::make (ann);
    }
    return res;
}
vector__cpp__expr::__t cpp::__and::unfold_left  (const ivy::ptr< cpp::expr::__t > &s)
{
    vector__cpp__expr::__t args;
    {
        ivy::ptr< cpp::expr::__t > e;
        e = s;
        __bool b;
        b = e -> is_typed (cpp::verb::__t (cpp::verb::__and));
        while (b)
        {
            args . append (e -> get_arg (vector__cpp__expr::domain::__t (1)));
            e = e -> get_arg (vector__cpp__expr::domain::__t (0));
            b = e -> is_typed (cpp::verb::__t (cpp::verb::__and));
        }
        args . append (e);
        args . reverse();
    }
    return args;
}
ivy::ptr< cpp::expr::__t > cpp::lt::make  (const ivy::ptr< cpp::expr::__t > &lhs,const ivy::ptr< cpp::expr::__t >
    &rhs,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< cpp::expr::__t > res;
    {
        cpp::app::__t s;
        s . func = cpp::symbol::makestr (ivy::from_str< str::__t > ("<"),ann);
        s . args . append (lhs);
        s . args . append (rhs);
        s . ann = ann;
        res = s;
    }
    return res;
}
ivy::ptr< cpp::expr::__t > cpp::lt::fold_left  (const vector__cpp__expr::__t &args,const ivy::ptr< annot::__t >
    &ann)
{
    ivy::ptr< cpp::expr::__t > res;
    if (args . end > vector__cpp__expr::domain::__t (0))
    {
        res = args . value (vector__cpp__expr::domain::__t (0));
        vector__cpp__expr::domain::__t idx;
        idx = args . begin() . next();
        while (idx < args . end)
        {
            res = cpp::lt::make (res,args . value (idx),ann);
            idx = idx . next();
        }
    } else {
        res = cpp::empty::make (ann);
    }
    return res;
}
vector__cpp__expr::__t cpp::lt::unfold_left  (const ivy::ptr< cpp::expr::__t > &s)
{
    vector__cpp__expr::__t args;
    {
        ivy::ptr< cpp::expr::__t > e;
        e = s;
        __bool b;
        b = e -> is_typed (cpp::verb::__t (cpp::verb::lt));
        while (b)
        {
            args . append (e -> get_arg (vector__cpp__expr::domain::__t (1)));
            e = e -> get_arg (vector__cpp__expr::domain::__t (0));
            b = e -> is_typed (cpp::verb::__t (cpp::verb::lt));
        }
        args . append (e);
        args . reverse();
    }
    return args;
}
ivy::ptr< cpp::expr::__t > cpp::leq::make  (const ivy::ptr< cpp::expr::__t > &lhs,const ivy::ptr< cpp::expr::__t >
    &rhs,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< cpp::expr::__t > res;
    {
        cpp::app::__t s;
        s . func = cpp::symbol::makestr (ivy::from_str< str::__t > ("<="),ann);
        s . args . append (lhs);
        s . args . append (rhs);
        s . ann = ann;
        res = s;
    }
    return res;
}
ivy::ptr< cpp::expr::__t > cpp::leq::fold_left  (const vector__cpp__expr::__t &args,const ivy::ptr< annot::__t >
    &ann)
{
    ivy::ptr< cpp::expr::__t > res;
    if (args . end > vector__cpp__expr::domain::__t (0))
    {
        res = args . value (vector__cpp__expr::domain::__t (0));
        vector__cpp__expr::domain::__t idx;
        idx = args . begin() . next();
        while (idx < args . end)
        {
            res = cpp::leq::make (res,args . value (idx),ann);
            idx = idx . next();
        }
    } else {
        res = cpp::empty::make (ann);
    }
    return res;
}
vector__cpp__expr::__t cpp::leq::unfold_left  (const ivy::ptr< cpp::expr::__t > &s)
{
    vector__cpp__expr::__t args;
    {
        ivy::ptr< cpp::expr::__t > e;
        e = s;
        __bool b;
        b = e -> is_typed (cpp::verb::__t (cpp::verb::leq));
        while (b)
        {
            args . append (e -> get_arg (vector__cpp__expr::domain::__t (1)));
            e = e -> get_arg (vector__cpp__expr::domain::__t (0));
            b = e -> is_typed (cpp::verb::__t (cpp::verb::leq));
        }
        args . append (e);
        args . reverse();
    }
    return args;
}
ivy::ptr< cpp::expr::__t > cpp::gt::make  (const ivy::ptr< cpp::expr::__t > &lhs,const ivy::ptr< cpp::expr::__t >
    &rhs,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< cpp::expr::__t > res;
    {
        cpp::app::__t s;
        s . func = cpp::symbol::makestr (ivy::from_str< str::__t > (">"),ann);
        s . args . append (lhs);
        s . args . append (rhs);
        s . ann = ann;
        res = s;
    }
    return res;
}
ivy::ptr< cpp::expr::__t > cpp::gt::fold_left  (const vector__cpp__expr::__t &args,const ivy::ptr< annot::__t >
    &ann)
{
    ivy::ptr< cpp::expr::__t > res;
    if (args . end > vector__cpp__expr::domain::__t (0))
    {
        res = args . value (vector__cpp__expr::domain::__t (0));
        vector__cpp__expr::domain::__t idx;
        idx = args . begin() . next();
        while (idx < args . end)
        {
            res = cpp::gt::make (res,args . value (idx),ann);
            idx = idx . next();
        }
    } else {
        res = cpp::empty::make (ann);
    }
    return res;
}
vector__cpp__expr::__t cpp::gt::unfold_left  (const ivy::ptr< cpp::expr::__t > &s)
{
    vector__cpp__expr::__t args;
    {
        ivy::ptr< cpp::expr::__t > e;
        e = s;
        __bool b;
        b = e -> is_typed (cpp::verb::__t (cpp::verb::gt));
        while (b)
        {
            args . append (e -> get_arg (vector__cpp__expr::domain::__t (1)));
            e = e -> get_arg (vector__cpp__expr::domain::__t (0));
            b = e -> is_typed (cpp::verb::__t (cpp::verb::gt));
        }
        args . append (e);
        args . reverse();
    }
    return args;
}
ivy::ptr< cpp::expr::__t > cpp::geq::make  (const ivy::ptr< cpp::expr::__t > &lhs,const ivy::ptr< cpp::expr::__t >
    &rhs,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< cpp::expr::__t > res;
    {
        cpp::app::__t s;
        s . func = cpp::symbol::makestr (ivy::from_str< str::__t > (">="),ann);
        s . args . append (lhs);
        s . args . append (rhs);
        s . ann = ann;
        res = s;
    }
    return res;
}
ivy::ptr< cpp::expr::__t > cpp::geq::fold_left  (const vector__cpp__expr::__t &args,const ivy::ptr< annot::__t >
    &ann)
{
    ivy::ptr< cpp::expr::__t > res;
    if (args . end > vector__cpp__expr::domain::__t (0))
    {
        res = args . value (vector__cpp__expr::domain::__t (0));
        vector__cpp__expr::domain::__t idx;
        idx = args . begin() . next();
        while (idx < args . end)
        {
            res = cpp::geq::make (res,args . value (idx),ann);
            idx = idx . next();
        }
    } else {
        res = cpp::empty::make (ann);
    }
    return res;
}
vector__cpp__expr::__t cpp::geq::unfold_left  (const ivy::ptr< cpp::expr::__t > &s)
{
    vector__cpp__expr::__t args;
    {
        ivy::ptr< cpp::expr::__t > e;
        e = s;
        __bool b;
        b = e -> is_typed (cpp::verb::__t (cpp::verb::geq));
        while (b)
        {
            args . append (e -> get_arg (vector__cpp__expr::domain::__t (1)));
            e = e -> get_arg (vector__cpp__expr::domain::__t (0));
            b = e -> is_typed (cpp::verb::__t (cpp::verb::geq));
        }
        args . append (e);
        args . reverse();
    }
    return args;
}
ivy::ptr< cpp::expr::__t > cpp::plus::make  (const ivy::ptr< cpp::expr::__t > &lhs,const ivy::ptr< cpp::expr::__t >
    &rhs,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< cpp::expr::__t > res;
    {
        cpp::app::__t s;
        s . func = cpp::symbol::makestr (ivy::from_str< str::__t > ("+"),ann);
        s . args . append (lhs);
        s . args . append (rhs);
        s . ann = ann;
        res = s;
    }
    return res;
}
ivy::ptr< cpp::expr::__t > cpp::plus::fold_left  (const vector__cpp__expr::__t &args,const ivy::ptr< annot::__t >
    &ann)
{
    ivy::ptr< cpp::expr::__t > res;
    if (args . end > vector__cpp__expr::domain::__t (0))
    {
        res = args . value (vector__cpp__expr::domain::__t (0));
        vector__cpp__expr::domain::__t idx;
        idx = args . begin() . next();
        while (idx < args . end)
        {
            res = cpp::plus::make (res,args . value (idx),ann);
            idx = idx . next();
        }
    } else {
        res = cpp::empty::make (ann);
    }
    return res;
}
vector__cpp__expr::__t cpp::plus::unfold_left  (const ivy::ptr< cpp::expr::__t > &s)
{
    vector__cpp__expr::__t args;
    {
        ivy::ptr< cpp::expr::__t > e;
        e = s;
        __bool b;
        b = e -> is_typed (cpp::verb::__t (cpp::verb::plus));
        while (b)
        {
            args . append (e -> get_arg (vector__cpp__expr::domain::__t (1)));
            e = e -> get_arg (vector__cpp__expr::domain::__t (0));
            b = e -> is_typed (cpp::verb::__t (cpp::verb::plus));
        }
        args . append (e);
        args . reverse();
    }
    return args;
}
ivy::ptr< cpp::expr::__t > cpp::minus::make  (const ivy::ptr< cpp::expr::__t > &lhs,const ivy::ptr< cpp::expr::__t >
    &rhs,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< cpp::expr::__t > res;
    {
        cpp::app::__t s;
        s . func = cpp::symbol::makestr (ivy::from_str< str::__t > ("-"),ann);
        s . args . append (lhs);
        s . args . append (rhs);
        s . ann = ann;
        res = s;
    }
    return res;
}
ivy::ptr< cpp::expr::__t > cpp::minus::fold_left  (const vector__cpp__expr::__t &args,const ivy::ptr< annot::__t >
    &ann)
{
    ivy::ptr< cpp::expr::__t > res;
    if (args . end > vector__cpp__expr::domain::__t (0))
    {
        res = args . value (vector__cpp__expr::domain::__t (0));
        vector__cpp__expr::domain::__t idx;
        idx = args . begin() . next();
        while (idx < args . end)
        {
            res = cpp::minus::make (res,args . value (idx),ann);
            idx = idx . next();
        }
    } else {
        res = cpp::empty::make (ann);
    }
    return res;
}
vector__cpp__expr::__t cpp::minus::unfold_left  (const ivy::ptr< cpp::expr::__t > &s)
{
    vector__cpp__expr::__t args;
    {
        ivy::ptr< cpp::expr::__t > e;
        e = s;
        __bool b;
        b = e -> is_typed (cpp::verb::__t (cpp::verb::minus));
        while (b)
        {
            args . append (e -> get_arg (vector__cpp__expr::domain::__t (1)));
            e = e -> get_arg (vector__cpp__expr::domain::__t (0));
            b = e -> is_typed (cpp::verb::__t (cpp::verb::minus));
        }
        args . append (e);
        args . reverse();
    }
    return args;
}
ivy::ptr< cpp::expr::__t > cpp::times::make  (const ivy::ptr< cpp::expr::__t > &lhs,const ivy::ptr< cpp::expr::__t >
    &rhs,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< cpp::expr::__t > res;
    {
        cpp::app::__t s;
        s . func = cpp::symbol::makestr (ivy::from_str< str::__t > ("*"),ann);
        s . args . append (lhs);
        s . args . append (rhs);
        s . ann = ann;
        res = s;
    }
    return res;
}
ivy::ptr< cpp::expr::__t > cpp::times::fold_left  (const vector__cpp__expr::__t &args,const ivy::ptr< annot::__t >
    &ann)
{
    ivy::ptr< cpp::expr::__t > res;
    if (args . end > vector__cpp__expr::domain::__t (0))
    {
        res = args . value (vector__cpp__expr::domain::__t (0));
        vector__cpp__expr::domain::__t idx;
        idx = args . begin() . next();
        while (idx < args . end)
        {
            res = cpp::times::make (res,args . value (idx),ann);
            idx = idx . next();
        }
    } else {
        res = cpp::empty::make (ann);
    }
    return res;
}
vector__cpp__expr::__t cpp::times::unfold_left  (const ivy::ptr< cpp::expr::__t > &s)
{
    vector__cpp__expr::__t args;
    {
        ivy::ptr< cpp::expr::__t > e;
        e = s;
        __bool b;
        b = e -> is_typed (cpp::verb::__t (cpp::verb::times));
        while (b)
        {
            args . append (e -> get_arg (vector__cpp__expr::domain::__t (1)));
            e = e -> get_arg (vector__cpp__expr::domain::__t (0));
            b = e -> is_typed (cpp::verb::__t (cpp::verb::times));
        }
        args . append (e);
        args . reverse();
    }
    return args;
}
ivy::ptr< cpp::expr::__t > cpp::div::make  (const ivy::ptr< cpp::expr::__t > &lhs,const ivy::ptr< cpp::expr::__t >
    &rhs,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< cpp::expr::__t > res;
    {
        cpp::app::__t s;
        s . func = cpp::symbol::makestr (ivy::from_str< str::__t > ("/"),ann);
        s . args . append (lhs);
        s . args . append (rhs);
        s . ann = ann;
        res = s;
    }
    return res;
}
ivy::ptr< cpp::expr::__t > cpp::div::fold_left  (const vector__cpp__expr::__t &args,const ivy::ptr< annot::__t >
    &ann)
{
    ivy::ptr< cpp::expr::__t > res;
    if (args . end > vector__cpp__expr::domain::__t (0))
    {
        res = args . value (vector__cpp__expr::domain::__t (0));
        vector__cpp__expr::domain::__t idx;
        idx = args . begin() . next();
        while (idx < args . end)
        {
            res = cpp::div::make (res,args . value (idx),ann);
            idx = idx . next();
        }
    } else {
        res = cpp::empty::make (ann);
    }
    return res;
}
vector__cpp__expr::__t cpp::div::unfold_left  (const ivy::ptr< cpp::expr::__t > &s)
{
    vector__cpp__expr::__t args;
    {
        ivy::ptr< cpp::expr::__t > e;
        e = s;
        __bool b;
        b = e -> is_typed (cpp::verb::__t (cpp::verb::div));
        while (b)
        {
            args . append (e -> get_arg (vector__cpp__expr::domain::__t (1)));
            e = e -> get_arg (vector__cpp__expr::domain::__t (0));
            b = e -> is_typed (cpp::verb::__t (cpp::verb::div));
        }
        args . append (e);
        args . reverse();
    }
    return args;
}
ivy::ptr< cpp::expr::__t > cpp::empty::make  (const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< cpp::expr::__t > res;
    res = cpp::symbol::makestr (ivy::from_str< str::__t > ("()"),ann);
    return res;
}
ivy::ptr< cpp::expr::__t > cpp::boolv::make  (const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< cpp::expr::__t > res;
    res = cpp::symbol::makestr (ivy::from_str< str::__t > ("bool"),ann);
    return res;
}
ivy::ptr< cpp::expr::__t > cpp::truev::make  (const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< cpp::expr::__t > res;
    res = cpp::symbol::makestr (ivy::from_str< str::__t > ("true"),ann);
    return res;
}
ivy::ptr< cpp::expr::__t > cpp::falsev::make  (const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< cpp::expr::__t > res;
    res = cpp::symbol::makestr (ivy::from_str< str::__t > ("false"),ann);
    return res;
}
ivy::ptr< cpp::expr::__t > cpp::comma::make  (const ivy::ptr< cpp::expr::__t > &lhs,const ivy::ptr< cpp::expr::__t >
    &rhs,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< cpp::expr::__t > res;
    {
        cpp::app::__t s;
        s . func = cpp::symbol::makestr (ivy::from_str< str::__t > (","),ann);
        s . args . append (lhs);
        s . args . append (rhs);
        s . ann = ann;
        res = s;
    }
    return res;
}
ivy::ptr< cpp::expr::__t > cpp::comma::fold_left  (const vector__cpp__expr::__t &args,const ivy::ptr< annot::__t >
    &ann)
{
    ivy::ptr< cpp::expr::__t > res;
    if (args . end > vector__cpp__expr::domain::__t (0))
    {
        res = args . value (vector__cpp__expr::domain::__t (0));
        vector__cpp__expr::domain::__t idx;
        idx = args . begin() . next();
        while (idx < args . end)
        {
            res = cpp::comma::make (res,args . value (idx),ann);
            idx = idx . next();
        }
    } else {
        res = cpp::empty::make (ann);
    }
    return res;
}
vector__cpp__expr::__t cpp::comma::unfold_left  (const ivy::ptr< cpp::expr::__t > &s)
{
    vector__cpp__expr::__t args;
    {
        ivy::ptr< cpp::expr::__t > e;
        e = s;
        __bool b;
        b = e -> is_typed (cpp::verb::__t (cpp::verb::comma));
        while (b)
        {
            args . append (e -> get_arg (vector__cpp__expr::domain::__t (1)));
            e = e -> get_arg (vector__cpp__expr::domain::__t (0));
            b = e -> is_typed (cpp::verb::__t (cpp::verb::comma));
        }
        args . append (e);
        args . reverse();
    }
    return args;
}
ivy::ptr< cpp::expr::__t > cpp::dot::make  (const ivy::ptr< cpp::expr::__t > &lhs,const ivy::ptr< cpp::expr::__t >
    &rhs,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< cpp::expr::__t > res;
    {
        cpp::app::__t s;
        s . func = cpp::symbol::makestr (ivy::from_str< str::__t > ("."),ann);
        s . args . append (lhs);
        s . args . append (rhs);
        s . ann = ann;
        res = s;
    }
    return res;
}
ivy::ptr< cpp::expr::__t > cpp::dot::fold_left  (const vector__cpp__expr::__t &args,const ivy::ptr< annot::__t >
    &ann)
{
    ivy::ptr< cpp::expr::__t > res;
    if (args . end > vector__cpp__expr::domain::__t (0))
    {
        res = args . value (vector__cpp__expr::domain::__t (0));
        vector__cpp__expr::domain::__t idx;
        idx = args . begin() . next();
        while (idx < args . end)
        {
            res = cpp::dot::make (res,args . value (idx),ann);
            idx = idx . next();
        }
    } else {
        res = cpp::empty::make (ann);
    }
    return res;
}
vector__cpp__expr::__t cpp::dot::unfold_left  (const ivy::ptr< cpp::expr::__t > &s)
{
    vector__cpp__expr::__t args;
    {
        ivy::ptr< cpp::expr::__t > e;
        e = s;
        __bool b;
        b = e -> is_typed (cpp::verb::__t (cpp::verb::dot));
        while (b)
        {
            args . append (e -> get_arg (vector__cpp__expr::domain::__t (1)));
            e = e -> get_arg (vector__cpp__expr::domain::__t (0));
            b = e -> is_typed (cpp::verb::__t (cpp::verb::dot));
        }
        args . append (e);
        args . reverse();
    }
    return args;
}
void cpp::expr::parse  (pstate::__t &st,const priority::__t &prio,ivy::ptr< cpp::expr::__t > &res)
{
    if (st . tok == ivy::from_str< str::__t > ("("))
    {
        st . consume();
        cpp::expr::parse (st,priority::__t (0),res);
        if (st . ok & st . tok == ivy::from_str< str::__t > (")")) {
            st . consume();
        } else {
            st . ok = ivy::native_bool (false);
        }
    } else
    {
        cpp::verb::__t vrb;
        vrb = cpp::str_to_verb (st . tok);
        if (vrb != cpp::verb::__t (cpp::verb::none) & cpp::verb_to_arity (vrb) == pos::__t (1))
        {
            cpp::app::__t s;
            s . func = cpp::symbol::makestr (st . tok,s . ann);
            st . consume();
            ivy::ptr< cpp::expr::__t > arg;
            cpp::expr::parse (st,cpp::verb_to_prio (vrb),arg);
            s . args . append (arg);
            res = s;
        } else {
            cpp::symbol::parse (st,res);
        }
    }
    cpp::verb::__t vrb;
    vrb = cpp::str_to_verb (st . tok);
    while (st . ok & vrb != cpp::verb::__t (cpp::verb::none) & prio < cpp::verb_to_prio (vrb))
    {
        cpp::app::__t s;
        st . get_ann (s . ann);
        if (vrb == cpp::verb::__t (cpp::verb::app))
        {
            s . func = res;
            cpp::expr::tup::parse (st,priority::__t (1),s . args);
        } else
        {
            s . func = cpp::symbol::makestr (st . tok,s . ann);
            st . consume();
            s . args . append (res);
            ivy::ptr< cpp::expr::__t > arg;
            cpp::expr::parse (st,cpp::verb_to_prio (vrb),arg);
            s . args . append (arg);
            if (st . ok & vrb == cpp::verb::__t (cpp::verb::ite))
            {
                if (st . tok ==
                (ivy::native_bool (true) ? ivy::from_str< str::__t > (":") :
                    ivy::from_str< str::__t > ("else")))
                {
                    st . consume();
                    cpp::expr::parse (st,cpp::verb_to_prio (vrb),arg);
                    s . args . append (arg);
                } else {
                    st . ok = ivy::native_bool (false);
                }
            }
        }
        res = s;
        vrb = cpp::str_to_verb (st . tok);
    }
}
void cpp::expr::tup::encode  (const vector__cpp__expr::__t &s,pretty::__t &b,const priority::__t &prio)
{
    if (s . end > vector__cpp__expr::domain::__t (0))
    {
        b . extend (ivy::from_str< str::__t > (" "));
        b . extend (ivy::from_str< str::__t > ("("));
        s . value (vector__cpp__expr::domain::__t (0)) -> encode (b,priority::__t (0));
        vector__cpp__expr::domain::__t idx;
        idx = s . begin() . next();
        while (idx < s . end)
        {
            b . extend (ivy::from_str< str::__t > (","));
            s . value (idx) -> encode (b,priority::__t (0));
            idx = idx . next();
        }
        b . extend (ivy::from_str< str::__t > (")"));
    }
}
void cpp::expr::tup::parse  (pstate::__t &st,const priority::__t &prio,vector__cpp__expr::__t &res)
{
    if (st . tok == ivy::from_str< str::__t > ("("))
    {
        st . consume();
        ivy::ptr< cpp::expr::__t > s;
        cpp::expr::parse (st,prio,s);
        res . append (s);
        while (st . ok & st . tok == ivy::from_str< str::__t > (","))
        {
            st . consume();
            cpp::expr::parse (st,prio,s);
            res . append (s);
        }
        if (st . ok & st . tok == ivy::from_str< str::__t > (")")) {
            st . consume();
        } else {
            st . ok = ivy::native_bool (false);
        }
    } else {
        st . ok = ivy::native_bool (false);
    }
}
void cpp::stmt::__t::encode  (pretty::__t &b,const priority::__t &prio) const {}
str::__t cpp::stmt::__t::enc () const
{
    str::__t s;
    {
        pretty::__t p;
        p = pretty::make (pos::__t (100),pos::__t (4));
        p . cppstyle = ivy::native_bool (true);
        (*this) . encode (p,priority::__t (0));
        p . flush();
        s = p . output;
    }
    return s;
}
ivy::ptr< cpp::stmt::__t > cpp::stmt::dec  (const str::__t &s)
{
    ivy::ptr< cpp::stmt::__t > e;
    {
        pstate::__t st;
        st = pstate::make (s);
        cpp::stmt::parse (st,priority::__t (0),e);
        if (! st . ok | st . tok . end != pos::__t (0)) {
            parse_error (st . ann . line,st . tok);
        }
    }
    return e;
}
str::__t cpp::stmt::encdec  (const str::__t &s)
{
    str::__t res;
    {
        ivy::ptr< cpp::stmt::__t > e;
        e = cpp::stmt::dec (s);
        res = e -> enc();
    }
    return res;
}
ivy::ptr< cpp::expr::__t > cpp::stmt::__t::get_expr () const
{
    ivy::ptr< cpp::expr::__t > res;
    {}
    return res;
}
ivy::ptr< cpp::expr::__t > cpp::stmt::__t::get_lhs () const
{
    ivy::ptr< cpp::expr::__t > res;
    {}
    return res;
}
ivy::ptr< cpp::expr::__t > cpp::stmt::__t::get_rhs () const
{
    ivy::ptr< cpp::expr::__t > res;
    {}
    return res;
}
ivy::ptr< annot::__t > cpp::stmt::__t::get_ann () const {
    ivy::ptr< annot::__t > res;
    {}
    return res;
}
ivy::ptr< cpp::stmt::__t > cpp::asgn::make  (const ivy::ptr< cpp::expr::__t > &x,const ivy::ptr< cpp::expr::__t >
    &y,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< cpp::stmt::__t > res;
    {
        cpp::asgn::__t s;
        s . lhs = x;
        s . rhs = y;
        s . ann = ann;
        res = s;
    }
    return res;
}
void cpp::asgn::__t::encode  (pretty::__t &b,const priority::__t &prio) const
{
    (*this) . ann -> encode (b);
    if (priority::__t (1) < prio)
    {
        b . nest();
        b . extend (ivy::from_str< str::__t > ("{"));
        b . newline();
    }
    (*this) . encode_int (b,prio);
    if (priority::__t (1) < prio)
    {
        b . unnest();
        b . newline();
        b . extend (ivy::from_str< str::__t > ("}"));
    }
}
void cpp::asgn::__t::encode_int  (pretty::__t &b,const priority::__t &prio) const
{
    b . nest();
    if ((*this) . lhs -> get_verb() != cpp::verb::__t (cpp::verb::empty))
    {
        (*this) . lhs -> encode (b,priority::__t (0));
        b . extend (ivy::from_str< str::__t > (" "));
        b . extend (ivy::from_str< str::__t > ("="));
        b . extend (ivy::from_str< str::__t > (" "));
    }
    (*this) . rhs -> encode (b,priority::__t (0));
    b . extend (ivy::from_str< str::__t > (";"));
    b . unnest();
}
ivy::ptr< cpp::expr::__t > cpp::asgn::__t::get_lhs () const
{
    ivy::ptr< cpp::expr::__t > res;
    res = (*this) . lhs;
    return res;
}
ivy::ptr< cpp::expr::__t > cpp::asgn::__t::get_rhs () const
{
    ivy::ptr< cpp::expr::__t > res;
    res = (*this) . rhs;
    return res;
}
ivy::ptr< annot::__t > cpp::asgn::__t::get_ann () const
{
    ivy::ptr< annot::__t > res;
    res = (*this) . ann;
    return res;
}
ivy::ptr< cpp::stmt::__t > cpp::sequence::make  (const ivy::ptr< cpp::stmt::__t > &x,const ivy::ptr< cpp::stmt::__t >
    &y,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< cpp::stmt::__t > res;
    {
        cpp::sequence::__t s;
        s . lhs = x;
        s . rhs = y;
        s . ann = ann;
        res = s;
    }
    return res;
}
void cpp::sequence::__t::encode  (pretty::__t &b,const priority::__t &prio) const
{
    (*this) . ann -> encode (b);
    if (priority::__t (0) < prio)
    {
        b . nest();
        b . extend (ivy::from_str< str::__t > ("{"));
        b . newline();
    }
    (*this) . encode_int (b,prio);
    if (priority::__t (0) < prio)
    {
        b . unnest();
        b . newline();
        b . extend (ivy::from_str< str::__t > ("}"));
    }
}
void cpp::sequence::__t::encode_int  (pretty::__t &b,const priority::__t &prio) const
{
    (*this) . lhs -> encode (b,priority::__t (1));
    if (! (*this) . rhs . isa< cpp::skipst::__t >())
    {
        b . newline();
        (*this) . rhs -> encode (b,priority::__t (0));
    }
}
vector__cpp__stmt::domain::__t vector__cpp__stmt::domain::__t::next () const
{
    vector__cpp__stmt::domain::__t y;
    y = (*this) + vector__cpp__stmt::domain::__t (1);
    return y;
}
vector__cpp__stmt::domain::__t vector__cpp__stmt::domain::__t::prev () const
{
    vector__cpp__stmt::domain::__t y;
    y = (*this) - vector__cpp__stmt::domain::__t (1);
    return y;
}
vector__cpp__stmt::domain::__t vector__cpp__stmt::__t::begin () const
{
    vector__cpp__stmt::domain::__t res;
    res = vector__cpp__stmt::domain::__t (0);
    return res;
}
vector__cpp__stmt::__t vector__cpp__stmt::empty () {
    vector__cpp__stmt::__t res;
    {}
    return res;
}
void vector__cpp__stmt::__t::set  (const vector__cpp__stmt::domain::__t &i,const ivy::ptr< cpp::stmt::__t >
    &v) {
    (*this) . value (i) = v;
}
void vector__cpp__stmt::__t::append  (const ivy::ptr< cpp::stmt::__t > &c)
{
    (*this) . value ((*this) . end) = c;
    (*this) . end = (*this) . end . next();
}
void vector__cpp__stmt::__t::extend  (const vector__cpp__stmt::__t &x)
{
    vector__cpp__stmt::domain::__t idx;
    idx = x . begin();
    while (idx < x . end) {
        (*this) . append (x . value (idx));
        idx = idx . next();
    }
}
void vector__cpp__stmt::__t::resize  (const vector__cpp__stmt::domain::__t &end)
{
    ivy::resize ((*this) . value,end);
    (*this) . end = end;
}
ivy::ptr< cpp::stmt::__t > vector__cpp__stmt::__t::back () const
{
    ivy::ptr< cpp::stmt::__t > y;
    if ((*this) . end > vector__cpp__stmt::domain::__t (0))
    {
        y = (*this) . value ((*this) . end . prev());
    }
    return y;
}
void vector__cpp__stmt::__t::pop_back ()
{
    if ((*this) . end > vector__cpp__stmt::domain::__t (0))
    {
        vector__cpp__stmt::domain::__t size;
        size = (*this) . end . prev();
        (*this) . resize (size);
    }
}
vector__cpp__stmt::__t vector__cpp__stmt::__t::segment  (const vector__cpp__stmt::domain::__t &beg,const
    vector__cpp__stmt::domain::__t &en) const
{
    vector__cpp__stmt::__t res;
    {
        vector__cpp__stmt::domain::__t idx;
        idx = beg;
        while (idx < en & idx < (*this) . end)
        {
            res . append ((*this) . value (idx));
            idx = idx . next();
        }
    }
    return res;
}
void vector__cpp__stmt::__t::reverse ()
{
    vector__cpp__stmt::domain::__t idx;
    idx = (*this) . begin();
    vector__cpp__stmt::domain::__t jdx;
    jdx = (*this) . end . prev();
    while (idx < jdx)
    {
        ivy::ptr< cpp::stmt::__t > tmp;
        tmp = (*this) . value (idx);
        (*this) . value (idx) = (*this) . value (jdx);
        (*this) . value (jdx) = tmp;
        jdx = jdx . prev();
        idx = idx . next();
    }
}
ivy::ptr< cpp::stmt::__t > cpp::sequence::fold_right  (const vector__cpp__stmt::__t &args,const ivy::ptr< annot::__t >
    &ann)
{
    ivy::ptr< cpp::stmt::__t > res;
    if (args . end > vector__cpp__stmt::domain::__t (0))
    {
        vector__cpp__stmt::domain::__t idx;
        idx = args . end . prev();
        res = args . value (idx);
        while (idx > vector__cpp__stmt::domain::__t (0))
        {
            idx = idx . prev();
            res = cpp::sequence::make (args . value (idx),res,ann);
        }
    }
    return res;
}
ivy::ptr< annot::__t > cpp::sequence::__t::get_ann () const
{
    ivy::ptr< annot::__t > res;
    res = (*this) . ann;
    return res;
}
ivy::ptr< cpp::stmt::__t > cpp::skipst::make  (const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< cpp::stmt::__t > res;
    {
        cpp::skipst::__t s;
        s . ann = ann;
        res = s;
    }
    return res;
}
void cpp::skipst::__t::encode  (pretty::__t &b,const priority::__t &prio) const
{
    (*this) . ann -> encode (b);
    b . extend (ivy::from_str< str::__t > ("{"));
    b . extend (ivy::from_str< str::__t > ("}"));
}
ivy::ptr< annot::__t > cpp::skipst::__t::get_ann () const
{
    ivy::ptr< annot::__t > res;
    res = (*this) . ann;
    return res;
}
void cpp::ifst::__t::encode  (pretty::__t &b,const priority::__t &prio) const
{
    (*this) . ann -> encode (b);
    if (priority::__t (1) < prio)
    {
        b . nest();
        b . extend (ivy::from_str< str::__t > ("{"));
        b . newline();
    }
    (*this) . encode_int (b,prio);
    if (priority::__t (1) < prio)
    {
        b . unnest();
        b . newline();
        b . extend (ivy::from_str< str::__t > ("}"));
    }
}
ivy::ptr< cpp::stmt::__t > cpp::ifst::make  (const ivy::ptr< cpp::expr::__t > &cond,const ivy::ptr< cpp::stmt::__t >
    &thenst,const ivy::ptr< cpp::stmt::__t > &elsest,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< cpp::stmt::__t > res;
    {
        cpp::ifst::__t s;
        s . cond = cond;
        s . thenst = elsest;
        s . elsest = elsest;
        s . ann = ann;
        res = s;
    }
    return res;
}
void cpp::ifst::__t::encode_int  (pretty::__t &b,const priority::__t &prio) const
{
    b . extend (ivy::from_str< str::__t > ("if"));
    b . extend (ivy::from_str< str::__t > (" "));
    if (ivy::native_bool (true)) {
        b . extend (ivy::from_str< str::__t > ("("));
    }
    (*this) . cond -> encode (b,priority::__t (0));
    if (ivy::native_bool (true)) {
        b . extend (ivy::from_str< str::__t > (")"));
    }
    b . extend (ivy::from_str< str::__t > (" "));
    (*this) . thenst -> encode (b,priority::__t (2));
    if (! (*this) . elsest . isa< cpp::skipst::__t >())
    {
        b . extend (ivy::from_str< str::__t > (" "));
        b . extend (ivy::from_str< str::__t > ("else"));
        b . extend (ivy::from_str< str::__t > (" "));
        (*this) . elsest -> encode (b,priority::__t (2));
    }
    {}
}
ivy::ptr< annot::__t > cpp::ifst::__t::get_ann () const
{
    ivy::ptr< annot::__t > res;
    res = (*this) . ann;
    return res;
}
void cpp::whilest::__t::encode  (pretty::__t &b,const priority::__t &prio) const
{
    (*this) . ann -> encode (b);
    if (priority::__t (1) < prio)
    {
        b . nest();
        b . extend (ivy::from_str< str::__t > ("{"));
        b . newline();
    }
    (*this) . encode_int (b,prio);
    if (priority::__t (1) < prio)
    {
        b . unnest();
        b . newline();
        b . extend (ivy::from_str< str::__t > ("}"));
    }
}
ivy::ptr< cpp::stmt::__t > cpp::whilest::make  (const ivy::ptr< cpp::expr::__t > &cond,const ivy::ptr< cpp::stmt::__t >
    &body,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< cpp::stmt::__t > res;
    {
        cpp::whilest::__t s;
        s . cond = cond;
        s . body = body;
        s . ann = ann;
        res = s;
    }
    return res;
}
void cpp::whilest::__t::encode_int  (pretty::__t &b,const priority::__t &prio) const
{
    b . extend (ivy::from_str< str::__t > ("while"));
    b . extend (ivy::from_str< str::__t > (" "));
    if (ivy::native_bool (true)) {
        b . extend (ivy::from_str< str::__t > ("("));
    }
    (*this) . cond -> encode (b,priority::__t (0));
    if (ivy::native_bool (true)) {
        b . extend (ivy::from_str< str::__t > (")"));
    }
    b . extend (ivy::from_str< str::__t > (" "));
    (*this) . body -> encode (b,priority::__t (2));
}
ivy::ptr< annot::__t > cpp::whilest::__t::get_ann () const
{
    ivy::ptr< annot::__t > res;
    res = (*this) . ann;
    return res;
}
void cpp::breakst::__t::encode  (pretty::__t &b,const priority::__t &prio) const
{
    (*this) . ann -> encode (b);
    if (priority::__t (1) < prio)
    {
        b . nest();
        b . extend (ivy::from_str< str::__t > ("{"));
        b . newline();
    }
    (*this) . encode_int (b,prio);
    if (priority::__t (1) < prio)
    {
        b . unnest();
        b . newline();
        b . extend (ivy::from_str< str::__t > ("}"));
    }
}
ivy::ptr< cpp::stmt::__t > cpp::breakst::make  (const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< cpp::stmt::__t > res;
    {
        cpp::breakst::__t s;
        s . ann = ann;
        res = s;
    }
    return res;
}
void cpp::breakst::__t::encode_int  (pretty::__t &b,const priority::__t &prio) const
{
    b . extend (ivy::from_str< str::__t > ("break;"));
}
ivy::ptr< annot::__t > cpp::breakst::__t::get_ann () const
{
    ivy::ptr< annot::__t > res;
    res = (*this) . ann;
    return res;
}
void cpp::stmt::parse  (pstate::__t &st,const priority::__t &prio,ivy::ptr< cpp::stmt::__t > &res)
{
    while (st . tok == ivy::from_str< str::__t > (";")) {
        st . consume();
    }
    if (st . tok == ivy::from_str< str::__t > ("{"))
    {
        st . consume();
        cpp::stmt::parse (st,priority::__t (0),res);
        if (st . ok & st . tok == ivy::from_str< str::__t > ("}")) {
            st . consume();
        } else {
            st . ok = ivy::native_bool (false);
        }
    } else
    {
        if (st . tok == ivy::from_str< str::__t > ("if"))
        {
            st . consume();
            cpp::ifst::__t s;
            st . get_ann (s . ann);
            cpp::expr::parse (st,priority::__t (0),s . cond);
            if (st . ok & st . tok == ivy::from_str< str::__t > ("{"))
            {
                cpp::stmt::parse (st,priority::__t (1),s . thenst);
                if (st . ok & st . tok == ivy::from_str< str::__t > ("else"))
                {
                    st . consume();
                    if (st . ok &
                    (st . tok == ivy::from_str< str::__t > ("{") | st . tok ==
                        ivy::from_str< str::__t > ("if")))
                    {
                        cpp::stmt::parse (st,priority::__t (1),s . elsest);
                    } else {
                        st . ok = ivy::native_bool (false);
                    }
                } else {
                    ivy::ptr< annot::__t > ann;
                    s . elsest = cpp::skipst::make (ann);
                }
            } else {
                st . ok = ivy::native_bool (false);
            }
            res = s;
        } else
        {
            if (st . tok == ivy::from_str< str::__t > ("while"))
            {
                st . consume();
                cpp::whilest::__t s;
                st . get_ann (s . ann);
                cpp::expr::parse (st,priority::__t (0),s . cond);
                if (st . ok & st . tok == ivy::from_str< str::__t > ("{"))
                {
                    cpp::stmt::parse (st,priority::__t (1),s . body);
                } else {
                    st . ok = ivy::native_bool (false);
                }
                res = s;
            } else
            {
                if (st . tok == ivy::from_str< str::__t > ("}"))
                {
                    ivy::ptr< annot::__t > ann;
                    st . get_ann (ann);
                    res = cpp::skipst::make (ann);
                } else {
                    cpp::stmt::parse_lang_stmt (st,prio,res);
                }
            }
        }
    }
    if (st . ok & prio == priority::__t (0) & st . tok . end > pos::__t (0) & st . tok !=
    ivy::from_str< str::__t > ("}"))
    {
        cpp::sequence::__t sq;
        sq . lhs = res;
        cpp::stmt::parse (st,priority::__t (0),sq . rhs);
        res = sq;
    }
}
ivy::ptr< cpp::expr::__t > cpp::__new::make  (const ivy::ptr< cpp::expr::__t > &arg,const ivy::ptr< annot::__t >
    &ann)
{
    ivy::ptr< cpp::expr::__t > res;
    {
        cpp::app::__t s;
        s . func = cpp::symbol::makestr (ivy::from_str< str::__t > ("new"),ann);
        s . args . append (arg);
        s . ann = ann;
        res = s;
    }
    return res;
}
ivy::ptr< cpp::expr::__t > cpp::arrow::make  (const ivy::ptr< cpp::expr::__t > &lhs,const ivy::ptr< cpp::expr::__t >
    &rhs,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< cpp::expr::__t > res;
    {
        cpp::app::__t s;
        s . func = cpp::symbol::makestr (ivy::from_str< str::__t > ("->"),ann);
        s . args . append (lhs);
        s . args . append (rhs);
        s . ann = ann;
        res = s;
    }
    return res;
}
ivy::ptr< cpp::expr::__t > cpp::arrow::fold_left  (const vector__cpp__expr::__t &args,const ivy::ptr< annot::__t >
    &ann)
{
    ivy::ptr< cpp::expr::__t > res;
    if (args . end > vector__cpp__expr::domain::__t (0))
    {
        res = args . value (vector__cpp__expr::domain::__t (0));
        vector__cpp__expr::domain::__t idx;
        idx = args . begin() . next();
        while (idx < args . end)
        {
            res = cpp::arrow::make (res,args . value (idx),ann);
            idx = idx . next();
        }
    } else {
        res = cpp::empty::make (ann);
    }
    return res;
}
vector__cpp__expr::__t cpp::arrow::unfold_left  (const ivy::ptr< cpp::expr::__t > &s)
{
    vector__cpp__expr::__t args;
    {
        ivy::ptr< cpp::expr::__t > e;
        e = s;
        __bool b;
        b = e -> is_typed (cpp::verb::__t (cpp::verb::arrow));
        while (b)
        {
            args . append (e -> get_arg (vector__cpp__expr::domain::__t (1)));
            e = e -> get_arg (vector__cpp__expr::domain::__t (0));
            b = e -> is_typed (cpp::verb::__t (cpp::verb::arrow));
        }
        args . append (e);
        args . reverse();
    }
    return args;
}
ivy::ptr< cpp::expr::__t > cpp::equals::make  (const ivy::ptr< cpp::expr::__t > &lhs,const ivy::ptr< cpp::expr::__t >
    &rhs,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< cpp::expr::__t > res;
    {
        cpp::app::__t s;
        s . func = cpp::symbol::makestr (ivy::from_str< str::__t > ("=="),ann);
        s . args . append (lhs);
        s . args . append (rhs);
        s . ann = ann;
        res = s;
    }
    return res;
}
ivy::ptr< cpp::expr::__t > cpp::equals::fold_left  (const vector__cpp__expr::__t &args,const ivy::ptr< annot::__t >
    &ann)
{
    ivy::ptr< cpp::expr::__t > res;
    if (args . end > vector__cpp__expr::domain::__t (0))
    {
        res = args . value (vector__cpp__expr::domain::__t (0));
        vector__cpp__expr::domain::__t idx;
        idx = args . begin() . next();
        while (idx < args . end)
        {
            res = cpp::equals::make (res,args . value (idx),ann);
            idx = idx . next();
        }
    } else {
        res = cpp::empty::make (ann);
    }
    return res;
}
vector__cpp__expr::__t cpp::equals::unfold_left  (const ivy::ptr< cpp::expr::__t > &s)
{
    vector__cpp__expr::__t args;
    {
        ivy::ptr< cpp::expr::__t > e;
        e = s;
        __bool b;
        b = e -> is_typed (cpp::verb::__t (cpp::verb::equals));
        while (b)
        {
            args . append (e -> get_arg (vector__cpp__expr::domain::__t (1)));
            e = e -> get_arg (vector__cpp__expr::domain::__t (0));
            b = e -> is_typed (cpp::verb::__t (cpp::verb::equals));
        }
        args . append (e);
        args . reverse();
    }
    return args;
}
ivy::ptr< cpp::expr::__t > cpp::notequals::make  (const ivy::ptr< cpp::expr::__t > &lhs,const ivy::ptr< cpp::expr::__t >
    &rhs,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< cpp::expr::__t > res;
    {
        cpp::app::__t s;
        s . func = cpp::symbol::makestr (ivy::from_str< str::__t > ("!="),ann);
        s . args . append (lhs);
        s . args . append (rhs);
        s . ann = ann;
        res = s;
    }
    return res;
}
ivy::ptr< cpp::expr::__t > cpp::notequals::fold_left  (const vector__cpp__expr::__t &args,const ivy::ptr< annot::__t >
    &ann)
{
    ivy::ptr< cpp::expr::__t > res;
    if (args . end > vector__cpp__expr::domain::__t (0))
    {
        res = args . value (vector__cpp__expr::domain::__t (0));
        vector__cpp__expr::domain::__t idx;
        idx = args . begin() . next();
        while (idx < args . end)
        {
            res = cpp::notequals::make (res,args . value (idx),ann);
            idx = idx . next();
        }
    } else {
        res = cpp::empty::make (ann);
    }
    return res;
}
vector__cpp__expr::__t cpp::notequals::unfold_left  (const ivy::ptr< cpp::expr::__t > &s)
{
    vector__cpp__expr::__t args;
    {
        ivy::ptr< cpp::expr::__t > e;
        e = s;
        __bool b;
        b = e -> is_typed (cpp::verb::__t (cpp::verb::notequals));
        while (b)
        {
            args . append (e -> get_arg (vector__cpp__expr::domain::__t (1)));
            e = e -> get_arg (vector__cpp__expr::domain::__t (0));
            b = e -> is_typed (cpp::verb::__t (cpp::verb::notequals));
        }
        args . append (e);
        args . reverse();
    }
    return args;
}
ivy::ptr< cpp::expr::__t > cpp::__not::make  (const ivy::ptr< cpp::expr::__t > &arg,const ivy::ptr< annot::__t >
    &ann)
{
    ivy::ptr< cpp::expr::__t > res;
    {
        cpp::app::__t s;
        s . func = cpp::symbol::makestr (ivy::from_str< str::__t > ("!"),ann);
        s . args . append (arg);
        s . ann = ann;
        res = s;
    }
    return res;
}
ivy::ptr< cpp::expr::__t > cpp::ite::make  (const ivy::ptr< cpp::expr::__t > &arg0,const ivy::ptr< cpp::expr::__t >
    &arg1,const ivy::ptr< cpp::expr::__t > &arg2,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< cpp::expr::__t > res;
    {
        cpp::app::__t s;
        s . func = cpp::symbol::makestr (ivy::from_str< str::__t > ("?"),ann);
        s . args . append (arg0);
        s . args . append (arg1);
        s . args . append (arg2);
        s . ann = ann;
        res = s;
    }
    return res;
}
ivy::ptr< cpp::expr::__t > cpp::app::make0  (const ivy::ptr< cpp::expr::__t > &func,const ivy::ptr< annot::__t >
    &ann)
{
    ivy::ptr< cpp::expr::__t > res;
    {
        cpp::app::__t s;
        s . func = func;
        s . ann = ann;
        res = s;
    }
    return res;
}
void cpp::simpletype::tup::encode  (const vector__cpp__simpletype::__t &s,pretty::__t &b,const
    priority::__t &prio)
{
    if (s . end > vector__cpp__simpletype::domain::__t (0))
    {
        b . extend (ivy::from_str< str::__t > (" "));
        b . extend (ivy::from_str< str::__t > ("("));
        s . value (vector__cpp__simpletype::domain::__t (0)) . encode (b,priority::__t (0));
        vector__cpp__simpletype::domain::__t idx;
        idx = s . begin() . next();
        while (idx < s . end)
        {
            b . extend (ivy::from_str< str::__t > (","));
            s . value (idx) . encode (b,priority::__t (0));
            idx = idx . next();
        }
        b . extend (ivy::from_str< str::__t > (")"));
    }
}
void cpp::simpletype::tup::parse  (pstate::__t &st,const priority::__t &prio,vector__cpp__simpletype::__t
    &res)
{
    if (st . tok == ivy::from_str< str::__t > ("("))
    {
        st . consume();
        cpp::simpletype::__t s;
        cpp::simpletype::parse (st,prio,s);
        res . append (s);
        while (st . ok & st . tok == ivy::from_str< str::__t > (","))
        {
            st . consume();
            cpp::simpletype::parse (st,prio,s);
            res . append (s);
        }
        if (st . ok & st . tok == ivy::from_str< str::__t > (")")) {
            st . consume();
        } else {
            st . ok = ivy::native_bool (false);
        }
    } else {
        st . ok = ivy::native_bool (false);
    }
}
void cpp::simpletype::__t::encode  (pretty::__t &b,const priority::__t &prio) const
{
    if ((*this) . is_const)
    {
        b . extend (ivy::from_str< str::__t > ("const"));
        b . extend (ivy::from_str< str::__t > (" "));
    }
    (*this) . _type -> encode (b,priority::__t (0));
    b . extend (ivy::from_str< str::__t > (" "));
    if ((*this) . is_ref) {
        b . extend (ivy::from_str< str::__t > ("&"));
    }
    if ((*this) . is_rvalue) {
        b . extend (ivy::from_str< str::__t > ("&"));
    }
    (*this) . name -> encode (b,priority::__t (99));
}
void cpp::simpletype::parse  (pstate::__t &st,const priority::__t &prio,cpp::simpletype::__t &res)
{
    cpp::symbol::parse (st,res . _type);
    if (st . ok) {
        cpp::symbol::parse (st,res . name);
    }
}
vector__cpp__simpletype::domain::__t vector__cpp__simpletype::domain::__t::next () const
{
    vector__cpp__simpletype::domain::__t y;
    y = (*this) + vector__cpp__simpletype::domain::__t (1);
    return y;
}
vector__cpp__simpletype::domain::__t vector__cpp__simpletype::domain::__t::prev () const
{
    vector__cpp__simpletype::domain::__t y;
    y = (*this) - vector__cpp__simpletype::domain::__t (1);
    return y;
}
vector__cpp__simpletype::domain::__t vector__cpp__simpletype::__t::begin () const
{
    vector__cpp__simpletype::domain::__t res;
    res = vector__cpp__simpletype::domain::__t (0);
    return res;
}
vector__cpp__simpletype::__t vector__cpp__simpletype::empty ()
{
    vector__cpp__simpletype::__t res;
    {}
    return res;
}
void vector__cpp__simpletype::__t::set  (const vector__cpp__simpletype::domain::__t &i,const cpp::simpletype::__t
    &v) {
    (*this) . value (i) = v;
}
void vector__cpp__simpletype::__t::append  (const cpp::simpletype::__t &c)
{
    (*this) . value ((*this) . end) = c;
    (*this) . end = (*this) . end . next();
}
void vector__cpp__simpletype::__t::extend  (const vector__cpp__simpletype::__t &x)
{
    vector__cpp__simpletype::domain::__t idx;
    idx = x . begin();
    while (idx < x . end) {
        (*this) . append (x . value (idx));
        idx = idx . next();
    }
}
void vector__cpp__simpletype::__t::resize  (const vector__cpp__simpletype::domain::__t &end)
{
    ivy::resize ((*this) . value,end);
    (*this) . end = end;
}
cpp::simpletype::__t vector__cpp__simpletype::__t::back () const
{
    cpp::simpletype::__t y;
    if ((*this) . end > vector__cpp__simpletype::domain::__t (0))
    {
        y = (*this) . value ((*this) . end . prev());
    }
    return y;
}
void vector__cpp__simpletype::__t::pop_back ()
{
    if ((*this) . end > vector__cpp__simpletype::domain::__t (0))
    {
        vector__cpp__simpletype::domain::__t size;
        size = (*this) . end . prev();
        (*this) . resize (size);
    }
}
vector__cpp__simpletype::__t vector__cpp__simpletype::__t::segment  (const vector__cpp__simpletype::domain::__t
    &beg,const vector__cpp__simpletype::domain::__t &en) const
{
    vector__cpp__simpletype::__t res;
    {
        vector__cpp__simpletype::domain::__t idx;
        idx = beg;
        while (idx < en & idx < (*this) . end)
        {
            res . append ((*this) . value (idx));
            idx = idx . next();
        }
    }
    return res;
}
void vector__cpp__simpletype::__t::reverse ()
{
    vector__cpp__simpletype::domain::__t idx;
    idx = (*this) . begin();
    vector__cpp__simpletype::domain::__t jdx;
    jdx = (*this) . end . prev();
    while (idx < jdx)
    {
        cpp::simpletype::__t tmp;
        tmp = (*this) . value (idx);
        (*this) . value (idx) = (*this) . value (jdx);
        (*this) . value (jdx) = tmp;
        jdx = jdx . prev();
        idx = idx . next();
    }
}
void cpp::functype::__t::encode  (pretty::__t &b,const priority::__t &prio) const
{
    (*this) . base . encode (b,priority::__t (0));
    b . extend (ivy::from_str< str::__t > (" "));
    if ((*this) . args . end > vector__cpp__simpletype::domain::__t (0))
    {
        cpp::simpletype::tup::encode ((*this) . args,b,priority::__t (0));
    } else {
        b . extend (ivy::from_str< str::__t > ("()"));
    }
    if ((*this) . is_const)
    {
        b . extend (ivy::from_str< str::__t > (" "));
        b . extend (ivy::from_str< str::__t > ("const"));
    }
    if ((*this) . has_initializer)
    {
        b . extend (ivy::from_str< str::__t > (" "));
        b . extend (ivy::from_str< str::__t > (":"));
        b . extend (ivy::from_str< str::__t > (" "));
        (*this) . initializer -> encode (b,priority::__t (0));
    }
}
void cpp::functype::parse  (pstate::__t &st,const cpp::simpletype::__t &base,const priority::__t &prio,cpp::functype::__t
    &res)
{
    res . base = base;
    if (st . ok) {
        cpp::simpletype::tup::parse (st,priority::__t (1),res . args);
    }
    if (st . ok & st . tok == ivy::from_str< str::__t > ("const"))
    {
        res . is_const = ivy::native_bool (true);
        st . consume();
    }
    if (st . ok & st . tok == ivy::from_str< str::__t > (":"))
    {
        res . has_initializer = ivy::native_bool (true);
        cpp::expr::parse (st,priority::__t (0),res . initializer);
    }
}
void cpp::varst::__t::encode  (pretty::__t &b,const priority::__t &prio) const
{
    (*this) . ann -> encode (b);
    if (priority::__t (1) < prio)
    {
        b . nest();
        b . extend (ivy::from_str< str::__t > ("{"));
        b . newline();
    }
    (*this) . encode_int (b,prio);
    if (priority::__t (1) < prio)
    {
        b . unnest();
        b . newline();
        b . extend (ivy::from_str< str::__t > ("}"));
    }
}
ivy::ptr< cpp::stmt::__t > cpp::varst::make  (const ivy::ptr< cpp::expr::__t > &_type,const ivy::ptr< cpp::expr::__t >
    &name,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< cpp::stmt::__t > res;
    {
        cpp::varst::__t s;
        s . vtype . _type = _type;
        s . vtype . name = name;
        s . ann = ann;
        res = s;
    }
    return res;
}
void cpp::varst::__t::encode_int  (pretty::__t &b,const priority::__t &prio) const
{
    b . nest();
    (*this) . vtype . encode (b,prio);
    if ((*this) . has_initval)
    {
        b . extend (ivy::from_str< str::__t > (" "));
        b . extend (ivy::from_str< str::__t > ("="));
        b . extend (ivy::from_str< str::__t > (" "));
        (*this) . initval -> encode (b,priority::__t (0));
    }
    b . extend (ivy::from_str< str::__t > (";"));
    b . unnest();
}
void cpp::retst::__t::encode  (pretty::__t &b,const priority::__t &prio) const
{
    (*this) . ann -> encode (b);
    if (priority::__t (1) < prio)
    {
        b . nest();
        b . extend (ivy::from_str< str::__t > ("{"));
        b . newline();
    }
    (*this) . encode_int (b,prio);
    if (priority::__t (1) < prio)
    {
        b . unnest();
        b . newline();
        b . extend (ivy::from_str< str::__t > ("}"));
    }
}
ivy::ptr< cpp::stmt::__t > cpp::retst::make  (const ivy::ptr< cpp::expr::__t > &val,const ivy::ptr< annot::__t >
    &ann)
{
    ivy::ptr< cpp::stmt::__t > res;
    {
        cpp::retst::__t s;
        s . val = val;
        s . ann = ann;
        res = s;
    }
    return res;
}
void cpp::retst::__t::encode_int  (pretty::__t &b,const priority::__t &prio) const
{
    b . nest();
    b . extend (ivy::from_str< str::__t > ("return"));
    b . extend (ivy::from_str< str::__t > (" "));
    (*this) . val -> encode (b,prio);
    b . extend (ivy::from_str< str::__t > (";"));
    b . unnest();
}
void cpp::stmt::parse_lang_stmt  (pstate::__t &st,const priority::__t &prio,ivy::ptr< cpp::stmt::__t >
    &res)
{
    ivy::ptr< cpp::expr::__t > lhs;
    ivy::ptr< annot::__t > ann;
    st . get_ann (ann);
    cpp::expr::parse (st,priority::__t (3),lhs);
    if (st . ok & st . tok == ivy::from_str< str::__t > ("="))
    {
        st . consume();
        cpp::asgn::__t s;
        s . lhs = lhs;
        s . ann = ann;
        cpp::expr::parse (st,priority::__t (0),s . rhs);
        res = s;
    } else
    {
        
        // if not assignment, could be variable declaration
        
        ivy::ptr< cpp::expr::__t > name;
        cpp::symbol::parse (st,name);
        if (st . ok)
        {
            cpp::varst::__t s;
            s . ann = ann;
            s . vtype . _type = lhs;
            s . vtype . name = name;
            res = s;
        }
    }
    if (st . ok & st . tok == ivy::from_str< str::__t > (";")) {
        st . consume();
    } else {
        st . ok = ivy::native_bool (false);
    }
}
void cpp::decl::__t::encode  (pretty::__t &b,const priority::__t &prio) const {}
str::__t cpp::decl::__t::enc () const
{
    str::__t s;
    {
        pretty::__t p;
        p = pretty::make (pos::__t (100),pos::__t (4));
        p . cppstyle = ivy::native_bool (true);
        (*this) . encode (p,priority::__t (0));
        p . flush();
        s = p . output;
    }
    return s;
}
ivy::ptr< cpp::decl::__t > cpp::decl::dec  (const str::__t &s)
{
    ivy::ptr< cpp::decl::__t > e;
    {
        pstate::__t st;
        st = pstate::make (s);
        cpp::decl::parse (st,priority::__t (0),e);
        if (! st . ok | st . tok . end != pos::__t (0)) {
            parse_error (st . ann . line,st . tok);
        }
    }
    return e;
}
str::__t cpp::decl::encdec  (const str::__t &s)
{
    str::__t res;
    {
        ivy::ptr< cpp::decl::__t > e;
        e = cpp::decl::dec (s);
        res = e -> enc();
    }
    return res;
}
ivy::ptr< annot::__t > cpp::decl::__t::get_ann () const {
    ivy::ptr< annot::__t > res;
    {}
    return res;
}
ivy::ptr< cpp::expr::__t > cpp::decl::__t::get_name () const
{
    ivy::ptr< cpp::expr::__t > res;
    {}
    return res;
}
ivy::ptr< cpp::expr::__t > cpp::decl::__t::get_type () const
{
    ivy::ptr< cpp::expr::__t > res;
    {}
    return res;
}
ivy::ptr< cpp::decl::__t > cpp::header::make  (const str::__t &filename)
{
    ivy::ptr< cpp::decl::__t > res;
    {
        cpp::header::__t s;
        s . filename = filename;
        res = s;
    }
    return res;
}
void cpp::header::__t::encode  (pretty::__t &b,const priority::__t &prio) const
{
    b . nest();
    b . extend (ivy::from_str< str::__t > ("#include "));
    b . extend ((*this) . filename);
    b . unnest();
    b . newline();
}
ivy::ptr< annot::__t > cpp::header::__t::get_ann () const
{
    ivy::ptr< annot::__t > res;
    res = (*this) . ann;
    return res;
}
void cpp::typedecl::__t::encode  (pretty::__t &b,const priority::__t &prio) const
{
    (*this) . ann -> encode (b);
    b . nest();
    b . extend (ivy::from_str< str::__t > ("typedef"));
    b . extend (ivy::from_str< str::__t > (" "));
    (*this) . ttype . encode (b,priority::__t (0));
    b . extend (ivy::from_str< str::__t > (";"));
    b . unnest();
    b . newline();
}
ivy::ptr< annot::__t > cpp::typedecl::__t::get_ann () const
{
    ivy::ptr< annot::__t > res;
    res = (*this) . ann;
    return res;
}
void cpp::curly_tup::encode  (const vector__cpp__expr::__t &s,pretty::__t &b,const priority::__t &prio)
{
    if (s . end > vector__cpp__expr::domain::__t (0))
    {
        b . extend (ivy::from_str< str::__t > (" "));
        b . extend (ivy::from_str< str::__t > ("{"));
        s . value (vector__cpp__expr::domain::__t (0)) -> encode (b,priority::__t (0));
        vector__cpp__expr::domain::__t idx;
        idx = s . begin() . next();
        while (idx < s . end)
        {
            b . extend (ivy::from_str< str::__t > (","));
            s . value (idx) -> encode (b,priority::__t (0));
            idx = idx . next();
        }
        b . extend (ivy::from_str< str::__t > ("}"));
    }
}
void cpp::curly_tup::parse  (pstate::__t &st,const priority::__t &prio,vector__cpp__expr::__t &res)
{
    if (st . tok == ivy::from_str< str::__t > ("{"))
    {
        st . consume();
        ivy::ptr< cpp::expr::__t > s;
        cpp::expr::parse (st,prio,s);
        res . append (s);
        while (st . ok & st . tok == ivy::from_str< str::__t > (","))
        {
            st . consume();
            cpp::expr::parse (st,prio,s);
            res . append (s);
        }
        if (st . ok & st . tok == ivy::from_str< str::__t > ("}")) {
            st . consume();
        } else {
            st . ok = ivy::native_bool (false);
        }
    } else {
        st . ok = ivy::native_bool (false);
    }
}
void cpp::enumdecl::__t::encode  (pretty::__t &b,const priority::__t &prio) const
{
    (*this) . ann -> encode (b);
    b . nest();
    b . extend (ivy::from_str< str::__t > ("enum"));
    b . extend (ivy::from_str< str::__t > (" "));
    (*this) . name -> encode (b,priority::__t (0));
    b . extend (ivy::from_str< str::__t > (" "));
    cpp::curly_tup::encode ((*this) . elems,b,priority::__t (0));
    b . extend (ivy::from_str< str::__t > (";"));
    b . unnest();
    b . newline();
}
ivy::ptr< annot::__t > cpp::enumdecl::__t::get_ann () const
{
    ivy::ptr< annot::__t > res;
    res = (*this) . ann;
    return res;
}
void cpp::vardecl::__t::encode  (pretty::__t &b,const priority::__t &prio) const
{
    (*this) . ann -> encode (b);
    b . nest();
    (*this) . vtype . encode (b,priority::__t (0));
    if ((*this) . has_initval)
    {
        b . extend (ivy::from_str< str::__t > (" "));
        b . extend (ivy::from_str< str::__t > ("="));
        b . extend (ivy::from_str< str::__t > (" "));
        (*this) . initval -> encode (b,priority::__t (0));
    }
    b . extend (ivy::from_str< str::__t > (";"));
    b . unnest();
    b . newline();
}
ivy::ptr< annot::__t > cpp::vardecl::__t::get_ann () const
{
    ivy::ptr< annot::__t > res;
    res = (*this) . ann;
    return res;
}
ivy::ptr< cpp::expr::__t > cpp::vardecl::__t::get_name () const
{
    ivy::ptr< cpp::expr::__t > res;
    res = (*this) . vtype . name;
    return res;
}
ivy::ptr< cpp::expr::__t > cpp::vardecl::__t::get_type () const
{
    ivy::ptr< cpp::expr::__t > res;
    res = (*this) . vtype . _type;
    return res;
}
void cpp::funcdecl::__t::encode  (pretty::__t &b,const priority::__t &prio) const
{
    (*this) . ann -> encode (b);
    b . nest();
    if ((*this) . is_static)
    {
        b . extend (ivy::from_str< str::__t > ("static"));
        b . extend (ivy::from_str< str::__t > (" "));
    }
    if ((*this) . is_virtual)
    {
        b . extend (ivy::from_str< str::__t > ("virtual"));
        b . extend (ivy::from_str< str::__t > (" "));
    }
    (*this) . ftype . encode (b,priority::__t (0));
    if ((*this) . has_body)
    {
        b . unnest();
        b . extend (ivy::from_str< str::__t > (" "));
        (*this) . body -> encode (b,priority::__t (2));
    } else
    {
        if ((*this) . is_default)
        {
            b . extend (ivy::from_str< str::__t > (" "));
            b . extend (ivy::from_str< str::__t > ("="));
            b . extend (ivy::from_str< str::__t > (" "));
            b . extend (ivy::from_str< str::__t > ("default"));
        }
        b . extend (ivy::from_str< str::__t > (";"));
        b . unnest();
        b . newline();
    }
}
ivy::ptr< annot::__t > cpp::funcdecl::__t::get_ann () const
{
    ivy::ptr< annot::__t > res;
    res = (*this) . ann;
    return res;
}
vector__cpp__decl::domain::__t vector__cpp__decl::domain::__t::next () const
{
    vector__cpp__decl::domain::__t y;
    y = (*this) + vector__cpp__decl::domain::__t (1);
    return y;
}
vector__cpp__decl::domain::__t vector__cpp__decl::domain::__t::prev () const
{
    vector__cpp__decl::domain::__t y;
    y = (*this) - vector__cpp__decl::domain::__t (1);
    return y;
}
vector__cpp__decl::domain::__t vector__cpp__decl::__t::begin () const
{
    vector__cpp__decl::domain::__t res;
    res = vector__cpp__decl::domain::__t (0);
    return res;
}
vector__cpp__decl::__t vector__cpp__decl::empty () {
    vector__cpp__decl::__t res;
    {}
    return res;
}
void vector__cpp__decl::__t::set  (const vector__cpp__decl::domain::__t &i,const ivy::ptr< cpp::decl::__t >
    &v) {
    (*this) . value (i) = v;
}
void vector__cpp__decl::__t::append  (const ivy::ptr< cpp::decl::__t > &c)
{
    (*this) . value ((*this) . end) = c;
    (*this) . end = (*this) . end . next();
}
void vector__cpp__decl::__t::extend  (const vector__cpp__decl::__t &x)
{
    vector__cpp__decl::domain::__t idx;
    idx = x . begin();
    while (idx < x . end) {
        (*this) . append (x . value (idx));
        idx = idx . next();
    }
}
void vector__cpp__decl::__t::resize  (const vector__cpp__decl::domain::__t &end)
{
    ivy::resize ((*this) . value,end);
    (*this) . end = end;
}
ivy::ptr< cpp::decl::__t > vector__cpp__decl::__t::back () const
{
    ivy::ptr< cpp::decl::__t > y;
    if ((*this) . end > vector__cpp__decl::domain::__t (0))
    {
        y = (*this) . value ((*this) . end . prev());
    }
    return y;
}
void vector__cpp__decl::__t::pop_back ()
{
    if ((*this) . end > vector__cpp__decl::domain::__t (0))
    {
        vector__cpp__decl::domain::__t size;
        size = (*this) . end . prev();
        (*this) . resize (size);
    }
}
vector__cpp__decl::__t vector__cpp__decl::__t::segment  (const vector__cpp__decl::domain::__t &beg,const
    vector__cpp__decl::domain::__t &en) const
{
    vector__cpp__decl::__t res;
    {
        vector__cpp__decl::domain::__t idx;
        idx = beg;
        while (idx < en & idx < (*this) . end)
        {
            res . append ((*this) . value (idx));
            idx = idx . next();
        }
    }
    return res;
}
void vector__cpp__decl::__t::reverse ()
{
    vector__cpp__decl::domain::__t idx;
    idx = (*this) . begin();
    vector__cpp__decl::domain::__t jdx;
    jdx = (*this) . end . prev();
    while (idx < jdx)
    {
        ivy::ptr< cpp::decl::__t > tmp;
        tmp = (*this) . value (idx);
        (*this) . value (idx) = (*this) . value (jdx);
        (*this) . value (jdx) = tmp;
        jdx = jdx . prev();
        idx = idx . next();
    }
}
void cpp::structdecl::__t::encode  (pretty::__t &b,const priority::__t &prio) const
{
    (*this) . ann -> encode (b);
    b . nest();
    b . extend (ivy::from_str< str::__t > ("struct"));
    b . extend (ivy::from_str< str::__t > (" "));
    (*this) . name -> encode (b,priority::__t (0));
    if ((*this) . has_super)
    {
        b . extend (ivy::from_str< str::__t > (" "));
        b . extend (ivy::from_str< str::__t > (":"));
        b . extend (ivy::from_str< str::__t > (" "));
        (*this) . super -> encode (b,priority::__t (0));
    }
    if ((*this) . has_members)
    {
        b . unnest();
        b . newline();
        b . extend (ivy::from_str< str::__t > ("{"));
        b . nest();
        vector__cpp__decl::domain::__t idx;
        idx = (*this) . members . begin();
        while (idx < (*this) . members . end)
        {
            b . newline();
            (*this) . members . value (idx) -> encode (b,priority::__t (0));
            idx = idx . next();
        }
        b . unnest();
        b . newline();
        b . extend (ivy::from_str< str::__t > ("}"));
        b . extend (ivy::from_str< str::__t > (";"));
    } else {
        b . extend (ivy::from_str< str::__t > (";"));
        b . unnest();
    }
    b . newline();
}
ivy::ptr< annot::__t > cpp::structdecl::__t::get_ann () const
{
    ivy::ptr< annot::__t > res;
    res = (*this) . ann;
    return res;
}
void cpp::namespacedecl::__t::encode  (pretty::__t &b,const priority::__t &prio) const
{
    (*this) . ann -> encode (b);
    b . nest();
    b . extend (ivy::from_str< str::__t > ("namespace"));
    b . extend (ivy::from_str< str::__t > (" "));
    (*this) . name -> encode (b,priority::__t (0));
    b . unnest();
    b . newline();
    b . extend (ivy::from_str< str::__t > ("{"));
    b . nest();
    vector__cpp__decl::domain::__t idx;
    idx = (*this) . members . begin();
    while (idx < (*this) . members . end)
    {
        b . newline();
        (*this) . members . value (idx) -> encode (b,priority::__t (0));
        idx = idx . next();
    }
    b . unnest();
    b . newline();
    b . extend (ivy::from_str< str::__t > ("}"));
    b . newline();
}
ivy::ptr< annot::__t > cpp::namespacedecl::__t::get_ann () const
{
    ivy::ptr< annot::__t > res;
    res = (*this) . ann;
    return res;
}
void cpp::groupdc::__t::encode  (pretty::__t &b,const priority::__t &prio) const
{
    vector__cpp__decl::domain::__t idx;
    idx = (*this) . decls . begin();
    while (idx < (*this) . decls . end)
    {
        b . newline();
        if (idx > vector__cpp__decl::domain::__t (0)) {
            b . newline();
        }
        (*this) . decls . value (idx) -> encode (b,priority::__t (0));
        idx = idx . next();
    }
    {}
}
void cpp::decl::parse  (pstate::__t &st,const priority::__t &prio,ivy::ptr< cpp::decl::__t > &res)
{
    ivy::ptr< annot::__t > ann;
    st . get_ann (ann);
    if (st . tok == ivy::from_str< str::__t > ("typedef"))
    {
        st . consume();
        cpp::typedecl::__t t;
        cpp::simpletype::parse (st,priority::__t (0),t . ttype);
        t . ann = ann;
        if (st . ok & st . tok == ivy::from_str< str::__t > (";")) {
            st . consume();
        } else {
            st . ok = ivy::native_bool (false);
        }
        res = t;
    } else
    {
        if (st . tok == ivy::from_str< str::__t > ("enum"))
        {
            st . consume();
            cpp::enumdecl::__t t;
            cpp::symbol::parse (st,t . name);
            cpp::curly_tup::parse (st,priority::__t (1),t . elems);
            t . ann = ann;
            if (st . ok & st . tok == ivy::from_str< str::__t > (";")) {
                st . consume();
            } else {
                st . ok = ivy::native_bool (false);
            }
            res = t;
        } else
        {
            if (st . tok == ivy::from_str< str::__t > ("struct"))
            {
                st . consume();
                cpp::structdecl::__t t;
                cpp::symbol::parse (st,t . name);
                t . ann = ann;
                if (st . ok & st . tok == ivy::from_str< str::__t > (":"))
                {
                    st . consume();
                    t . has_super = ivy::native_bool (true);
                    cpp::symbol::parse (st,t . super);
                }
                if (st . ok & st . tok == ivy::from_str< str::__t > ("{"))
                {
                    st . consume();
                    cpp::decl::parse_list (st,priority::__t (0),t . members);
                    if (st . ok & st . tok == ivy::from_str< str::__t > ("}")) {
                        st . consume();
                    } else {
                        st . ok = ivy::native_bool (false);
                    }
                }
                if (st . ok & st . tok == ivy::from_str< str::__t > (";")) {
                    st . consume();
                } else {
                    st . ok = ivy::native_bool (false);
                }
                res = t;
            } else
            {
                if (st . tok == ivy::from_str< str::__t > ("namespace"))
                {
                    st . consume();
                    cpp::namespacedecl::__t t;
                    cpp::symbol::parse (st,t . name);
                    t . ann = ann;
                    if (st . ok & st . tok == ivy::from_str< str::__t > ("{"))
                    {
                        st . consume();
                        cpp::decl::parse_list (st,priority::__t (0),t . members);
                        if (st . ok & st . tok == ivy::from_str< str::__t > ("}")) {
                            st . consume();
                        } else {
                            st . ok = ivy::native_bool (false);
                        }
                    }
                    res = t;
                } else
                {
                    if (st . tok == ivy::from_str< str::__t > ("#"))
                    {
                        cpp::header::__t s;
                        st . consume();
                        if (st . ok & st . tok == ivy::from_str< str::__t > ("include"))
                        {
                            st . consume();
                            if (st . ok & st . tok . end > pos::__t (0) &
                            st . tok . value (pos::__t (0)) == __char::__t (34))
                            {
                                
                                // double quote
                                
                                s . filename = st . tok;
                                st . consume();
                            } else {
                                st . ok = ivy::native_bool (false);
                            }
                        } else {
                            st . ok = ivy::native_bool (false);
                        }
                    } else
                    {
                        cpp::simpletype::__t t;
                        __bool is_static;
                        if (st . ok & st . tok == ivy::from_str< str::__t > ("static"))
                        {
                            is_static = ivy::native_bool (true);
                            st . consume();
                        }
                        cpp::simpletype::parse (st,prio,t);
                        if (st . ok & st . tok == ivy::from_str< str::__t > ("("))
                        {
                            cpp::funcdecl::__t s;
                            s . ann = ann;
                            s . is_static = is_static;
                            cpp::functype::parse (st,t,prio,s . ftype);
                            if (st . ok & st . tok == ivy::from_str< str::__t > (";"))
                            {
                                st . consume();
                            } else
                            {
                                if (st . ok & st . tok == ivy::from_str< str::__t > ("{"))
                                {
                                    s . has_body = ivy::native_bool (true);
                                    cpp::stmt::parse (st,priority::__t (0),s . body);
                                } else {
                                    st . ok = ivy::native_bool (false);
                                }
                            }
                            res = s;
                        } else
                        {
                            if (st . ok & st . tok == ivy::from_str< str::__t > (";"))
                            {
                                st . consume();
                                cpp::vardecl::__t s;
                                s . vtype = t;
                                s . ann = ann;
                                res = s;
                            } else {
                                st . ok = ivy::native_bool (false);
                            }
                        }
                    }
                }
            }
        }
    }
}
void cpp::decl::parse_list  (pstate::__t &st,const priority::__t &prio,vector__cpp__decl::__t &res)
{
    while (st . ok & st . tok . end > pos::__t (0) & st . tok != ivy::from_str< str::__t > ("}"))
    {
        ivy::ptr< cpp::decl::__t > s;
        cpp::decl::parse (st,priority::__t (0),s);
        res . append (s);
    }
}
void cpp::version::__t::encode  (pretty::__t &b) const
{
    b . extend (ivy::from_str< str::__t > ("#lang ivy"));
    vector__pos::domain::__t idx;
    idx = (*this) . nums . begin();
    while (idx < (*this) . nums . end)
    {
        if (idx > (*this) . nums . begin()) {
            b . extend (ivy::from_str< str::__t > ("."));
        }
        b . extend ((*this) . nums . value (idx) . to_str());
        idx = idx . next();
    }
}
void cpp::version::parse  (pstate::__t &st,const priority::__t &prio,cpp::version::__t &res)
{
    if (st . ok & st . tok == ivy::from_str< str::__t > ("lang")) {
        st . consume();
    } else {
        st . ok = ivy::native_bool (false);
    }
    if (st . ok & st . tok . segment (pos::__t (0),pos::__t (3)) ==
    ivy::from_str< str::__t > ("ivy"))
    {
        st . p = st . p - (st . tok . end - pos::__t (3));
        st . consume();
    }
    if (st . ok & st . tok . end > pos::__t (0) & st . tok . value (pos::__t (0)) . is_digit())
    {
        res . nums . append (pos::from_str (st . tok));
        st . consume();
        while (st . ok & st . tok == ivy::from_str< str::__t > ("."))
        {
            st . consume();
            if (st . tok . end > pos::__t (0) & st . tok . value (pos::__t (0)) . is_digit())
            {
                res . nums . append (pos::from_str (st . tok));
                st . consume();
            } else {
                st . ok = ivy::native_bool (false);
            }
        }
    }
    if (st . tok . end > pos::__t (0)) {
        st . ok = ivy::native_bool (false);
    }
}
str::__t cpp::prog::__t::enc () const
{
    str::__t s;
    {
        pretty::__t p;
        p = pretty::make (pos::__t (100),pos::__t (4));
        p . cppstyle = ivy::native_bool (true);
        (*this) . encode (p,priority::__t (0));
        p . flush();
        s = p . output;
    }
    return s;
}
cpp::prog::__t cpp::prog::dec  (const str::__t &s)
{
    cpp::prog::__t e;
    {
        pstate::__t st;
        st = pstate::make (s);
        cpp::prog::parse (st,priority::__t (0),e);
        if (! st . ok | st . tok . end != pos::__t (0)) {
            parse_error (st . ann . line,st . tok);
        }
    }
    return e;
}
str::__t cpp::prog::encdec  (const str::__t &s)
{
    str::__t res;
    {
        cpp::prog::__t e;
        e = cpp::prog::dec (s);
        res = e . enc();
    }
    return res;
}
cpp::prog::__t cpp::prog::make  (const vector__cpp__decl::__t &decls)
{
    cpp::prog::__t res;
    {
        cpp::prog::__t s;
        s . decls = decls;
        res = s;
    }
    return res;
}
void cpp::prog::__t::encode  (pretty::__t &b,const priority::__t &prio) const
{
    if (! ivy::native_bool (true)) {
        (*this) . vers . encode (b);
    }
    b . newline();
    vector__cpp__decl::domain::__t idx;
    idx = (*this) . decls . begin();
    while (idx < (*this) . decls . end)
    {
        b . newline();
        if (idx > vector__cpp__decl::domain::__t (0)) {
            b . newline();
        }
        (*this) . decls . value (idx) -> encode (b,priority::__t (0));
        idx = idx . next();
    }
    {}
}
void cpp::prog::parse_to  (pstate::__t &st,const priority::__t &prio,cpp::prog::__t &res)
{
    if (! ivy::native_bool (true))
    {
        if (st . ann . comments . end > vector__str::domain::__t (0))
        {
            pstate::__t vst;
            vst = pstate::make (st . ann . comments . value (vector__str::domain::__t (0)));
            cpp::version::parse (vst,priority::__t (0),res . vers);
            st . ok = vst . ok;
            st . ann . comments =
                st . ann . comments . segment (vector__str::domain::__t (1),st . ann . comments .
                    end);
        } else {
            st . ok = ivy::native_bool (false);
        }
        {}
    }
    while (st . ok & st . tok . end > pos::__t (0))
    {
        ivy::ptr< cpp::decl::__t > dcl;
        cpp::decl::parse (st,priority::__t (0),dcl);
        res . decls . append (dcl);
    }
}
void cpp::prog::parse  (pstate::__t &st,const priority::__t &prio,cpp::prog::__t &res)
{
    cpp::prog::parse_to (st,prio,res);
}
ivy::ptr< cpp::expr::__t > cpp::namedtype  (const ivy::ptr< cpp::ident::__t > &name,const ivy::ptr< annot::__t >
    &ann)
{
    ivy::ptr< cpp::expr::__t > res;
    {
        cpp::symbol::__t s;
        s . name = name;
        s . ann = ann -> strip();
        res = s;
    }
    return res;
}
ivy::ptr< cpp::expr::__t > cpp::inttype  (const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< cpp::expr::__t > res;
    res = cpp::namedtype (cpp::strident::make (ivy::from_str< str::__t > ("int")),ann);
    return res;
}
ivy::ptr< cpp::expr::__t > cpp::voidtype  (const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< cpp::expr::__t > res;
    res = cpp::namedtype (cpp::strident::make (ivy::from_str< str::__t > ("void")),ann);
    return res;
}
__bool ivy::path_may_alias  (const ivy::access_path::__t &v,const ivy::access_path::__t &w)
{
    __bool res;
    {
        res = ivy::native_bool (true);
        vector__ivy__ident::domain::__t idx;
        idx = v . elems . begin();
        while (res & idx < v . elems . end & idx < w . elems . end)
        {
            res = v . elems . value (idx) == w . elems . value (idx);
            idx = idx . next();
        }
    }
    return res;
}
vector__ivy__path_tree__undo_rec::domain::__t vector__ivy__path_tree__undo_rec::domain::__t::next ()
    const
{
    vector__ivy__path_tree__undo_rec::domain::__t y;
    y = (*this) + vector__ivy__path_tree__undo_rec::domain::__t (1);
    return y;
}
vector__ivy__path_tree__undo_rec::domain::__t vector__ivy__path_tree__undo_rec::domain::__t::prev ()
    const
{
    vector__ivy__path_tree__undo_rec::domain::__t y;
    y = (*this) - vector__ivy__path_tree__undo_rec::domain::__t (1);
    return y;
}
vector__ivy__path_tree__undo_rec::domain::__t vector__ivy__path_tree__undo_rec::__t::begin () const
{
    vector__ivy__path_tree__undo_rec::domain::__t res;
    res = vector__ivy__path_tree__undo_rec::domain::__t (0);
    return res;
}
vector__ivy__path_tree__undo_rec::__t vector__ivy__path_tree__undo_rec::empty ()
{
    vector__ivy__path_tree__undo_rec::__t res;
    {}
    return res;
}
void vector__ivy__path_tree__undo_rec::__t::set  (const vector__ivy__path_tree__undo_rec::domain::__t
    &i,const ivy::path_tree::undo_rec::__t &v) {
    (*this) . value (i) = v;
}
void vector__ivy__path_tree__undo_rec::__t::append  (const ivy::path_tree::undo_rec::__t &c)
{
    (*this) . value ((*this) . end) = c;
    (*this) . end = (*this) . end . next();
}
void vector__ivy__path_tree__undo_rec::__t::extend  (const vector__ivy__path_tree__undo_rec::__t &x)
{
    vector__ivy__path_tree__undo_rec::domain::__t idx;
    idx = x . begin();
    while (idx < x . end) {
        (*this) . append (x . value (idx));
        idx = idx . next();
    }
}
void vector__ivy__path_tree__undo_rec::__t::resize  (const vector__ivy__path_tree__undo_rec::domain::__t
    &end) {
    ivy::resize ((*this) . value,end);
    (*this) . end = end;
}
ivy::path_tree::undo_rec::__t vector__ivy__path_tree__undo_rec::__t::back () const
{
    ivy::path_tree::undo_rec::__t y;
    if ((*this) . end > vector__ivy__path_tree__undo_rec::domain::__t (0))
    {
        y = (*this) . value ((*this) . end . prev());
    }
    return y;
}
void vector__ivy__path_tree__undo_rec::__t::pop_back ()
{
    if ((*this) . end > vector__ivy__path_tree__undo_rec::domain::__t (0))
    {
        vector__ivy__path_tree__undo_rec::domain::__t size;
        size = (*this) . end . prev();
        (*this) . resize (size);
    }
}
vector__ivy__path_tree__undo_rec::__t vector__ivy__path_tree__undo_rec::__t::segment  (const
    vector__ivy__path_tree__undo_rec::domain::__t &beg,const vector__ivy__path_tree__undo_rec::domain::__t
    &en) const
{
    vector__ivy__path_tree__undo_rec::__t res;
    {
        vector__ivy__path_tree__undo_rec::domain::__t idx;
        idx = beg;
        while (idx < en & idx < (*this) . end)
        {
            res . append ((*this) . value (idx));
            idx = idx . next();
        }
    }
    return res;
}
void vector__ivy__path_tree__undo_rec::__t::reverse ()
{
    vector__ivy__path_tree__undo_rec::domain::__t idx;
    idx = (*this) . begin();
    vector__ivy__path_tree__undo_rec::domain::__t jdx;
    jdx = (*this) . end . prev();
    while (idx < jdx)
    {
        ivy::path_tree::undo_rec::__t tmp;
        tmp = (*this) . value (idx);
        (*this) . value (idx) = (*this) . value (jdx);
        (*this) . value (jdx) = tmp;
        jdx = jdx . prev();
        idx = idx . next();
    }
}
void ivy::path_tree::__t::add  (const ivy::access_path::__t &path,const ivy::ptr< ivy::ident::__t >
    &item)
{
    ivy::path_tree::undo_rec::__t und;
    ivy::ptr< ivy::ident::__t > id;
    id = path . elems . value (vector__ivy__ident::domain::__t (0));
    vector__ivy__ident::domain::__t idx;
    idx = path . elems . begin() . next();
    while (idx < path . elems . end)
    {
        ivy::ptr< ivy::ident::__t > newid;
        newid = path . elems . value (idx) -> prefix (id);
        if (! (*this) . value (newid) . present)
        {
            (*this) . value (id) . children . append (newid);
            (*this) . value (newid) . present = ivy::native_bool (true);
            und . children . append (id);
        }
        id = newid;
        idx = idx . next();
    }
    (*this) . value (id) . leaves . append (item);
    und . leaf = id;
    (*this) . undos . append (und);
}
void ivy::path_tree::__t::undo ()
{
    ivy::path_tree::undo_rec::__t und;
    und = (*this) . undos . back();
    vector__ivy__ident::domain::__t idx;
    idx = und . children . begin();
    while (idx < und . children . end)
    {
        ivy::ptr< ivy::ident::__t > id;
        id = und . children . value (idx);
        ivy::ptr< ivy::ident::__t > cid;
        cid = (*this) . value (id) . children . back();
        (*this) . value (id) . children . pop_back();
        (*this) . value (cid) . present = ivy::native_bool (false);
        idx = idx . next();
    }
    (*this) . value (und . leaf) . leaves . pop_back();
    (*this) . undos . pop_back();
}
vector__ivy__ident::__t ivy::path_tree::__t::collect  (const ivy::access_path::__t &path) const
{
    vector__ivy__ident::__t res;
    {
        ivy::ptr< ivy::ident::__t > id;
        id = path . elems . value (vector__ivy__ident::domain::__t (0));
        vector__ivy__ident::domain::__t idx;
        idx = path . elems . begin() . next();
        while (idx < path . elems . end)
        {
            res . extend ((*this) . value (id) . leaves);
            id = path . elems . value (idx) -> prefix (id);
            idx = idx . next();
        }
        (*this) . collect_rec (id,res);
    }
    return res;
}
void ivy::path_tree::__t::collect_rec  (const ivy::ptr< ivy::ident::__t > &id,vector__ivy__ident::__t
    &res) const
{
    ivy::path_tree::elem::__t elm;
    elm = (*this) . value (id);
    res . extend (elm . leaves);
    vector__ivy__ident::domain::__t idx;
    idx = elm . children . begin();
    while (idx < elm . children . end)
    {
        (*this) . collect_rec (elm . children . value (idx),res);
        idx = idx . next();
    }
}
vector__ivy__access_path::domain::__t vector__ivy__access_path::domain::__t::next () const
{
    vector__ivy__access_path::domain::__t y;
    y = (*this) + vector__ivy__access_path::domain::__t (1);
    return y;
}
vector__ivy__access_path::domain::__t vector__ivy__access_path::domain::__t::prev () const
{
    vector__ivy__access_path::domain::__t y;
    y = (*this) - vector__ivy__access_path::domain::__t (1);
    return y;
}
vector__ivy__access_path::domain::__t vector__ivy__access_path::__t::begin () const
{
    vector__ivy__access_path::domain::__t res;
    res = vector__ivy__access_path::domain::__t (0);
    return res;
}
vector__ivy__access_path::__t vector__ivy__access_path::empty ()
{
    vector__ivy__access_path::__t res;
    {}
    return res;
}
void vector__ivy__access_path::__t::set  (const vector__ivy__access_path::domain::__t &i,const ivy::access_path::__t
    &v) {
    (*this) . value (i) = v;
}
void vector__ivy__access_path::__t::append  (const ivy::access_path::__t &c)
{
    (*this) . value ((*this) . end) = c;
    (*this) . end = (*this) . end . next();
}
void vector__ivy__access_path::__t::extend  (const vector__ivy__access_path::__t &x)
{
    vector__ivy__access_path::domain::__t idx;
    idx = x . begin();
    while (idx < x . end) {
        (*this) . append (x . value (idx));
        idx = idx . next();
    }
}
void vector__ivy__access_path::__t::resize  (const vector__ivy__access_path::domain::__t &end)
{
    ivy::resize ((*this) . value,end);
    (*this) . end = end;
}
ivy::access_path::__t vector__ivy__access_path::__t::back () const
{
    ivy::access_path::__t y;
    if ((*this) . end > vector__ivy__access_path::domain::__t (0))
    {
        y = (*this) . value ((*this) . end . prev());
    }
    return y;
}
void vector__ivy__access_path::__t::pop_back ()
{
    if ((*this) . end > vector__ivy__access_path::domain::__t (0))
    {
        vector__ivy__access_path::domain::__t size;
        size = (*this) . end . prev();
        (*this) . resize (size);
    }
}
vector__ivy__access_path::__t vector__ivy__access_path::__t::segment  (const
    vector__ivy__access_path::domain::__t &beg,const vector__ivy__access_path::domain::__t &en)
    const
{
    vector__ivy__access_path::__t res;
    {
        vector__ivy__access_path::domain::__t idx;
        idx = beg;
        while (idx < en & idx < (*this) . end)
        {
            res . append ((*this) . value (idx));
            idx = idx . next();
        }
    }
    return res;
}
void vector__ivy__access_path::__t::reverse ()
{
    vector__ivy__access_path::domain::__t idx;
    idx = (*this) . begin();
    vector__ivy__access_path::domain::__t jdx;
    jdx = (*this) . end . prev();
    while (idx < jdx)
    {
        ivy::access_path::__t tmp;
        tmp = (*this) . value (idx);
        (*this) . value (idx) = (*this) . value (jdx);
        (*this) . value (jdx) = tmp;
        jdx = jdx . prev();
        idx = idx . next();
    }
}
ivy::ident_to_declvec::__t ivy::ident_to_declvec::empty () {
    ivy::ident_to_declvec::__t a;
    {}
    return a;
}
void ivy::ident_to_declvec::__t::set  (const ivy::ptr< ivy::ident::__t > &x,const vector__ivy__decl::__t
    &y)
{
    ivy::ident_to_declvec::rec z;
    z . full = ivy::native_bool (true);
    z . val = y;
    (*this) . map (x) = z;
}
void ivy::ident_to_declvec::__t::get  (const ivy::ptr< ivy::ident::__t > &x,vector__ivy__decl::__t &y)
    const {
    ivy::ident_to_declvec::rec z;
    z = (*this) . map (x);
    if (z . full) {
        y = z . val;
    }
}
__bool ivy::ident_to_declvec::__t::mem  (const ivy::ptr< ivy::ident::__t > &x) const
{
    __bool res;
    res = (*this) . map (x) . full;
    return res;
}
void ivy::ident_to_declvec::__t::remove  (const ivy::ptr< ivy::ident::__t > &x)
{
    ivy::ident_to_declvec::rec z;
    (*this) . map (x) = z;
}
vector__ivy__decl::__t ivy::ident_to_declvec::__t::value  (const ivy::ptr< ivy::ident::__t > &x)
    const {
    vector__ivy__decl::__t y;
    y = (*this) . map (x) . val;
    return y;
}
ivy::ident_to_cppclass::__t ivy::ident_to_cppclass::empty ()
{
    ivy::ident_to_cppclass::__t a;
    {}
    return a;
}
void ivy::ident_to_cppclass::__t::set  (const ivy::ptr< ivy::ident::__t > &x,const ivy::ptr< ivy::expr::__t >
    &y)
{
    ivy::ident_to_cppclass::rec z;
    z . full = ivy::native_bool (true);
    z . val = y;
    (*this) . map (x) = z;
}
void ivy::ident_to_cppclass::__t::get  (const ivy::ptr< ivy::ident::__t > &x,ivy::ptr< ivy::expr::__t >
    &y) const {
    ivy::ident_to_cppclass::rec z;
    z = (*this) . map (x);
    if (z . full) {
        y = z . val;
    }
}
__bool ivy::ident_to_cppclass::__t::mem  (const ivy::ptr< ivy::ident::__t > &x) const
{
    __bool res;
    res = (*this) . map (x) . full;
    return res;
}
void ivy::ident_to_cppclass::__t::remove  (const ivy::ptr< ivy::ident::__t > &x)
{
    ivy::ident_to_cppclass::rec z;
    (*this) . map (x) = z;
}
ivy::ptr< ivy::expr::__t > ivy::ident_to_cppclass::__t::value  (const ivy::ptr< ivy::ident::__t > &x)
    const {
    ivy::ptr< ivy::expr::__t > y;
    y = (*this) . map (x) . val;
    return y;
}
ivy::ident_to_prototype::__t ivy::ident_to_prototype::empty ()
{
    ivy::ident_to_prototype::__t a;
    {}
    return a;
}
void ivy::ident_to_prototype::__t::set  (const ivy::ptr< ivy::ident::__t > &x,const ivy::prototype::__t
    &y)
{
    ivy::ident_to_prototype::rec z;
    z . full = ivy::native_bool (true);
    z . val = y;
    (*this) . map (x) = z;
}
void ivy::ident_to_prototype::__t::get  (const ivy::ptr< ivy::ident::__t > &x,ivy::prototype::__t &y)
    const {
    ivy::ident_to_prototype::rec z;
    z = (*this) . map (x);
    if (z . full) {
        y = z . val;
    }
}
__bool ivy::ident_to_prototype::__t::mem  (const ivy::ptr< ivy::ident::__t > &x) const
{
    __bool res;
    res = (*this) . map (x) . full;
    return res;
}
void ivy::ident_to_prototype::__t::remove  (const ivy::ptr< ivy::ident::__t > &x)
{
    ivy::ident_to_prototype::rec z;
    (*this) . map (x) = z;
}
ivy::prototype::__t ivy::ident_to_prototype::__t::value  (const ivy::ptr< ivy::ident::__t > &x)
    const {
    ivy::prototype::__t y;
    y = (*this) . map (x) . val;
    return y;
}
ivy::ident_to_borrowing::map_t::__t ivy::ident_to_borrowing::map_t::empty ()
{
    ivy::ident_to_borrowing::map_t::__t a;
    {}
    return a;
}
void ivy::ident_to_borrowing::map_t::__t::set  (const ivy::ptr< ivy::ident::__t > &x,const ivy::borrowing::__t
    &y)
{
    ivy::ident_to_borrowing::map_t::rec z;
    z . full = ivy::native_bool (true);
    z . val = y;
    (*this) . map (x) = z;
}
void ivy::ident_to_borrowing::map_t::__t::get  (const ivy::ptr< ivy::ident::__t > &x,ivy::borrowing::__t
    &y) const
{
    ivy::ident_to_borrowing::map_t::rec z;
    z = (*this) . map (x);
    if (z . full) {
        y = z . val;
    }
}
__bool ivy::ident_to_borrowing::map_t::__t::mem  (const ivy::ptr< ivy::ident::__t > &x) const
{
    __bool res;
    res = (*this) . map (x) . full;
    return res;
}
void ivy::ident_to_borrowing::map_t::__t::remove  (const ivy::ptr< ivy::ident::__t > &x)
{
    ivy::ident_to_borrowing::map_t::rec z;
    (*this) . map (x) = z;
}
ivy::borrowing::__t ivy::ident_to_borrowing::map_t::__t::value  (const ivy::ptr< ivy::ident::__t > &x)
    const {
    ivy::borrowing::__t y;
    y = (*this) . map (x) . val;
    return y;
}
pos::__t ivy::ident_to_borrowing::vec_t::__t::begin () const
{
    pos::__t res;
    res = pos::__t (0);
    return res;
}
ivy::ident_to_borrowing::vec_t::__t ivy::ident_to_borrowing::vec_t::empty ()
{
    ivy::ident_to_borrowing::vec_t::__t res;
    {}
    return res;
}
void ivy::ident_to_borrowing::vec_t::__t::set  (const pos::__t &i,const ivy::ident_to_borrowing::undo
    &v) {
    (*this) . value (i) = v;
}
void ivy::ident_to_borrowing::vec_t::__t::append  (const ivy::ident_to_borrowing::undo &c)
{
    (*this) . value ((*this) . end) = c;
    (*this) . end = (*this) . end . next();
}
void ivy::ident_to_borrowing::vec_t::__t::extend  (const ivy::ident_to_borrowing::vec_t::__t &x)
{
    pos::__t idx;
    idx = x . begin();
    while (idx < x . end) {
        (*this) . append (x . value (idx));
        idx = idx . next();
    }
}
void ivy::ident_to_borrowing::vec_t::__t::resize  (const pos::__t &end)
{
    ivy::resize ((*this) . value,end);
    (*this) . end = end;
}
ivy::ident_to_borrowing::undo ivy::ident_to_borrowing::vec_t::__t::back () const
{
    ivy::ident_to_borrowing::undo y;
    if ((*this) . end > pos::__t (0)) {
        y = (*this) . value ((*this) . end . prev());
    }
    return y;
}
void ivy::ident_to_borrowing::vec_t::__t::pop_back ()
{
    if ((*this) . end > pos::__t (0))
    {
        pos::__t size;
        size = (*this) . end . prev();
        (*this) . resize (size);
    }
}
ivy::ident_to_borrowing::vec_t::__t ivy::ident_to_borrowing::vec_t::__t::segment  (const pos::__t &beg,const
    pos::__t &en) const
{
    ivy::ident_to_borrowing::vec_t::__t res;
    {
        pos::__t idx;
        idx = beg;
        while (idx < en & idx < (*this) . end)
        {
            res . append ((*this) . value (idx));
            idx = idx . next();
        }
    }
    return res;
}
void ivy::ident_to_borrowing::vec_t::__t::reverse ()
{
    pos::__t idx;
    idx = (*this) . begin();
    pos::__t jdx;
    jdx = (*this) . end . prev();
    while (idx < jdx)
    {
        ivy::ident_to_borrowing::undo tmp;
        tmp = (*this) . value (idx);
        (*this) . value (idx) = (*this) . value (jdx);
        (*this) . value (jdx) = tmp;
        jdx = jdx . prev();
        idx = idx . next();
    }
}
void ivy::ident_to_borrowing::__t::set  (const ivy::ptr< ivy::ident::__t > &id,const ivy::borrowing::__t
    &v)
{
    ivy::ident_to_borrowing::undo und;
    und . id = id;
    und . present = (*this) . map . mem (id);
    if (und . present) {
        und . value = (*this) . map . value (id);
    }
    (*this) . del . append (und);
    (*this) . map . set (id,v);
}
__bool ivy::ident_to_borrowing::__t::mem  (const ivy::ptr< ivy::ident::__t > &id) const
{
    __bool res;
    res = (*this) . map . mem (id);
    return res;
}
ivy::borrowing::__t ivy::ident_to_borrowing::__t::value  (const ivy::ptr< ivy::ident::__t > &id)
    const {
    ivy::borrowing::__t res;
    res = (*this) . map . value (id);
    return res;
}
void ivy::ident_to_borrowing::__t::push () {
    (*this) . stack . append ((*this) . del . end);
}
void ivy::ident_to_borrowing::__t::pop ()
{
    pos::__t begin;
    begin = (*this) . stack . back();
    (*this) . stack . pop_back();
    while ((*this) . del . end > begin)
    {
        ivy::ident_to_borrowing::undo x;
        x = (*this) . del . back();
        if (x . present) {
            (*this) . map . set (x . id,x . value);
        } else {
            (*this) . map . remove (x . id);
        }
        (*this) . del . pop_back();
    }
}
ivy::cppident_to_cppexpr::map_t::__t ivy::cppident_to_cppexpr::map_t::empty ()
{
    ivy::cppident_to_cppexpr::map_t::__t a;
    {}
    return a;
}
void ivy::cppident_to_cppexpr::map_t::__t::set  (const ivy::ptr< cpp::ident::__t > &x,const ivy::ptr< cpp::expr::__t >
    &y)
{
    ivy::cppident_to_cppexpr::map_t::rec z;
    z . full = ivy::native_bool (true);
    z . val = y;
    (*this) . map (x) = z;
}
void ivy::cppident_to_cppexpr::map_t::__t::get  (const ivy::ptr< cpp::ident::__t > &x,ivy::ptr< cpp::expr::__t >
    &y) const
{
    ivy::cppident_to_cppexpr::map_t::rec z;
    z = (*this) . map (x);
    if (z . full) {
        y = z . val;
    }
}
__bool ivy::cppident_to_cppexpr::map_t::__t::mem  (const ivy::ptr< cpp::ident::__t > &x) const
{
    __bool res;
    res = (*this) . map (x) . full;
    return res;
}
void ivy::cppident_to_cppexpr::map_t::__t::remove  (const ivy::ptr< cpp::ident::__t > &x)
{
    ivy::cppident_to_cppexpr::map_t::rec z;
    (*this) . map (x) = z;
}
ivy::ptr< cpp::expr::__t > ivy::cppident_to_cppexpr::map_t::__t::value  (const ivy::ptr< cpp::ident::__t >
    &x) const {
    ivy::ptr< cpp::expr::__t > y;
    y = (*this) . map (x) . val;
    return y;
}
pos::__t ivy::cppident_to_cppexpr::vec_t::__t::begin () const
{
    pos::__t res;
    res = pos::__t (0);
    return res;
}
ivy::cppident_to_cppexpr::vec_t::__t ivy::cppident_to_cppexpr::vec_t::empty ()
{
    ivy::cppident_to_cppexpr::vec_t::__t res;
    {}
    return res;
}
void ivy::cppident_to_cppexpr::vec_t::__t::set  (const pos::__t &i,const ivy::cppident_to_cppexpr::undo
    &v) {
    (*this) . value (i) = v;
}
void ivy::cppident_to_cppexpr::vec_t::__t::append  (const ivy::cppident_to_cppexpr::undo &c)
{
    (*this) . value ((*this) . end) = c;
    (*this) . end = (*this) . end . next();
}
void ivy::cppident_to_cppexpr::vec_t::__t::extend  (const ivy::cppident_to_cppexpr::vec_t::__t &x)
{
    pos::__t idx;
    idx = x . begin();
    while (idx < x . end) {
        (*this) . append (x . value (idx));
        idx = idx . next();
    }
}
void ivy::cppident_to_cppexpr::vec_t::__t::resize  (const pos::__t &end)
{
    ivy::resize ((*this) . value,end);
    (*this) . end = end;
}
ivy::cppident_to_cppexpr::undo ivy::cppident_to_cppexpr::vec_t::__t::back () const
{
    ivy::cppident_to_cppexpr::undo y;
    if ((*this) . end > pos::__t (0)) {
        y = (*this) . value ((*this) . end . prev());
    }
    return y;
}
void ivy::cppident_to_cppexpr::vec_t::__t::pop_back ()
{
    if ((*this) . end > pos::__t (0))
    {
        pos::__t size;
        size = (*this) . end . prev();
        (*this) . resize (size);
    }
}
ivy::cppident_to_cppexpr::vec_t::__t ivy::cppident_to_cppexpr::vec_t::__t::segment  (const pos::__t
    &beg,const pos::__t &en) const
{
    ivy::cppident_to_cppexpr::vec_t::__t res;
    {
        pos::__t idx;
        idx = beg;
        while (idx < en & idx < (*this) . end)
        {
            res . append ((*this) . value (idx));
            idx = idx . next();
        }
    }
    return res;
}
void ivy::cppident_to_cppexpr::vec_t::__t::reverse ()
{
    pos::__t idx;
    idx = (*this) . begin();
    pos::__t jdx;
    jdx = (*this) . end . prev();
    while (idx < jdx)
    {
        ivy::cppident_to_cppexpr::undo tmp;
        tmp = (*this) . value (idx);
        (*this) . value (idx) = (*this) . value (jdx);
        (*this) . value (jdx) = tmp;
        jdx = jdx . prev();
        idx = idx . next();
    }
}
void ivy::cppident_to_cppexpr::__t::set  (const ivy::ptr< cpp::ident::__t > &id,const ivy::ptr< cpp::expr::__t >
    &v)
{
    ivy::cppident_to_cppexpr::undo und;
    und . id = id;
    und . present = (*this) . map . mem (id);
    if (und . present) {
        und . value = (*this) . map . value (id);
    }
    (*this) . del . append (und);
    (*this) . map . set (id,v);
}
__bool ivy::cppident_to_cppexpr::__t::mem  (const ivy::ptr< cpp::ident::__t > &id) const
{
    __bool res;
    res = (*this) . map . mem (id);
    return res;
}
ivy::ptr< cpp::expr::__t > ivy::cppident_to_cppexpr::__t::value  (const ivy::ptr< cpp::ident::__t >
    &id) const {
    ivy::ptr< cpp::expr::__t > res;
    res = (*this) . map . value (id);
    return res;
}
void ivy::cppident_to_cppexpr::__t::push () {
    (*this) . stack . append ((*this) . del . end);
}
void ivy::cppident_to_cppexpr::__t::pop ()
{
    pos::__t begin;
    begin = (*this) . stack . back();
    (*this) . stack . pop_back();
    while ((*this) . del . end > begin)
    {
        ivy::cppident_to_cppexpr::undo x;
        x = (*this) . del . back();
        if (x . present) {
            (*this) . map . set (x . id,x . value);
        } else {
            (*this) . map . remove (x . id);
        }
        (*this) . del . pop_back();
    }
}
vector__ivy__lvalue_count::domain::__t vector__ivy__lvalue_count::domain::__t::next () const
{
    vector__ivy__lvalue_count::domain::__t y;
    y = (*this) + vector__ivy__lvalue_count::domain::__t (1);
    return y;
}
vector__ivy__lvalue_count::domain::__t vector__ivy__lvalue_count::domain::__t::prev () const
{
    vector__ivy__lvalue_count::domain::__t y;
    y = (*this) - vector__ivy__lvalue_count::domain::__t (1);
    return y;
}
vector__ivy__lvalue_count::domain::__t vector__ivy__lvalue_count::__t::begin () const
{
    vector__ivy__lvalue_count::domain::__t res;
    res = vector__ivy__lvalue_count::domain::__t (0);
    return res;
}
vector__ivy__lvalue_count::__t vector__ivy__lvalue_count::empty ()
{
    vector__ivy__lvalue_count::__t res;
    {}
    return res;
}
void vector__ivy__lvalue_count::__t::set  (const vector__ivy__lvalue_count::domain::__t &i,const ivy::lvalue_count
    &v) {
    (*this) . value (i) = v;
}
void vector__ivy__lvalue_count::__t::append  (const ivy::lvalue_count &c)
{
    (*this) . value ((*this) . end) = c;
    (*this) . end = (*this) . end . next();
}
void vector__ivy__lvalue_count::__t::extend  (const vector__ivy__lvalue_count::__t &x)
{
    vector__ivy__lvalue_count::domain::__t idx;
    idx = x . begin();
    while (idx < x . end) {
        (*this) . append (x . value (idx));
        idx = idx . next();
    }
}
void vector__ivy__lvalue_count::__t::resize  (const vector__ivy__lvalue_count::domain::__t &end)
{
    ivy::resize ((*this) . value,end);
    (*this) . end = end;
}
ivy::lvalue_count vector__ivy__lvalue_count::__t::back () const
{
    ivy::lvalue_count y;
    if ((*this) . end > vector__ivy__lvalue_count::domain::__t (0))
    {
        y = (*this) . value ((*this) . end . prev());
    }
    return y;
}
void vector__ivy__lvalue_count::__t::pop_back ()
{
    if ((*this) . end > vector__ivy__lvalue_count::domain::__t (0))
    {
        vector__ivy__lvalue_count::domain::__t size;
        size = (*this) . end . prev();
        (*this) . resize (size);
    }
}
vector__ivy__lvalue_count::__t vector__ivy__lvalue_count::__t::segment  (const
    vector__ivy__lvalue_count::domain::__t &beg,const vector__ivy__lvalue_count::domain::__t &en)
    const
{
    vector__ivy__lvalue_count::__t res;
    {
        vector__ivy__lvalue_count::domain::__t idx;
        idx = beg;
        while (idx < en & idx < (*this) . end)
        {
            res . append ((*this) . value (idx));
            idx = idx . next();
        }
    }
    return res;
}
void vector__ivy__lvalue_count::__t::reverse ()
{
    vector__ivy__lvalue_count::domain::__t idx;
    idx = (*this) . begin();
    vector__ivy__lvalue_count::domain::__t jdx;
    jdx = (*this) . end . prev();
    while (idx < jdx)
    {
        ivy::lvalue_count tmp;
        tmp = (*this) . value (idx);
        (*this) . value (idx) = (*this) . value (jdx);
        (*this) . value (jdx) = tmp;
        jdx = jdx . prev();
        idx = idx . next();
    }
}
void ivy::tocppst::__t::add_member  (const ivy::ptr< ivy::ident::__t > &namesp,const ivy::ptr< ivy::decl::__t >
    &member)
{
    vector__ivy__decl::__t emp;
    vector__ivy__decl::__t __tmp20;
    __tmp20 = emp;
    (*this) . members . get (namesp,__tmp20);
    vector__ivy__decl::__t __tmp21;
    __tmp21 = __tmp20;
    __tmp21 . append (member);
    (*this) . members . set (namesp,__tmp21);
}
void ivy::tocppst::__t::add_stmt  (const ivy::ptr< cpp::stmt::__t > &code)
{
    (*this) . code . append (code);
}
void ivy::tocppst::__t::get_code  (const ivy::ptr< annot::__t > &ann,ivy::ptr< cpp::stmt::__t > &res)
{
    res = cpp::sequence::fold_right ((*this) . code,ann);
    (*this) . code = vector__cpp__stmt::empty();
}
void ivy::tocppst::__t::wrap_stmt  (const ivy::ptr< cpp::stmt::__t > &code,const ivy::ptr< annot::__t >
    &ann,ivy::ptr< cpp::stmt::__t > &res) {
    (*this) . add_stmt (code);
    (*this) . get_code (ann,res);
}
void ivy::temp_sym  (ivy::tocppst::__t &s,const ivy::ptr< annot::__t > &ann,ivy::ptr< cpp::expr::__t >
    &res)
{
    str::__t name;
    name = ivy::from_str< str::__t > ("__tmp");
    name . extend (s . counter . to_str());
    s . counter = s . counter . next();
    res = cpp::symbol::makestr (name,ann);
}
void ivy::make_temp  (ivy::tocppst::__t &s,const ivy::ptr< ivy::expr::__t > &ty,const ivy::ptr< annot::__t >
    &ann,ivy::ptr< cpp::expr::__t > &res)
{
    ivy::temp_sym (s,ann,res);
    cpp::varst::__t vst;
    ivy::fix_variant_type (ty,s,vst . vtype . _type);
    vst . vtype . name = res;
    vst . ann = ann;
    ivy::ptr< cpp::stmt::__t > vstt;
    vstt = vst;
    s . add_stmt (vstt);
}
void ivy::lvalue_path  (const ivy::ptr< ivy::expr::__t > &s,ivy::access_path::__t &path,__bool &ok)
{
    if (s . isa< ivy::symbol::__t >())
    {
        if (s -> get_verb() == ivy::verb::__t (ivy::verb::none))
        {
            path . elems . append (s -> get_name());
            ok = ivy::native_bool (true);
        }
    } else
    {
        if (s . isa< ivy::app::__t >())
        {
            if (s -> is (ivy::verb::__t (ivy::verb::colon)))
            {
                ivy::lvalue_path (s -> get_arg (vector__ivy__expr::domain::__t (0)),path,ok);
            } else
            {
                if (s -> is (ivy::verb::__t (ivy::verb::dot)))
                {
                    ivy::lvalue_path (s -> get_arg (vector__ivy__expr::domain::__t (0)),path,ok);
                    if (ok)
                    {
                        path . elems . append (s -> get_arg (vector__ivy__expr::domain::__t (1)) ->
                                        get_arg (vector__ivy__expr::domain::__t (0)) -> get_name());
                    }
                } else
                {
                    if (s -> is (ivy::verb::__t (ivy::verb::none)))
                    {
                        ivy::lvalue_path (s -> get_func(),path,ok);
                    }
                }
            }
        }
    }
}
void ivy::lvalue_paths  (const ivy::ptr< ivy::expr::__t > &s,vector__ivy__access_path::__t &paths,const
    __bool &ao,const __bool &ro)
{
    if (s -> is (ivy::verb::__t (ivy::verb::colon)))
    {
        ivy::lvalue_paths (s -> get_arg (vector__ivy__expr::domain::__t (0)),paths,ao,ro);
    } else
    {
        if (s -> is_typed (ivy::verb::__t (ivy::verb::comma)))
        {
            ivy::lvalue_paths (s -> get_arg (vector__ivy__expr::domain::__t (0)),paths,ao,ro);
            ivy::lvalue_paths (s -> get_arg (vector__ivy__expr::domain::__t (1)),paths,ao,ro);
        } else
        {
            if (! ao)
            {
                ivy::access_path::__t path;
                __bool ok;
                ivy::lvalue_path (s,path,ok);
                if (ok) {
                    paths . append (path);
                }
            }
            if (! ro & s . isa< ivy::app::__t >())
            {
                if (s -> is (ivy::verb::__t (ivy::verb::dot)))
                {
                    ivy::lvalue_paths (s -> get_arg (vector__ivy__expr::domain::__t (0)),paths,ivy::native_bool
                                (true),ivy::native_bool (false));
                } else
                {
                    vector__ivy__expr::__t args;
                    args = s -> get_args();
                    vector__ivy__expr::domain::__t idx;
                    idx = args . begin();
                    while (idx < args . end)
                    {
                        ivy::lvalue_paths (args . value (idx),paths,ivy::native_bool (false),ivy::native_bool
                                    (false));
                        idx = idx . next();
                    }
                }
            }
        }
    }
}
__bool ivy::is_dead  (const ivy::ptr< cpp::expr::__t > &e,const ivy::tocppst::__t &st,const pos::__t
    &cnt)
{
    __bool res;
    {
        vector__ivy__lvalue_count::domain::__t idx;
        idx = st . dead . begin();
        while (! res & idx < st . dead . end)
        {
            ivy::lvalue_count d;
            d = st . dead . value (idx);
            res = e -> eq (d . lvalue) & d . cnt <= cnt;
            idx = idx . next();
        }
    }
    return res;
}
void ivy::name_in_context  (ivy::ptr< ivy::expr::__t > &name,const ivy::tocppst::__t &st)
{
    if (st . in_class)
    {
        name = ivy::symbol::make (name -> get_name() -> get_member(),name -> get_ann());
    }
    {}
}
ivy::ptr< cpp::ident::__t > ivy::ident::__t::to_cpp  (const __bool &native) const
{
    ivy::ptr< cpp::ident::__t > res;
    {}
    return res;
}
str::__t ivy::mangle  (const ivy::ptr< cpp::ident::__t > &s)
{
    str::__t res;
    if (s . isa< cpp::dotident::__t >())
    {
        res = ivy::mangle (s -> get_namesp());
        res . extend (ivy::from_str< str::__t > ("__"));
        res . extend (s -> get_member() -> to_str());
    } else {
        res = s -> to_str();
    }
    return res;
}
cpp::strident::__t ivy::strident_to_cpp  (const ivy::strident::__t &s,const __bool &native)
{
    cpp::strident::__t t;
    {
        if (! native & ivy::cpp_reserved_word (s . val))
        {
            t . val = ivy::from_str< str::__t > ("__");
            t . val . extend (s . val);
        } else {
            t . val = s . val;
        }
        vector__ivy__ident::domain::__t idx;
        idx = s . subscrs . begin();
        while (idx < s . subscrs . end)
        {
            ivy::ptr< cpp::ident::__t > subs;
            subs = s . subscrs . value (idx) -> to_cpp (native);
            if (native) {
                t . subscrs . append (subs);
            } else
            {
                t . val . extend (ivy::from_str< str::__t > ("__"));
                t . val . extend (ivy::mangle (subs));
            }
            idx = idx . next();
        }
    }
    return t;
}
ivy::ptr< cpp::ident::__t > ivy::strident::__t::to_cpp  (const __bool &native) const
{
    ivy::ptr< cpp::ident::__t > res;
    {
        cpp::strident::__t x;
        x = ivy::strident_to_cpp ((*this),native);
        
        // workaround
        
        ivy::ptr< cpp::ident::__t > y;
        y = x;
        res = y;
    }
    return res;
}
ivy::ptr< cpp::ident::__t > ivy::dotident::__t::to_cpp  (const __bool &native) const
{
    ivy::ptr< cpp::ident::__t > res;
    {
        cpp::dotident::__t t;
        t . namesp = (*this) . namesp -> to_cpp (native);
        t . member = ivy::strident_to_cpp ((*this) . member,native);
        res = t;
    }
    return res;
}
void ivy::expr::__t::to_cpp  (ivy::tocppst::__t &st,ivy::ptr< cpp::expr::__t > &res) const {}
void ivy::fix_object_clash  (ivy::ptr< ivy::ident::__t > &id,const ivy::tocppst::__t &st)
{
    if (st . objects . mem (id))
    {
        ivy::strident::__t tok;
        tok . val = ivy::from_str< str::__t > ("__t");
        id = ivy::dotident::make (id,tok);
    }
}
void ivy::symbol::__t::to_cpp  (ivy::tocppst::__t &st,ivy::ptr< cpp::expr::__t > &res) const
{
    cpp::symbol::__t t;
    (*this) . to_cpp_int (st,t);
    t . ann = (*this) . ann;
    res = t;
}
void ivy::symbol::__t::to_cpp_int  (ivy::tocppst::__t &st,cpp::symbol::__t &res) const
{
    ivy::verb::__t vrb;
    vrb = (*this) . get_verb();
    if (vrb == ivy::verb::__t (ivy::verb::__not))
    {
        res . name = cpp::strident::make (ivy::from_str< str::__t > ("!"));
    } else
    {
        if (vrb == ivy::verb::__t (ivy::verb::equals))
        {
            res . name = cpp::strident::make (ivy::from_str< str::__t > ("=="));
        } else
        {
            if (vrb == ivy::verb::__t (ivy::verb::notequals))
            {
                res . name = cpp::strident::make (ivy::from_str< str::__t > ("!="));
            } else
            {
                if (vrb == ivy::verb::__t (ivy::verb::ite))
                {
                    res . name = cpp::strident::make (ivy::from_str< str::__t > ("?"));
                } else
                {
                    if (st . is_member & (*this) . name == st . this_ident & ! st . dot_rhs)
                    {
                        res . name = cpp::strident::make (ivy::from_str< str::__t > ("(*this)"));
                    } else
                    {
                        ivy::ptr< ivy::ident::__t > id;
                        id = (*this) . name;
                        if (! st . locals . mem (id))
                        {
                            id = (*this) . name;
                            ivy::fix_object_clash (id,st);
                        }
                        res . name = id -> to_cpp (st . native);
                    }
                }
            }
        }
    }
    res . vrb = cpp::str_to_verb (res . name -> to_str());
}
void ivy::make_vector_type  (ivy::ptr< ivy::expr::__t > &ty)
{
    ivy::strident::__t vid;
    vid . val = ivy::from_str< str::__t > ("vector");
    vid . subscrs . append (ty -> get_name());
    ivy::ptr< ivy::ident::__t > name;
    name = vid . prefix (ivy::strident::make (ivy::from_str< str::__t > ("ivy")));
    ty = ivy::symbol::make (name,ty -> get_ann());
}
void ivy::fix_tpl_param  (const ivy::ptr< ivy::expr::__t > &s,ivy::tocppst::__t &st,ivy::ptr< cpp::expr::__t >
    &res) {
    ivy::fix_variant_type (s,st,res);
}
void ivy::make_md_vector_type  (const vector__ivy__expr::__t &dom,const ivy::ptr< ivy::expr::__t > &rng,ivy::tocppst::__t
    &st,ivy::ptr< cpp::expr::__t > &res)
{
    cpp::strident::__t vid;
    vid . val = ivy::from_str< str::__t > ("vector");
    ivy::ptr< cpp::expr::__t > crng;
    ivy::fix_tpl_param (rng,st,crng);
    vid . subscrs . append (crng -> get_name());
    vector__ivy__expr::domain::__t idx;
    idx = dom . begin();
    while (idx < dom . end)
    {
        ivy::ptr< cpp::expr::__t > dty;
        ivy::fix_tpl_param (dom . value (idx),st,dty);
        vid . subscrs . append (dty -> get_name());
        idx = idx . next();
    }
    ivy::ptr< cpp::ident::__t > name;
    name = vid . prefix (cpp::strident::make (ivy::from_str< str::__t > ("ivy")));
    res = cpp::symbol::make (name,rng -> get_ann());
}
void ivy::function_type  (const ivy::ptr< ivy::expr::__t > &ty,ivy::tocppst::__t &st,ivy::ptr< cpp::expr::__t >
    &res)
{
    if (ty . isa< ivy::app::__t >())
    {
        ivy::make_md_vector_type (ivy::times::unfold_left (ty -> get_arg (vector__ivy__expr::domain::__t
                            (0))),ty -> get_arg (vector__ivy__expr::domain::__t (1)),st,res);
    } else {
        ty -> to_cpp (st,res);
    }
}
ivy::ptr< cpp::expr::__t > ivy::make_from_string  (const ivy::ptr< cpp::expr::__t > &ty,const ivy::ptr< cpp::expr::__t >
    &arg,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< cpp::expr::__t > res;
    {
        cpp::strident::__t id;
        id . val = ivy::from_str< str::__t > ("from_str");
        id . subscrs . append (ty -> get_name());
        ivy::ptr< cpp::ident::__t > name;
        name = cpp::dotident::make (cpp::strident::make (ivy::from_str< str::__t > ("ivy")),id);
        res = cpp::app::make1 (cpp::symbol::make (name,ann),arg,ann);
    }
    return res;
}
ivy::ptr< cpp::expr::__t > ivy::make_from_float  (const ivy::ptr< cpp::expr::__t > &ty,const ivy::ptr< cpp::expr::__t >
    &arg,const ivy::ptr< annot::__t > &ann)
{
    ivy::ptr< cpp::expr::__t > res;
    {
        cpp::strident::__t id;
        id . val = ivy::from_str< str::__t > ("from_flt");
        id . subscrs . append (ty -> get_name());
        ivy::ptr< cpp::ident::__t > name;
        name = cpp::dotident::make (cpp::strident::make (ivy::from_str< str::__t > ("ivy")),id);
        res = cpp::app::make1 (cpp::symbol::make (name,ann),arg,ann);
    }
    return res;
}
__bool ivy::is_cpp_this  (const ivy::ptr< cpp::expr::__t > &s)
{
    __bool res;
    if (s . isa< cpp::symbol::__t >())
    {
        res = s -> get_name() -> to_str() == ivy::from_str< str::__t > ("(*this)");
    }
    return res;
}
void ivy::make_cpp_call  (const ivy::ptr< ivy::expr::__t > &func,const vector__cpp__expr::__t &args,const
    ivy::ptr< annot::__t > &ann,ivy::tocppst::__t &st,const ivy::prototype::__t &proto,ivy::ptr< cpp::expr::__t >
    &res)
{
    if (ivy::func_is_member (func))
    {
        ivy::ptr< cpp::ident::__t > fid;
        fid =
            func -> get_arg (vector__ivy__expr::domain::__t (0)) -> get_name() -> to_cpp (ivy::native_bool
                    (false));
        ivy::ptr< cpp::expr::__t > cfunc;
        cfunc = cpp::symbol::make (fid -> get_member(),func -> get_ann());
        if (ivy::is_variant_type (ivy::get_dom0 (func -> get_arg (vector__ivy__expr::domain::__t (1))),st)
        & ! ivy::is_cpp_this (args . value (vector__cpp__expr::domain::__t (0))))
        {
            ivy::prototype_argument::__t arg;
            arg = proto . args . value (vector__ivy__prototype_argument::domain::__t (0));
            if (arg . is_const)
            {
                cfunc =
                    cpp::arrow::make (args . value (vector__cpp__expr::domain::__t (0)),cfunc,ann);
            } else
            {
                cfunc =
                    cpp::dot::make (cpp::app::make0 (cpp::dot::make (args . value (vector__cpp__expr::domain::__t
                                        (0)),cpp::symbol::makestr (ivy::from_str< str::__t > ("get"),ann),ann),ann),cfunc,ann);
            }
        } else
        {
            cfunc = cpp::dot::make (args . value (vector__cpp__expr::domain::__t (0)),cfunc,ann);
        }
        res =
            cpp::app::make (cfunc,args . segment (vector__cpp__expr::domain::__t (1),args . end),ann);
    } else
    {
        ivy::ptr< cpp::expr::__t > cfunc;
        func -> to_cpp (st,cfunc);
        res = cpp::app::make (cfunc,args,ann);
    }
}
void ivy::unown_func_args  (const vector__ivy__expr::__t &args,ivy::tocppst::__t &st)
{
    vector__ivy__expr::domain::__t idx;
    idx = args . begin();
    while (idx < args . end)
    {
        ivy::ptr< ivy::expr::__t > arg;
        arg = args . value (idx);
        ivy::access_path::__t path;
        __bool ok;
        ivy::lvalue_path (arg,path,ok);
        if (ok) {
            ivy::unown_path (path,st);
        }
        idx = idx . next();
    }
}
void ivy::make_rvalue_if_dead  (const ivy::tocppst::__t &st,ivy::ptr< cpp::expr::__t > &inp)
{
    if (ivy::is_dead (inp,st,pos::__t (1)))
    {
        inp =
            cpp::app::make1 (cpp::symbol::makestr (ivy::from_str< str::__t > ("std::move"),inp ->
                        get_ann()),inp,inp -> get_ann());
    }
}
void ivy::call_to_cpp  (const ivy::ptr< ivy::expr::__t > &func,const vector__ivy__expr::__t &inputs,const
    ivy::ptr< annot::__t > &ann,ivy::tocppst::__t &st,ivy::ptr< cpp::expr::__t > &res)
{
    ivy::prototype::__t proto;
    proto = st . protos . value (func -> get_arg (vector__ivy__expr::domain::__t (0)) -> get_name());
    
    // First evaluate all of the inputs.
    
    vector__cpp__expr::__t inpvals;
    vector__ivy__prototype_argument::domain::__t idx;
    idx = proto . args . begin();
    while (idx < proto . args . end)
    {
        ivy::ptr< cpp::expr::__t > inp;
        ivy::prototype_argument::__t parg;
        parg = proto . args . value (idx);
        if (parg . is_input)
        {
            vector__ivy__expr::__t save_outputs;
            save_outputs = st . outputs;
            st . outputs = vector__ivy__expr::empty();
            inputs . value (parg . inpos) -> to_cpp (st,inp);
            st . outputs = save_outputs;
        }
        inpvals . append (inp);
        idx = idx . next();
    }
    
    // Evaluate all of the arguments
    
    vector__cpp__expr::__t args;
    idx = proto . args . begin();
    vector__cpp__stmt::__t rets;
    vector__cpp__expr::__t ret_vals;
    vector__cpp__expr::domain::__t kdx;
    kdx = inpvals . begin();
    while (idx < proto . args . end)
    {
        ivy::prototype_argument::__t parg;
        parg = proto . args . value (idx);
        ivy::ptr< cpp::expr::__t > inp;
        inp = inpvals . value (kdx);
        ivy::ptr< cpp::expr::__t > out;
        if (parg . is_output & st . outputs . end > vector__ivy__expr::domain::__t (0))
        {
            st . outputs . value (parg . outpos) -> to_cpp (st,out);
            if (! ivy::is_dead (out,st,parg . is_input ? pos::__t (1) : pos::__t (0)))
            {
                ivy::ptr< cpp::expr::__t > orig;
                orig = out;
                ivy::make_temp (st,parg . name -> get_arg (vector__ivy__expr::domain::__t (1)),ann,out);
                rets . append (cpp::asgn::make (orig,out,ann));
            }
        } else
        {
            if (parg . is_ref & ! parg . is_const)
            {
                if (ivy::is_dead (inp,st,pos::__t (1))) {
                    out = inp;
                } else
                {
                    ivy::make_temp (st,parg . name -> get_arg (vector__ivy__expr::domain::__t (1)),ann,out);
                }
                if (parg . is_output) {
                    ret_vals . append (out);
                }
            } else {
                if (parg . is_input & ! parg . is_ref) {
                    ivy::make_rvalue_if_dead (st,inp);
                }
            }
        }
        if (parg . is_input & parg . is_ref & ! parg . is_const & ! inp -> eq (out))
        {
            st . add_stmt (cpp::asgn::make (out,inp,ann));
            inp = out;
        } else {
            if (parg . is_output) {
                inp = out;
            }
        }
        args . append (inp);
        idx = idx . next();
        kdx = kdx . next();
    }
    ivy::ptr< annot::__t > cann;
    cann = st . outputs . end > vector__ivy__expr::domain::__t (0) ? st . asgn_ann : ann;
    ivy::make_cpp_call (func,args,cann,st,proto,res);
    ivy::unown_func_args (inputs,st);
    if (ret_vals . end > vector__cpp__expr::domain::__t (0) | rets . end >
    vector__cpp__stmt::domain::__t (0) | ! proto . has_ret)
    {
        st . add_stmt (cpp::asgn::make (cpp::empty::make (ann),res,ann));
        vector__cpp__stmt::domain::__t jdx;
        jdx = rets . begin();
        while (jdx < rets . end) {
            st . add_stmt (rets . value (jdx));
            jdx = jdx . next();
        }
        res = cpp::comma::fold_left (ret_vals,ann);
    }
}
void ivy::make_cast_to_bool  (ivy::ptr< cpp::expr::__t > &s)
{
    s =
        cpp::app::make1 (cpp::symbol::makestr (ivy::from_str< str::__t > ("ivy::native_bool"),s ->
                    get_ann()),s,s -> get_ann());
}
void ivy::make_isa  (ivy::ptr< cpp::expr::__t > &s,const ivy::ptr< cpp::expr::__t > &ty)
{
    s =
        cpp::app::make1 (cpp::symbol::makestr1 (ivy::from_str< str::__t > ("ivy::isa"),ty ->
                    get_name(),s -> get_ann()),s,s -> get_ann());
}
void ivy::app::__t::to_cpp  (ivy::tocppst::__t &st,ivy::ptr< cpp::expr::__t > &res) const
{
    if ((*this) . is (ivy::verb::__t (ivy::verb::colon))) 
    // Generally, type decorations are not emitted to
    // C++. However, in case of a numeral, we need to cast
    // the numeral to the appropriate type. If a string
    // literal, we use the template function
    // `ivy::from_str<t>` to convert to type `t`.
    //
    // If a symbol is an action and its type is not a
    // function type, we have to add () for C++.
    
    {
        ivy::ptr< ivy::expr::__t > arg;
        arg = (*this) . args . value (vector__ivy__expr::domain::__t (0));
        arg -> to_cpp (st,res);
        if (arg . isa< ivy::symbol::__t >())
        {
            if (arg -> get_verb() == ivy::verb::__t (ivy::verb::truev) | arg -> get_verb() ==
            ivy::verb::__t (ivy::verb::falsev))
            {
                res =
                    cpp::app::make1 (cpp::symbol::makestr (ivy::from_str< str::__t > ("ivy::native_bool"),(*this)
                                . get_ann()),res,(*this) . get_ann());
            } else
            {
                if (arg -> get_verb() == ivy::verb::__t (ivy::verb::numeral) |
                st . constructors . mem (arg -> get_name()))
                {
                    ivy::ptr< cpp::expr::__t > ty;
                    (*this) . args . value (vector__ivy__expr::domain::__t (1)) -> to_cpp (st,ty);
                    res = cpp::app::make1 (ty,res,(*this) . get_ann());
                } else
                {
                    if (arg -> get_verb() == ivy::verb::__t (ivy::verb::string))
                    {
                        ivy::ptr< cpp::expr::__t > ty;
                        (*this) . args . value (vector__ivy__expr::domain::__t (1)) -> to_cpp (st,ty);
                        res = ivy::make_from_string (ty,res,(*this) . get_ann());
                    } else
                    {
                        if (arg -> get_verb() == ivy::verb::__t (ivy::verb::fltnum))
                        {
                            ivy::ptr< cpp::expr::__t > ty;
                            (*this) . args . value (vector__ivy__expr::domain::__t (1)) -> to_cpp (st,ty);
                            res = ivy::make_from_float (ty,res,(*this) . get_ann());
                        } else
                        {
                            if (st . globals . is_action . mem (arg -> get_name()))
                            {
                                if (!
                                (*this) . args . value (vector__ivy__expr::domain::__t (1)) -> is (ivy::verb::__t
                                        (ivy::verb::arrow)))
                                {
                                    vector__cpp__expr::__t args;
                                    res = cpp::app::make (res,args,res -> get_ann());
                                }
                            }
                        }
                    }
                }
            }
        }
    } else
    {
        if ((*this) . is (ivy::verb::__t (ivy::verb::arrow))) 
        // Function types need special translation to C++
        
        {
            ivy::ptr< ivy::expr::__t > tmp;
            tmp = (*this);
            ivy::function_type (tmp,st,res);
        } else
        {
            if ((*this) . is (ivy::verb::__t (ivy::verb::isav)))
            {
                
                // `x isa t` is translated to `x.isa<t>()`
                
                ivy::ptr< cpp::expr::__t > arg0;
                ivy::ptr< cpp::expr::__t > arg1;
                (*this) . args . value (vector__ivy__expr::domain::__t (0)) -> to_cpp (st,arg0);
                (*this) . args . value (vector__ivy__expr::domain::__t (1)) -> to_cpp (st,arg1);
                if (ivy::is_cpp_this (arg0)) {
                    res = arg0;
                    ivy::make_isa (res,arg1);
                } else
                {
                    cpp::strident::__t isam;
                    isam . val = ivy::from_str< str::__t > ("isa");
                    isam . subscrs . append (arg1 -> get_name());
                    ivy::ptr< cpp::ident::__t > id;
                    id = isam;
                    res = cpp::symbol::make (id,(*this) . ann);
                    res = cpp::dot::make (arg0,res,(*this) . ann);
                    res = cpp::app::make0 (res,(*this) . ann);
                }
            } else
            {
                if ((*this) . func -> is (ivy::verb::__t (ivy::verb::colon)) &
                (*this) . func -> get_arg (vector__ivy__expr::domain::__t (0)) -> get_verb() ==
                ivy::verb::__t (ivy::verb::castv)) 
                // A cast operator looks like (cast : (t->u))(x). This may indicate
                // a need for an upcast in C++. 
                
                {
                    ivy::ptr< ivy::expr::__t > ty;
                    ty =
                        (*this) . func -> get_arg (vector__ivy__expr::domain::__t (1)) -> get_arg (vector__ivy__expr::domain::__t
                                (1));
                    ivy::upcast (ty,(*this) . args . value (vector__ivy__expr::domain::__t (0)),st,res);
                } else
                {
                    
                    // Detect whether a function application is an action call.
                    
                    ivy::ptr< ivy::expr::__t > func;
                    vector__ivy__expr::__t args;
                    ivy::get_app ((*this),func,args);
                    if (st . globals . is_action . mem (func -> get_arg (vector__ivy__expr::domain::__t
                                    (0)) -> get_name()))
                    {
                        ivy::call_to_cpp (func,args,(*this) . ann,st,res);
                    } else
                    {
                        
                        // This is the normal case of function application. We
                        // translate the function and all the arguments and
                        // then apply.
                        
                        cpp::app::__t capp;
                        (*this) . func -> to_cpp (st,capp . func);
                        {
                            vector__ivy__expr::__t save_outputs;
                            save_outputs = st . outputs;
                            st . outputs = vector__ivy__expr::empty();
                            vector__ivy__expr::domain::__t idx;
                            idx = (*this) . args . begin();
                            while (idx < (*this) . args . end)
                            {
                                ivy::ptr< cpp::expr::__t > arg;
                                if ((*this) . func -> get_verb() == ivy::verb::__t (ivy::verb::dot)
                                & idx == vector__ivy__expr::domain::__t (1))
                                {
                                    st . dot_rhs = ivy::native_bool (true);
                                }
                                (*this) . args . value (idx) -> to_cpp (st,arg);
                                st . dot_rhs = ivy::native_bool (false);
                                capp . args . append (arg);
                                idx = idx . next();
                            }
                            st . outputs = save_outputs;
                            
                            // For ternary operators, we need to permute the arguments
                            
                            if (capp . is (cpp::verb::__t (cpp::verb::ite)))
                            {
                                ivy::ptr< cpp::expr::__t > tmp;
                                tmp = capp . args . value (vector__cpp__expr::domain::__t (0));
                                capp . args . set (vector__cpp__expr::domain::__t (0),capp . args .
                                            value (vector__cpp__expr::domain::__t (1)));
                                capp . args . set (vector__cpp__expr::domain::__t (1),tmp);
                            }
                            
                            // For inbounds array accesses, we use the
                            // member function __inp rather than
                            // operator(). This does an ordinary unchecked
                            // vector access.
                            
                            if (st . inbounds_nesting > pos::__t (0))
                            {
                                __bool is_data;
                                is_data = (*this) . func -> is (ivy::verb::__t (ivy::verb::dot));
                                if ((*this) . func -> is (ivy::verb::__t (ivy::verb::colon)))
                                {
                                    ivy::ptr< ivy::expr::__t > arg;
                                    arg =
                                        (*this) . func -> get_arg (vector__ivy__expr::domain::__t (0));
                                    is_data = arg . isa< ivy::symbol::__t >() & arg -> get_verb() ==
                                        ivy::verb::__t (ivy::verb::none);
                                }
                                if (is_data)
                                {
                                    ivy::ptr< cpp::expr::__t > inb;
                                    inb =
                                        cpp::symbol::makestr (ivy::from_str< str::__t > ("__inb"),capp
                                                . func -> get_ann());
                                    capp . func = cpp::dot::make (capp . func,inb,(*this) . ann);
                                }
                            }
                            
                            // If of the form (x:t).f, where t is a variant
                            // type, convert to x->f, since variant types are
                            // represented with smart pointers.
                            
                            if ((*this) . func -> get_verb() == ivy::verb::__t (ivy::verb::dot))
                            {
                                ivy::ptr< ivy::expr::__t > lhs;
                                lhs = (*this) . args . value (vector__ivy__expr::domain::__t (0));
                                if (lhs -> is (ivy::verb::__t (ivy::verb::colon)))
                                {
                                    ivy::ptr< ivy::expr::__t > ty;
                                    ty = lhs -> get_arg (vector__ivy__expr::domain::__t (1));
                                    if (ivy::is_variant_type (ty,st) & !
                                    ivy::is_cpp_this (capp . args . value (vector__cpp__expr::domain::__t
                                                (0))))
                                    {
                                        capp . func =
                                            cpp::symbol::makestr (ivy::from_str< str::__t > ("->"),capp
                                                    . func -> get_ann());
                                    }
                                }
                            }
                        }
                        capp . ann = (*this) . ann;
                        res = capp;
                        ivy::unown_func_args ((*this) . args,st);
                    }
                }
            }
        }
    }
}
void ivy::stmt::__t::to_cpp  (ivy::tocppst::__t &st,ivy::ptr< cpp::stmt::__t > &res) const {}
void ivy::skipst::__t::to_cpp  (ivy::tocppst::__t &st,ivy::ptr< cpp::stmt::__t > &res) const
{
    cpp::skipst::__t t;
    t . ann = (*this) . ann;
    res = t;
}
void cpp::stmt::__t::fix_borrow  (ivy::tocppst::__t &st,ivy::ptr< cpp::stmt::__t > &res) const
{
    res = (*this) . __upcast();
}
void cpp::stmt::__t::setup_fix_borrow  (ivy::tocppst::__t &st,__bool &ok) const
{
    ok = ivy::native_bool (false);
}
void ivy::upcast  (const ivy::ptr< ivy::expr::__t > &lhsty,const ivy::ptr< ivy::expr::__t > &rhs,ivy::tocppst::__t
    &st,ivy::ptr< cpp::expr::__t > &res)
{
    rhs -> to_cpp (st,res);
    if (ivy::native_bool (false) & rhs -> is (ivy::verb::__t (ivy::verb::colon)))
    {
        ivy::ptr< ivy::expr::__t > rhsty;
        rhsty = rhs -> get_arg (vector__ivy__expr::domain::__t (1));
        if (st . subtype_rel . is_subtype (rhsty,lhsty))
        {
            ivy::ptr< cpp::expr::__t > crhsty;
            rhsty -> to_cpp (st,crhsty);
            res = cpp::__new::make (cpp::app::make1 (crhsty,res,rhs -> get_ann()),rhs -> get_ann());
            ivy::ptr< cpp::expr::__t > clhsty;
            ivy::fix_variant_type (lhsty,st,clhsty);
            res = cpp::app::make1 (clhsty,res,rhs -> get_ann());
        }
    }
}
void ivy::unown_path  (const ivy::access_path::__t &path,ivy::tocppst::__t &st)
{
    vector__ivy__lvalue_count::domain::__t idx;
    idx = st . dead . begin();
    while (idx < st . dead . end)
    {
        ivy::lvalue_count lc;
        lc = st . dead . value (idx);
        if (ivy::path_may_alias (path,lc . path))
        {
            lc . cnt = lc . cnt . prev();
            st . dead . set (idx,lc);
        }
        idx = idx . next();
    }
}
void ivy::kill_lvalue  (const ivy::ptr< ivy::expr::__t > &e,ivy::tocppst::__t &st,const
    vector__ivy__access_path::__t &paths)
{
    ivy::access_path::__t path;
    __bool ok;
    ivy::lvalue_path (e,path,ok);
    if (ok)
    {
        pos::__t alias_count;
        alias_count = pos::__t (0);
        vector__ivy__access_path::domain::__t idx;
        idx = paths . begin();
        while (idx < paths . end)
        {
            if (ivy::path_may_alias (path,paths . value (idx))) {
                alias_count = alias_count . next();
            }
            idx = idx . next();
        }
        ivy::lvalue_count lc;
        e -> to_cpp (st,lc . lvalue);
        lc . path = path;
        lc . cnt = alias_count;
        st . dead . append (lc);
    }
}
void ivy::kill_lvalues  (const vector__ivy__expr::__t &es,ivy::tocppst::__t &st,const
    vector__ivy__access_path::__t &paths)
{
    vector__ivy__expr::domain::__t idx;
    idx = es . begin();
    while (idx < es . end) {
        ivy::kill_lvalue (es . value (idx),st,paths);
        idx = idx . next();
    }
    ivy::vector< __bool,ivy::ptr< ivy::ident::__t > > seen;
    vector__ivy__access_path::domain::__t jdx;
    jdx = paths . begin();
    while (jdx < paths . end)
    {
        ivy::ptr< ivy::ident::__t > id;
        id = paths . value (jdx) . elems . value (vector__ivy__ident::domain::__t (0));
        if (st . locals . mem (id) & ! seen (id))
        {
            seen (id) = ivy::native_bool (true);
            ivy::ptr< annot::__t > ann;
            ivy::local_info::__t li;
            li = st . locals . value (id);
            if (! li . is_live & ! li . is_ref & li . loop_nesting >= st . loop_nesting)
            {
                ivy::kill_lvalue (ivy::symbol::make (id,ann),st,paths);
            }
        }
        jdx = jdx . next();
    }
}
void ivy::fix_variant_arg  (const ivy::ptr< ivy::expr::__t > &s,ivy::ptr< cpp::expr::__t > &rhs,const
    ivy::tocppst::__t &st)
{
    if (! s -> is_typed (ivy::verb::__t (ivy::verb::castv)) & ivy::is_cpp_this (rhs))
    {
        ivy::ptr< ivy::expr::__t > ty;
        ty = s -> get_type();
        if (ivy::is_variant_type (ty,st))
        {
            ivy::ptr< annot::__t > ann;
            ann = rhs -> get_ann();
            rhs =
                cpp::dot::make (rhs,cpp::app::make0 (cpp::symbol::makestr (ivy::from_str< str::__t >
                                ("__upcast"),ann),ann),ann);
        }
    }
}
void ivy::update_live  (const vector__ivy__access_path::__t &paths,ivy::tocppst::__t &st)
{
    vector__ivy__access_path::domain::__t idx;
    idx = paths . begin();
    while (idx < paths . end)
    {
        ivy::ptr< ivy::ident::__t > id;
        id = paths . value (idx) . elems . value (vector__ivy__ident::domain::__t (0));
        if (st . locals . mem (id))
        {
            ivy::local_info::__t li;
            li = st . locals . value (id);
            li . is_live = ivy::native_bool (true);
            st . locals . set (id,li);
        }
        idx = idx . next();
    }
}
void ivy::asgn::__t::to_cpp  (ivy::tocppst::__t &st,ivy::ptr< cpp::stmt::__t > &resd) const
{
    vector__ivy__access_path::__t paths;
    ivy::lvalue_paths ((*this) . rhs,paths,ivy::native_bool (false),ivy::native_bool (false));
    cpp::asgn::__t res;
    res . ann = (*this) . ann;
    (*this) . lhs -> to_cpp (st,res . lhs);
    st . outputs = ivy::comma::unfold_left ((*this) . lhs);
    st . asgn_ann = (*this) . ann;
    ivy::kill_lvalues (st . outputs,st,paths);
    (*this) . rhs -> to_cpp (st,res . rhs);
    if (res . rhs -> get_verb() != cpp::verb::__t (cpp::verb::empty))
    {
        ivy::make_rvalue_if_dead (st,res . rhs);
        st . add_stmt (res);
    }
    st . get_code ((*this) . ann,resd);
    st . outputs = vector__ivy__expr::empty();
    st . dead = vector__ivy__lvalue_count::empty();
    ivy::lvalue_paths ((*this) . lhs,paths,ivy::native_bool (true),ivy::native_bool (false));
    ivy::update_live (paths,st);
    if (st . num_borrowings > pos::__t (0))
    {
        vector__ivy__access_path::__t apaths;
        ivy::lvalue_paths ((*this) . lhs,apaths,ivy::native_bool (false),ivy::native_bool (true));
        ivy::update_borrowings (apaths,ivy::native_bool (true),st);
        ivy::check_borrowing_return ((*this),st);
        ivy::update_borrowings (paths,ivy::native_bool (false),st);
    }
}
void ivy::strip_move  (ivy::ptr< cpp::expr::__t > &s)
{
    if (s . isa< cpp::app::__t >())
    {
        if (s -> get_func() -> get_name() -> to_str() == ivy::from_str< str::__t > ("std::move"))
        {
            s = s -> get_arg (vector__cpp__expr::domain::__t (0));
        }
    }
}
void cpp::asgn::__t::fix_borrow  (ivy::tocppst::__t &st,ivy::ptr< cpp::stmt::__t > &res) const
{
    res = (*this);
    ivy::ptr< cpp::expr::__t > rhs;
    {
        rhs = (*this) . rhs;
        ivy::strip_move (rhs);
    }
    if (rhs . isa< cpp::symbol::__t >())
    {
        ivy::ptr< cpp::ident::__t > id;
        id = rhs -> get_name();
        if (st . fix_borrow_map . mem (id))
        {
            ivy::ptr< cpp::expr::__t > lvalue;
            lvalue = st . fix_borrow_map . value (id);
            if (lvalue -> eq ((*this) . lhs)) {
                res = cpp::skipst::make ((*this) . ann);
            }
        }
    }
}
void ivy::setup_borrowing  (const ivy::ptr< ivy::stmt::__t > &s,ivy::tocppst::__t &st,__bool &ok,ivy::ptr< ivy::ident::__t >
    &id)
{
    if (s . isa< ivy::asgn::__t >())
    {
        ivy::ptr< ivy::expr::__t > x;
        x = s -> get_lhs();
        if (x -> is (ivy::verb::__t (ivy::verb::colon)))
        {
            x = x -> get_arg (vector__ivy__expr::domain::__t (0));
        }
        if (x . isa< ivy::symbol::__t >())
        {
            id = x -> get_name();
            if (st . locals . mem (id) & ! st . borrowings . mem (id))
            {
                ivy::ptr< ivy::expr::__t > y;
                y = s -> get_rhs();
                ivy::access_path::__t path;
                __bool is_lvalue;
                ivy::lvalue_path (y,path,is_lvalue);
                ivy::local_info::__t li;
                li = st . locals . value (id);
                if (is_lvalue & ! li . is_live & ! li . is_ref & li . loop_nesting >= st .
                loop_nesting)
                {
                    if (path . elems . value (vector__ivy__ident::domain::__t (0)) !=
                    x -> get_name() & ivy::is_functional (y,st . globals))
                    {
                        st . borrowings . push();
                        st . num_borrowings = st . num_borrowings . next();
                        ivy::borrowing::__t br;
                        br . lvalue = y;
                        vector__ivy__access_path::__t paths;
                        ivy::lvalue_paths (y,paths,ivy::native_bool (false),ivy::native_bool (false));
                        br . num_paths = paths . end;
                        br . cond_nesting = st . cond_nesting;
                        st . borrowings . set (id,br);
                        vector__ivy__access_path::domain::__t idx;
                        idx = paths . begin();
                        while (idx < paths . end)
                        {
                            st . conflicts . add (paths . value (idx),id);
                            idx = idx . next();
                        }
                        ok = ivy::native_bool (true);
                    }
                }
            }
        }
    }
}
void ivy::unsetup_borrowing  (const ivy::ptr< ivy::ident::__t > &id,ivy::tocppst::__t &st)
{
    ivy::borrowing::__t br;
    br = st . borrowings . value (id);
    vector__ivy__access_path::domain::__t idx;
    idx = vector__ivy__access_path::domain::__t (0);
    while (idx < br . num_paths) {
        st . conflicts . undo();
        idx = idx . next();
    }
    st . borrowings . pop();
    st . num_borrowings = st . num_borrowings . prev();
}
void ivy::update_borrowings  (const vector__ivy__access_path::__t &paths,const __bool &is_mod,ivy::tocppst::__t
    &st)
{
    vector__ivy__access_path::domain::__t idx;
    idx = paths . begin();
    while (idx < paths . end)
    {
        ivy::access_path::__t path;
        path = paths . value (idx);
        vector__ivy__ident::__t ids;
        ids = st . conflicts . collect (path);
        vector__ivy__ident::domain::__t jdx;
        jdx = ids . begin();
        while (jdx < ids . end)
        {
            ivy::ptr< ivy::ident::__t > id;
            id = ids . value (jdx);
            if (st . borrowings . mem (id))
            {
                ivy::borrowing::__t br;
                br = st . borrowings . value (id);
                ivy::access_path::__t lpath;
                __bool ok;
                ivy::lvalue_path (br . lvalue,lpath,ok);
                if (ivy::path_may_alias (path,lpath))
                {
                    if (br . returned) {
                        br . cancel_non_const = ivy::native_bool (true);
                    }
                }
                if (is_mod & br . saw_ref)
                {
                    br . cancel_non_const = ivy::native_bool (true);
                    br . cancel_const = ivy::native_bool (true);
                }
                st . borrowings . map . set (id,br);
            }
            jdx = jdx . next();
        }
        ivy::ptr< ivy::ident::__t > root;
        root = path . elems . value (vector__ivy__ident::domain::__t (0));
        if (st . borrowings . mem (root))
        {
            ivy::borrowing::__t br;
            br = st . borrowings . value (root);
            if (is_mod)
            {
                br . cancel_const = ivy::native_bool (true);
                if (! br . returned) {
                    br . cancel_non_const = ivy::native_bool (true);
                }
            }
            br . saw_ref = ivy::native_bool (true);
            st . borrowings . map . set (root,br);
        }
        idx = idx . next();
    }
}
void ivy::check_borrowing_return  (const ivy::asgn::__t &s,ivy::tocppst::__t &st)
{
    if (s . rhs -> is (ivy::verb::__t (ivy::verb::colon)))
    {
        ivy::ptr< ivy::expr::__t > rhs;
        rhs = s . rhs -> get_arg (vector__ivy__expr::domain::__t (0));
        if (rhs . isa< ivy::symbol::__t >())
        {
            ivy::ptr< ivy::ident::__t > id;
            id = rhs -> get_name();
            if (st . borrowings . mem (id))
            {
                ivy::borrowing::__t br;
                br = st . borrowings . value (id);
                if (br . lvalue -> eq (s . lhs) & st . cond_nesting == br . cond_nesting)
                {
                    br . returned = ivy::native_bool (true);
                }
                st . borrowings . map . set (id,br);
            }
        }
    }
}
void ivy::make_local_ref  (const ivy::ptr< ivy::expr::__t > &typing,const ivy::ptr< cpp::stmt::__t >
    &lhs,const __bool &is_const,ivy::tocppst::__t &st,ivy::ptr< cpp::stmt::__t > &res)
{
    cpp::varst::__t vst;
    ivy::fix_variant_type (typing -> get_arg (vector__ivy__expr::domain::__t (1)),st,vst . vtype .
            _type);
    vst . vtype . name = lhs -> get_lhs();
    vst . ann = lhs -> get_ann();
    vst . has_initval = ivy::native_bool (true);
    {
        vst . initval = lhs -> get_rhs();
        ivy::strip_move (vst . initval);
    }
    vst . vtype . is_const = is_const;
    vst . vtype . is_borrow = ivy::native_bool (true);
    vst . vtype . is_ref = ivy::native_bool (true);
    res = vst;
}
void ivy::pragma_stmt  (const ivy::ptr< ivy::stmt::__t > &s,const __bool &start,ivy::tocppst::__t &st)
{
    if (s . isa< ivy::pragmast::__t >())
    {
        __bool ok;
        ok = ivy::native_bool (false);
        ivy::ptr< ivy::expr::__t > e;
        e = s -> get_expr();
        if (e . isa< ivy::symbol::__t >())
        {
            str::__t name;
            name = e -> get_name() -> to_str();
            if (name == ivy::from_str< str::__t > ("inbounds"))
            {
                ok = ivy::native_bool (true);
                if (start) {
                    st . inbounds_nesting = st . inbounds_nesting . next();
                } else {
                    st . inbounds_nesting = st . inbounds_nesting . prev();
                }
            }
        }
        if (! ok) {
            ivy::report_error (ivy::bad_syntax::make (e),e -> get_ann());
        }
    }
}
void ivy::sequence::__t::to_cpp  (ivy::tocppst::__t &st,ivy::ptr< cpp::stmt::__t > &resd) const
{
    cpp::sequence::__t res;
    res . ann = (*this) . ann;
    st . locals . push_stmt ((*this) . lhs,st . loop_nesting);
    __bool ok;
    ivy::ptr< ivy::ident::__t > bid;
    ivy::setup_borrowing ((*this) . lhs,st,ok,bid);
    ivy::pragma_stmt ((*this) . lhs,ivy::native_bool (true),st);
    (*this) . rhs -> to_cpp (st,res . rhs);
    ivy::pragma_stmt ((*this) . lhs,ivy::native_bool (false),st);
    ivy::borrowing::__t br;
    if (ok) {
        br = st . borrowings . value (bid);
        ivy::unsetup_borrowing (bid,st);
    }
    (*this) . lhs -> to_cpp (st,res . lhs);
    st . locals . pop();
    if (ok)
    {
        if (! br . cancel_const | ! br . cancel_non_const)
        {
            ivy::make_local_ref ((*this) . lhs -> get_lhs(),res . lhs,! br . cancel_const,st,res .
                    lhs);
            resd = cpp::sequence::make (res,cpp::skipst::make ((*this) . ann),(*this) . ann);
        } else {
            resd = res;
        }
    } else {
        resd = res;
    }
}
void cpp::sequence::__t::fix_borrow  (ivy::tocppst::__t &st,ivy::ptr< cpp::stmt::__t > &resd) const
{
    cpp::sequence::__t res;
    res . ann = (*this) . ann;
    (*this) . lhs -> fix_borrow (st,res . lhs);
    __bool ok;
    (*this) . lhs -> setup_fix_borrow (st,ok);
    (*this) . rhs -> fix_borrow (st,res . rhs);
    if (ok) {
        st . fix_borrow_map . pop();
    }
    resd = res;
}
void ivy::ifst::__t::to_cpp  (ivy::tocppst::__t &st,ivy::ptr< cpp::stmt::__t > &resd) const
{
    cpp::ifst::__t res;
    res . ann = (*this) . ann;
    vector__ivy__access_path::__t paths;
    ivy::lvalue_paths ((*this) . cond,paths,ivy::native_bool (false),ivy::native_bool (false));
    if (st . num_borrowings > pos::__t (0))
    {
        ivy::update_borrowings (paths,ivy::native_bool (false),st);
    }
    (*this) . cond -> to_cpp (st,res . cond);
    vector__cpp__stmt::__t code;
    code = st . code;
    
    // side effects of cond evaluation
    
    st . code = vector__cpp__stmt::empty();
    st . cond_nesting = st . cond_nesting . next();
    (*this) . thenst -> to_cpp (st,res . thenst);
    (*this) . elsest -> to_cpp (st,res . elsest);
    st . cond_nesting = st . cond_nesting . prev();
    resd = res;
    st . code = code;
    {
        ivy::ptr< cpp::stmt::__t > __tmp22;
        st . wrap_stmt (resd,(*this) . ann,__tmp22);
        resd = __tmp22;
    }
    ivy::update_live (paths,st);
}
void cpp::ifst::__t::fix_borrow  (ivy::tocppst::__t &st,ivy::ptr< cpp::stmt::__t > &resd) const
{
    cpp::ifst::__t res;
    res . ann = (*this) . ann;
    res . cond = (*this) . cond;
    (*this) . thenst -> fix_borrow (st,res . thenst);
    (*this) . elsest -> fix_borrow (st,res . elsest);
    resd = res;
}
void ivy::whilest::__t::to_cpp  (ivy::tocppst::__t &st,ivy::ptr< cpp::stmt::__t > &resd) const
{
    cpp::whilest::__t res;
    res . ann = (*this) . ann;
    vector__ivy__access_path::__t paths;
    ivy::lvalue_paths ((*this) . cond,paths,ivy::native_bool (false),ivy::native_bool (false));
    if (st . num_borrowings > pos::__t (0))
    {
        ivy::update_borrowings (paths,ivy::native_bool (false),st);
    }
    (*this) . cond -> to_cpp (st,res . cond);
    vector__cpp__stmt::__t code;
    code = st . code;
    
    // side effects of cond evaluation
    
    st . code = vector__cpp__stmt::empty();
    st . cond_nesting = st . cond_nesting . next();
    st . loop_nesting = st . loop_nesting . next();
    (*this) . body -> to_cpp (st,res . body);
    st . cond_nesting = st . cond_nesting . prev();
    st . loop_nesting = st . loop_nesting . prev();
    if (code . end > vector__cpp__stmt::domain::__t (0))
    {
        st . code = code;
        ivy::ptr< cpp::expr::__t > brkcond;
        brkcond = cpp::__not::make (res . cond,(*this) . ann);
        ivy::ptr< cpp::stmt::__t > brkif;
        brkif = cpp::breakst::make ((*this) . ann);
        ivy::ptr< cpp::stmt::__t > brkelse;
        brkelse = cpp::skipst::make ((*this) . ann);
        ivy::ptr< cpp::stmt::__t > brkst;
        brkst = cpp::ifst::make (brkcond,brkif,brkelse,(*this) . ann);
        st . add_stmt (brkst);
        res . cond = cpp::symbol::makestr (ivy::from_str< str::__t > ("true"),(*this) . ann);
        st . wrap_stmt (res . body,(*this) . ann,res . body);
    }
    resd = res;
    {
        ivy::ptr< cpp::stmt::__t > __tmp23;
        st . wrap_stmt (resd,(*this) . ann,__tmp23);
        resd = __tmp23;
    }
    ivy::update_live (paths,st);
}
void cpp::whilest::__t::fix_borrow  (ivy::tocppst::__t &st,ivy::ptr< cpp::stmt::__t > &resd) const
{
    cpp::whilest::__t res;
    res . ann = (*this) . ann;
    res . cond = (*this) . cond;
    (*this) . body -> fix_borrow (st,res . body);
    resd = res;
}
void ivy::varst::__t::to_cpp  (ivy::tocppst::__t &st,ivy::ptr< cpp::stmt::__t > &resd) const
{
    cpp::varst::__t res;
    res . ann = (*this) . ann;
    ivy::fix_variant_type ((*this) . name -> get_arg (vector__ivy__expr::domain::__t (1)),st,res .
            vtype . _type);
    (*this) . name -> get_arg (vector__ivy__expr::domain::__t (0)) -> to_cpp (st,res . vtype . name);
    resd = res;
}
void cpp::varst::__t::setup_fix_borrow  (ivy::tocppst::__t &st,__bool &ok) const
{
    if ((*this) . vtype . is_borrow)
    {
        st . fix_borrow_map . push();
        st . fix_borrow_map . set ((*this) . vtype . name -> get_name(),(*this) . initval);
        ok = ivy::native_bool (true);
    }
}
void ivy::decl::__t::to_cpp  (ivy::tocppst::__t &st,ivy::ptr< cpp::decl::__t > &res) const {}
void ivy::decl::__t::reg_member  (ivy::tocppst::__t &st) const {}
__bool ivy::decl::__t::emitted  (const ivy::tocppst::__t &st) const
{
    __bool res;
    res = ivy::native_bool (true);
    return res;
}
void ivy::decl::__t::record_prototypes  (ivy::tocppst::__t &st) const {}
void ivy::full_action_name  (const ivy::ptr< ivy::expr::__t > &name,const __bool &is_member,ivy::tocppst::__t
    &st,ivy::ptr< cpp::expr::__t > &res)
{
    if (is_member)
    {
        ivy::ptr< ivy::ident::__t > pref;
        pref = name -> get_name() -> get_namesp();
        ivy::ptr< ivy::ident::__t > clsid;
        {
            clsid = pref;
            ivy::fix_object_clash (clsid,st);
        }
        ivy::ptr< ivy::ident::__t > funid;
        funid = name -> get_name() -> get_member() -> prefix (clsid);
        res = cpp::symbol::make (funid -> to_cpp (ivy::native_bool (false)),name -> get_ann());
    } else {
        name -> to_cpp (st,res);
    }
}
__bool ivy::is_input_param  (const ivy::actdc::__t &s,const ivy::ptr< ivy::expr::__t > &p)
{
    __bool res;
    {
        vector__ivy__expr::domain::__t idx;
        idx = s . inputs . begin();
        while (! res & idx < s . inputs . end)
        {
            res = s . inputs . value (idx) -> eq (p);
            idx = idx . next();
        }
    }
    return res;
}
void ivy::make_initializer  (const ivy::ptr< ivy::expr::__t > &typing,const ivy::ptr< cpp::expr::__t >
    &initval,ivy::tocppst::__t &st,ivy::ptr< cpp::stmt::__t > &res)
{
    cpp::varst::__t vd;
    typing -> get_arg (vector__ivy__expr::domain::__t (0)) -> to_cpp (st,vd . vtype . name);
    typing -> get_arg (vector__ivy__expr::domain::__t (1)) -> to_cpp (st,vd . vtype . _type);
    vd . has_initval = ivy::native_bool (true);
    vd . initval = initval;
    vd . ann = typing -> get_ann();
    res = vd;
}
void ivy::actdc::__t::record_prototypes  (ivy::tocppst::__t &st) const
{
    ivy::prototype::__t proto;
    proto = (*this) . get_proto (st . globals,st . subtype_rel);
    st . protos . set ((*this) . name -> get_name(),proto);
}
void ivy::actdc::__t::to_cpp  (ivy::tocppst::__t &st,ivy::ptr< cpp::decl::__t > &resd) const
{
    cpp::funcdecl::__t res;
    res . ann = (*this) . ann;
    ivy::prototype::__t proto;
    proto = st . protos . value ((*this) . name -> get_name());
    __bool has_output;
    has_output = proto . has_ret;
    if (has_output)
    {
        ivy::fix_variant_type ((*this) . outputs . value (proto . ret . outpos) -> get_arg (vector__ivy__expr::domain::__t
                        (1)),st,res . ftype . base . _type);
    } else {
        res . ftype . base . _type = cpp::voidtype ((*this) . ann);
    }
    __bool cprot;
    cprot = st . proto_only;
    __bool is_member;
    is_member = (*this) . is_member();
    ivy::ptr< cpp::expr::__t > full_name;
    ivy::full_action_name ((*this) . name,is_member,st,full_name);
    {
        ivy::ptr< cpp::expr::__t > __tmp24;
        __tmp24 = full_name;
        ivy::member_name (__tmp24);
        res . ftype . base . name = cprot | st . in_class ? __tmp24 : full_name;
    }
    vector__ivy__prototype_argument::domain::__t idx;
    idx = proto . args . begin();
    st . is_member = is_member;
    vector__cpp__stmt::__t argasgns;
    if (st . is_member)
    {
        idx = idx . next();
        
        // skip the first input "this" if a member
        
        ivy::prototype_argument::__t parg;
        parg = proto . args . value (vector__ivy__prototype_argument::domain::__t (0));
        if (! cprot & parg . is_copy)
        {
            ivy::ptr< cpp::stmt::__t > vd;
            ivy::make_initializer (parg . name,cpp::symbol::makestr (ivy::from_str< str::__t > ("(*this)"),(*this)
                        . ann),st,vd);
            argasgns . append (vd);
        } else
        {
            st . this_ident =
                parg . name -> get_arg (vector__ivy__expr::domain::__t (0)) -> get_name();
        }
        res . ftype . is_const =
            proto . args . value (vector__ivy__prototype_argument::domain::__t (0)) . is_const;
        if (cprot &
        ivy::is_variant_type (proto . args . value (vector__ivy__prototype_argument::domain::__t (0))
                . name -> get_arg (vector__ivy__expr::domain::__t (1)),st))
        {
            res . is_virtual = ivy::native_bool (true);
        }
    }
    st . locals . push();
    while (idx < proto . args . end)
    {
        ivy::prototype_argument::__t parg;
        parg = proto . args . value (idx);
        ivy::ptr< ivy::expr::__t > arg;
        arg = parg . name;
        cpp::simpletype::__t argt;
        argt . is_const = parg . is_const;
        argt . is_ref = parg . is_ref;
        ivy::fix_variant_type (arg -> get_arg (vector__ivy__expr::domain::__t (1)),st,argt . _type);
        st . locals . add_var (arg,parg . is_ref,pos::__t (0));
        arg -> get_arg (vector__ivy__expr::domain::__t (0)) -> to_cpp (st,argt . name);
        if (! cprot & parg . is_copy)
        {
            ivy::temp_sym (st,(*this) . ann,argt . name);
            ivy::ptr< cpp::stmt::__t > vd;
            ivy::make_initializer (parg . name,argt . name,st,vd);
            argasgns . append (vd);
        }
        res . ftype . args . append (argt);
        idx = idx . next();
    }
    res . has_body = ! cprot;
    if (res . has_body)
    {
        if ((*this) . has_body)
        {
            ivy::ptr< cpp::stmt::__t > body;
            (*this) . body -> to_cpp (st,body);
            {
                ivy::ptr< cpp::stmt::__t > __tmp25;
                body -> fix_borrow (st,__tmp25);
                body = __tmp25;
            }
            res . body = body;
        } else {
            res . body = cpp::skipst::make ((*this) . ann);
        }
        if (has_output)
        {
            ivy::ptr< cpp::expr::__t > rvar;
            (*this) . outputs . value (vector__ivy__expr::domain::__t (0)) -> get_arg (vector__ivy__expr::domain::__t
                            (0)) -> to_cpp (st,rvar);
            ivy::ptr< cpp::stmt::__t > ret;
            ret = cpp::retst::make (rvar,(*this) . ann);
            res . body = cpp::sequence::make (res . body,ret,(*this) . ann);
            if (!
            ivy::is_input_param ((*this),(*this) . outputs . value (vector__ivy__expr::domain::__t (0))))
            {
                ivy::ptr< cpp::stmt::__t > vs;
                vs = cpp::varst::make (res . ftype . base . _type,rvar,(*this) . ann);
                res . body = cpp::sequence::make (vs,res . body,(*this) . ann);
            }
        }
        vector__cpp__stmt::domain::__t kdx;
        kdx = argasgns . end;
        while (kdx > argasgns . begin())
        {
            kdx = kdx . prev();
            res . body = cpp::sequence::make (argasgns . value (kdx),res . body,(*this) . ann);
        }
    }
    st . locals . pop();
    st . is_member = ivy::native_bool (false);
    resd = res;
    if (! st . in_class & cprot) {
        ivy::add_namespaces (resd,(*this) . name -> get_name());
    }
    st . this_ident = ivy::ident::__t (0);
}
void ivy::actdc::__t::reg_member  (ivy::tocppst::__t &st) const
{
    if ((*this) . is_member())
    {
        ivy::actdc::__t actd;
        actd = (*this);
        actd . has_body = ivy::native_bool (false);
        st . add_member ((*this) . member_type(),actd);
    }
}
__bool ivy::actdc::__t::emitted  (const ivy::tocppst::__t &st) const
{
    __bool res;
    res = (! (*this) . is_member() | ! st . proto_only) & (*this) . kind !=
        ivy::action_kind::__t (ivy::action_kind::external);
    return res;
}
ivy::ptr< ivy::decl::__t > ivy::actdc::__t::fix_action  (const ivy::tocppst::__t &st) const
{
    ivy::ptr< ivy::decl::__t > res;
    if ((*this) . is_member())
    {
        ivy::param_map::__t outs;
        outs = ivy::param_set ((*this) . outputs);
        ivy::ptr< ivy::expr::__t > origthis;
        origthis =
            (*this) . inputs . value (vector__ivy__expr::domain::__t (0)) -> get_arg (vector__ivy__expr::domain::__t
                    (0));
        ivy::ptr< ivy::expr::__t > thisty;
        thisty =
            (*this) . inputs . value (vector__ivy__expr::domain::__t (0)) -> get_arg (vector__ivy__expr::domain::__t
                    (1));
        ivy::ptr< ivy::ident::__t > id;
        id = origthis -> get_name();
        if (outs . mem (id))
        {
            if (ivy::is_virtual_action ((*this),st . globals,st . subtype_rel))
            {
                ivy::actdc::__t resa;
                resa = (*this);
                ivy::ptr< ivy::expr::__t > newthis;
                newthis = ivy::symbol::makestr (ivy::from_str< str::__t > ("__this"),(*this) . ann);
                ivy::ptr< ivy::expr::__t > newthisarg;
                newthisarg = ivy::colon::make (newthis,thisty,(*this) . ann);
                resa . inputs . set (vector__ivy__expr::domain::__t (0),newthisarg);
                if (resa . has_body)
                {
                    resa . body =
                        ivy::sequence::make (ivy::asgn::make (origthis,newthis,(*this) . ann),resa .
                            body,(*this) . ann);
                }
                res = resa;
            } else {
                res = (*this);
            }
        } else {
            res = (*this);
        }
    } else {
        res = (*this);
    }
    return res;
}
__bool ivy::initdc::__t::emitted  (const ivy::tocppst::__t &st) const
{
    __bool res;
    res = ivy::native_bool (false);
    return res;
}
void ivy::add_namespaces_rec  (ivy::ptr< cpp::decl::__t > &d,const ivy::ptr< ivy::ident::__t > &id)
{
    cpp::namespacedecl::__t nd;
    nd . ann = d -> get_ann();
    ivy::ptr< ivy::ident::__t > name;
    name = id . isa< ivy::dotident::__t >() ? id -> get_member() : id;
    nd . name = cpp::symbol::make (name -> to_cpp (ivy::native_bool (false)),d -> get_ann());
    nd . members . append (d);
    d = nd;
    if (id . isa< ivy::dotident::__t >()) {
        ivy::add_namespaces_rec (d,id -> get_namesp());
    }
}
void ivy::add_namespaces  (ivy::ptr< cpp::decl::__t > &d,const ivy::ptr< ivy::ident::__t > &id)
{
    if (id . isa< ivy::dotident::__t >()) {
        ivy::add_namespaces_rec (d,id -> get_namesp());
    }
}
void ivy::member_name  (ivy::ptr< cpp::expr::__t > &s)
{
    if (s -> get_name() . isa< cpp::dotident::__t >())
    {
        s = cpp::symbol::make (s -> get_name() -> get_member(),s -> get_ann());
    }
}
ivy::ptr< cpp::expr::__t > ivy::make_std_tpl  (const str::__t &tpl,const str::__t &ty,const ivy::ptr< annot::__t >
    &ann)
{
    ivy::ptr< cpp::expr::__t > res;
    {
        cpp::strident::__t vid;
        vid . val = tpl;
        vid . subscrs . append (cpp::strident::make (ty));
        ivy::ptr< cpp::ident::__t > tname;
        tname = cpp::dotident::make (cpp::strident::make (ivy::from_str< str::__t > ("ivy")),vid);
        res = cpp::symbol::make (tname,ann);
    }
    return res;
}
str::__t ivy::enum_name  (const ivy::ptr< cpp::expr::__t > &name)
{
    str::__t res;
    {
        res = ivy::from_str< str::__t > ("__enum_");
        res . extend (name -> get_name() -> to_str());
    }
    return res;
}
void ivy::enum_to_cpp  (const ivy::ptr< cpp::expr::__t > &name,const ivy::ptr< ivy::typespec::__t >
    &spec,const ivy::ptr< cpp::decl::__t > &sd,ivy::tocppst::__t &st,ivy::ptr< cpp::decl::__t > &res)
{
    
    // Delcare the enum `__enum_t`.
    
    cpp::enumdecl::__t ed;
    ed . ann = name -> get_ann();
    ed . name = cpp::symbol::makestr (ivy::enum_name (name),ed . ann);
    vector__ivy__expr::__t cnstrs;
    cnstrs = spec -> get_elems();
    vector__ivy__expr::domain::__t idx;
    idx = cnstrs . begin();
    while (idx < cnstrs . end)
    {
        ivy::ptr< cpp::expr::__t > e;
        cnstrs . value (idx) -> to_cpp (st,e);
        {
            ivy::ptr< cpp::expr::__t > __tmp26;
            __tmp26 = e;
            ivy::member_name (__tmp26);
            ed . elems . append (__tmp26);
        }
        idx = idx . next();
    }
    cpp::groupdc::__t gd;
    gd . ann = name -> get_ann();
    gd . decls . append (ed);
    gd . decls . append (sd);
    res = gd;
}
cpp::funcdecl::__t ivy::make_cpp_cons  (const cpp::structdecl::__t &t)
{
    cpp::funcdecl::__t s;
    {
        s . ftype . base . name = t . name;
        s . has_body = ivy::native_bool (true);
        s . body = cpp::skipst::make (t . ann);
    }
    return s;
}
cpp::funcdecl::__t ivy::make_virt_destr  (const cpp::structdecl::__t &t)
{
    cpp::funcdecl::__t s;
    {
        str::__t name;
        name . extend (ivy::from_str< str::__t > ("~"));
        name . extend (t . name -> get_name() -> to_str());
        s . ftype . base . name = cpp::symbol::makestr (name,t . ann);
        s . has_body = ivy::native_bool (true);
        s . body = cpp::skipst::make (t . ann);
        s . is_virtual = ivy::native_bool (true);
    }
    return s;
}
cpp::funcdecl::__t ivy::make_upcast_method  (const cpp::structdecl::__t &t)
{
    cpp::funcdecl::__t s;
    {
        s . ftype . base . name =
            cpp::symbol::makestr (ivy::from_str< str::__t > ("__upcast"),t . ann);
        ivy::ptr< cpp::expr::__t > ty;
        ty = t . has_super ? t . super : t . name;
        s . ftype . base . _type =
            cpp::symbol::makestr1 (ivy::from_str< str::__t > ("ivy::ptr"),ty -> get_name(),t . ann);
        s . has_body = ivy::native_bool (true);
        s . body =
            cpp::retst::make (cpp::symbol::makestr (ivy::from_str< str::__t > ("(*this)"),t . ann),t
                . ann);
        s . is_virtual = ivy::native_bool (true);
        s . ftype . is_const = ivy::native_bool (true);
    }
    return s;
}
void ivy::add_default_cons  (cpp::structdecl::__t &s,const __bool &is_const,const __bool &is_rvalue)
{
    cpp::simpletype::__t ty;
    ty . _type = s . name;
    ty . is_ref = ivy::native_bool (true);
    ty . is_const = is_const;
    ty . is_rvalue = is_rvalue;
    cpp::funcdecl::__t ncons;
    ncons . ftype . base . name = s . name;
    ncons . ftype . args . append (ty);
    ncons . is_default = ivy::native_bool (true);
    s . members . append (ncons);
}
void ivy::add_default_asgn  (cpp::structdecl::__t &s,const __bool &is_const,const __bool &is_rvalue)
{
    cpp::simpletype::__t ty;
    ty . _type = s . name;
    ty . is_ref = ivy::native_bool (true);
    ty . is_const = is_const;
    ty . is_rvalue = is_rvalue;
    cpp::funcdecl::__t ncons;
    ncons . ftype . base . _type = s . name;
    ncons . ftype . base . name =
        cpp::symbol::makestr (ivy::from_str< str::__t > ("operator ="),s . ann);
    ncons . ftype . base . is_ref = ivy::native_bool (true);
    ncons . ftype . args . append (ty);
    ncons . is_default = ivy::native_bool (true);
    s . members . append (ncons);
}
void ivy::add_numeric_cons  (cpp::structdecl::__t &s)
{
    cpp::funcdecl::__t ncons;
    ncons = ivy::make_cpp_cons (s);
    cpp::simpletype::__t nconsarg0;
    nconsarg0 . _type = cpp::symbol::makestr (ivy::from_str< str::__t > ("long long"),s . ann);
    nconsarg0 . name = cpp::symbol::makestr (ivy::from_str< str::__t > ("value"),ncons . ann);
    ncons . ftype . args . append (nconsarg0);
    s . members . append (ncons);
}
void ivy::add_sizet_conv  (cpp::structdecl::__t &s)
{
    cpp::funcdecl::__t tosizet;
    tosizet . ftype . base . name =
        cpp::symbol::makestr (ivy::from_str< str::__t > ("operator std::size_t"),s . ann);
    tosizet . ftype . is_const = ivy::native_bool (true);
    tosizet . has_body = ivy::native_bool (true);
    tosizet . body =
        cpp::retst::make (cpp::symbol::makestr (ivy::from_str< str::__t > ("0"),s . ann),s . ann);
    s . members . append (tosizet);
}
void ivy::add_is_seq_pred  (cpp::structdecl::__t &s)
{
    cpp::funcdecl::__t isseq;
    isseq . ftype . base . _type = cpp::symbol::makestr (ivy::from_str< str::__t > ("bool"),s . ann);
    isseq . ftype . base . name =
        cpp::symbol::makestr (ivy::from_str< str::__t > ("__is_seq"),s . ann);
    isseq . is_static = ivy::native_bool (true);
    isseq . has_body = ivy::native_bool (true);
    isseq . body =
        cpp::retst::make (cpp::symbol::makestr (ivy::from_str< str::__t > ("false"),s . ann),s . ann);
    s . members . append (isseq);
}
void ivy::add_eq_pred  (cpp::structdecl::__t &s)
{
    cpp::funcdecl::__t eq;
    eq . ftype . base . _type =
        cpp::symbol::makestr (ivy::from_str< str::__t > ("ivy::native_bool"),s . ann);
    eq . ftype . base . name =
        cpp::symbol::makestr (ivy::from_str< str::__t > ("operator =="),s . ann);
    eq . ftype . is_const = ivy::native_bool (true);
    cpp::simpletype::__t eqarg0;
    eqarg0 . _type = s . name;
    eqarg0 . is_const = ivy::native_bool (true);
    eqarg0 . is_ref = ivy::native_bool (true);
    eqarg0 . name = cpp::symbol::makestr (ivy::from_str< str::__t > ("other"),eq . ann);
    eq . ftype . args . append (eqarg0);
    eq . has_body = ivy::native_bool (true);
    vector__cpp__expr::__t eqs;
    vector__cpp__decl::domain::__t idx;
    idx = s . members . begin();
    while (idx < s . members . end)
    {
        ivy::ptr< cpp::decl::__t > d;
        d = s . members . value (idx);
        if (d . isa< cpp::vardecl::__t >())
        {
            ivy::ptr< cpp::expr::__t > f0;
            f0 = d -> get_name();
            ivy::ptr< cpp::expr::__t > f1;
            f1 = cpp::dot::make (eqarg0 . name,d -> get_name(),s . ann);
            ivy::ptr< cpp::expr::__t > e;
            e = cpp::equals::make (f0,f1,s . ann);
            eqs . append (e);
        }
        idx = idx . next();
    }
    ivy::ptr< cpp::expr::__t > retexp;
    retexp = cpp::symbol::makestr (ivy::from_str< str::__t > ("true"),s . ann);
    if (eqs . end > vector__cpp__expr::domain::__t (0))
    {
        retexp = cpp::__and::fold_left (eqs,s . ann);
    }
    eq . body = cpp::retst::make (retexp,s . ann);
    s . members . append (eq);
}
void ivy::add_diseq_pred  (cpp::structdecl::__t &s)
{
    cpp::funcdecl::__t diseq;
    diseq . ftype . base . _type =
        cpp::symbol::makestr (ivy::from_str< str::__t > ("ivy::native_bool"),s . ann);
    diseq . ftype . base . name =
        cpp::symbol::makestr (ivy::from_str< str::__t > ("operator !="),s . ann);
    diseq . ftype . is_const = ivy::native_bool (true);
    cpp::simpletype::__t diseqarg0;
    diseqarg0 . _type = s . name;
    diseqarg0 . is_const = ivy::native_bool (true);
    diseqarg0 . is_ref = ivy::native_bool (true);
    diseqarg0 . name = cpp::symbol::makestr (ivy::from_str< str::__t > ("other"),diseq . ann);
    diseq . ftype . args . append (diseqarg0);
    diseq . has_body = ivy::native_bool (true);
    ivy::ptr< cpp::expr::__t > f0;
    f0 = cpp::symbol::makestr (ivy::from_str< str::__t > ("(*this)"),s . ann);
    ivy::ptr< cpp::expr::__t > diseqret;
    diseqret = cpp::__not::make (cpp::equals::make (f0,diseqarg0 . name,s . ann),s . ann);
    diseq . body = cpp::retst::make (diseqret,s . ann);
    s . members . append (diseq);
}
void ivy::add_is_zero_pred  (cpp::structdecl::__t &s)
{
    cpp::funcdecl::__t iszero;
    iszero . ftype . base . _type =
        cpp::symbol::makestr (ivy::from_str< str::__t > ("bool"),s . ann);
    iszero . ftype . base . name =
        cpp::symbol::makestr (ivy::from_str< str::__t > ("__is_zero"),s . ann);
    iszero . ftype . is_const = ivy::native_bool (true);
    iszero . has_body = ivy::native_bool (true);
    vector__cpp__expr::__t iszeros;
    vector__cpp__decl::domain::__t idx;
    idx = s . members . begin();
    while (idx < s . members . end)
    {
        ivy::ptr< cpp::decl::__t > d;
        d = s . members . value (idx);
        if (d . isa< cpp::vardecl::__t >())
        {
            ivy::ptr< cpp::expr::__t > f0;
            f0 = d -> get_name();
            ivy::ptr< cpp::expr::__t > f1;
            f1 = cpp::dot::make (d -> get_name(),iszero . ftype . base . name,s . ann);
            vector__cpp__expr::__t f2;
            ivy::ptr< cpp::expr::__t > e;
            e = cpp::app::make (f1,f2,s . ann);
            iszeros . append (e);
        }
        idx = idx . next();
    }
    ivy::ptr< cpp::expr::__t > iszeroret;
    iszeroret = cpp::symbol::makestr (ivy::from_str< str::__t > ("true"),s . ann);
    if (iszeros . end > vector__cpp__expr::domain::__t (0))
    {
        iszeroret = cpp::__and::fold_left (iszeros,s . ann);
    }
    iszero . body = cpp::retst::make (iszeroret,s . ann);
    s . members . append (iszero);
}
void ivy::add_hasher  (cpp::structdecl::__t &s)
{
    
    // Hash function adds hashes of members:
    //     struct __hash { size_t operator()(const name &x) {returns t1::__hash(f1) + ...; } };
    
    cpp::structdecl::__t hashstr;
    hashstr . ann = s . ann;
    hashstr . name = cpp::symbol::makestr (ivy::from_str< str::__t > ("__hash"),s . ann);
    hashstr . has_members = ivy::native_bool (true);
    cpp::funcdecl::__t hash;
    hash . ftype . base . _type =
        cpp::symbol::makestr (ivy::from_str< str::__t > ("std::size_t"),s . ann);
    hash . ftype . base . name =
        cpp::symbol::makestr (ivy::from_str< str::__t > ("operator ()"),s . ann);
    hash . ftype . is_const = ivy::native_bool (true);
    cpp::simpletype::__t hasharg0;
    hasharg0 . _type = s . name;
    hasharg0 . is_const = ivy::native_bool (true);
    hasharg0 . is_ref = ivy::native_bool (true);
    hasharg0 . name = cpp::symbol::makestr (ivy::from_str< str::__t > ("x"),hash . ann);
    hash . ftype . args . append (hasharg0);
    hash . has_body = ivy::native_bool (true);
    vector__cpp__expr::__t hashs;
    vector__cpp__decl::domain::__t idx;
    idx = s . members . begin();
    while (idx < s . members . end)
    {
        ivy::ptr< cpp::decl::__t > d;
        d = s . members . value (idx);
        if (d . isa< cpp::vardecl::__t >())
        {
            ivy::ptr< cpp::expr::__t > f0;
            f0 = d -> get_name();
            ivy::ptr< cpp::expr::__t > f1;
            f1 = hashstr . name -> prefix (d -> get_type() -> get_name());
            ivy::ptr< cpp::expr::__t > f2;
            f2 = cpp::dot::make (hasharg0 . name,f0,s . ann);
            ivy::ptr< cpp::expr::__t > e;
            e = cpp::app::make1 (cpp::app::make0 (f1,s . ann),f2,s . ann);
            hashs . append (e);
        }
        idx = idx . next();
    }
    ivy::ptr< cpp::expr::__t > hashret;
    hashret = cpp::symbol::makestr (ivy::from_str< str::__t > ("0"),s . ann);
    if (hashs . end > vector__cpp__expr::domain::__t (0))
    {
        hashret = cpp::plus::fold_left (hashs,s . ann);
    }
    hash . body = cpp::retst::make (hashret,s . ann);
    hashstr . members . append (hash);
    s . members . append (hashstr);
}
void ivy::add_standard_traits  (cpp::structdecl::__t &s)
{
    s . members . append (ivy::make_cpp_cons (s));
    ivy::add_default_cons (s,ivy::native_bool (true),ivy::native_bool (false));
    ivy::add_default_cons (s,ivy::native_bool (false),ivy::native_bool (true));
    ivy::add_default_asgn (s,ivy::native_bool (true),ivy::native_bool (false));
    ivy::add_default_asgn (s,ivy::native_bool (false),ivy::native_bool (true));
    ivy::add_numeric_cons (s);
    ivy::add_sizet_conv (s);
    ivy::add_is_seq_pred (s);
    ivy::add_eq_pred (s);
    ivy::add_diseq_pred (s);
    ivy::add_is_zero_pred (s);
    ivy::add_hasher (s);
}
void ivy::add_virtual_destructor  (cpp::structdecl::__t &s)
{
    s . members . append (ivy::make_upcast_method (s));
    s . members . append (ivy::make_virt_destr (s));
}
void ivy::add_upcast_method  (cpp::structdecl::__t &s)
{
    s . members . append (ivy::make_upcast_method (s));
}
void ivy::add_derived_cons  (cpp::structdecl::__t &s,const ivy::ptr< cpp::expr::__t > &t,const
    __bool &constref)
{
    cpp::funcdecl::__t dcons;
    dcons = ivy::make_cpp_cons (s);
    cpp::simpletype::__t dconsarg0;
    dconsarg0 . _type = t;
    dconsarg0 . name = cpp::symbol::makestr (ivy::from_str< str::__t > ("value"),dcons . ann);
    dconsarg0 . is_const = constref;
    dconsarg0 . is_ref = constref;
    dcons . ftype . args . append (dconsarg0);
    dcons . ftype . has_initializer = ivy::native_bool (true);
    dcons . ftype . initializer = cpp::app::make1 (s . super,dconsarg0 . name,s . ann);
    s . members . append (dcons);
}
void ivy::add_base_conversion  (cpp::structdecl::__t &s)
{
    cpp::funcdecl::__t abc;
    str::__t op;
    op . extend (ivy::from_str< str::__t > ("operator "));
    op . extend (s . super -> get_name() -> to_str());
    abc . ftype . base . name = cpp::symbol::makestr (op,s . ann);
    abc . ftype . is_const = ivy::native_bool (true);
    abc . has_body = ivy::native_bool (true);
    abc . body =
        cpp::retst::make (cpp::symbol::makestr (ivy::from_str< str::__t > ("(*this)"),s . ann),s .
            ann);
    s . members . append (abc);
}
void ivy::add_derived_traits  (cpp::structdecl::__t &s)
{
    s . members . append (ivy::make_cpp_cons (s));
    ivy::add_derived_cons (s,cpp::symbol::makestr (ivy::from_str< str::__t > ("long long"),s . ann),ivy::native_bool
                (false));
    ivy::add_derived_cons (s,s . super,ivy::native_bool (true));
    ivy::add_base_conversion (s);
}
void ivy::native_type_to_cpp  (const ivy::ptr< ivy::expr::__t > &ty,ivy::tocppst::__t &st,ivy::ptr< cpp::expr::__t >
    &res)
{
    st . native = ivy::native_bool (true);
    ty -> to_cpp (st,res);
    st . native = ivy::native_bool (false);
}
void ivy::typedc::__t::to_cpp  (ivy::tocppst::__t &st,ivy::ptr< cpp::decl::__t > &resd) const
{
    cpp::structdecl::__t res;
    res . ann = (*this) . ann;
    ivy::ptr< cpp::expr::__t > cls;
    (*this) . sort -> to_cpp (st,cls);
    {
        res . name = cls;
        ivy::member_name (res . name);
    }
    if (! st . forward)
    {
        if ((*this) . has_super)
        {
            res . has_super = ivy::native_bool (true);
            (*this) . super -> to_cpp (st,res . super);
        } else
        {
            if ((*this) . has_spec & (*this) . spec . isa< ivy::enumspec::__t >())
            {
                res . has_super = ivy::native_bool (true);
                res . super =
                    ivy::make_std_tpl (ivy::from_str< str::__t > ("native_enum"),ivy::enum_name (res
                            . name),res . ann);
            } else
            {
                if (st . cppclasses . mem ((*this) . sort -> get_name()))
                {
                    res . has_super = ivy::native_bool (true);
                    ivy::ptr< ivy::expr::__t > itype;
                    itype = st . cppclasses . value ((*this) . sort -> get_name());
                    ivy::native_type_to_cpp (itype,st,res . super);
                }
            }
        }
        res . has_members = ivy::native_bool (true);
        
        // This is not a forward declaration
        
        vector__ivy__decl::__t members;
        {
            members = vector__ivy__decl::empty();
            st . members . get ((*this) . sort -> get_name(),members);
        }
        vector__ivy__decl::domain::__t idx;
        idx = members . begin();
        st . in_class = ivy::native_bool (true);
        while (idx < members . end)
        {
            ivy::ptr< cpp::decl::__t > d;
            members . value (idx) -> to_cpp (st,d);
            res . members . append (d);
            idx = idx . next();
        }
        st . in_class = ivy::native_bool (false);
        if (res . has_super & ! (*this) . has_super) {
            ivy::add_derived_traits (res);
        } else {
            ivy::add_standard_traits (res);
        }
        if ((*this) . has_super) {
            ivy::add_upcast_method (res);
        }
        if (ivy::is_variant_type ((*this) . sort,st)) {
            ivy::add_virtual_destructor (res);
        }
        resd = res;
        if ((*this) . has_spec & (*this) . spec . isa< ivy::enumspec::__t >())
        {
            ivy::ptr< cpp::decl::__t > __tmp27;
            ivy::enum_to_cpp (res . name,(*this) . spec,resd,st,__tmp27);
            resd = __tmp27;
        }
        {}
    } else {
        resd = res;
    }
    ivy::ptr< ivy::ident::__t > __tmp28;
    __tmp28 = (*this) . sort -> get_name();
    ivy::fix_object_clash (__tmp28,st);
    ivy::add_namespaces (resd,__tmp28);
}
void ivy::typedc::tocpp_show_str  (const str::__t &s) {}
void ivy::typedc::__t::reg_member  (ivy::tocppst::__t &st) const
{
    if ((*this) . has_spec)
    {
        if ((*this) . spec . isa< ivy::enumspec::__t >())
        {
            vector__ivy__expr::__t conss;
            conss = (*this) . spec -> get_elems();
            vector__ivy__expr::domain::__t idx;
            idx = conss . begin();
            while (idx < conss . end)
            {
                ivy::ptr< ivy::expr::__t > cons;
                cons = conss . value (idx);
                st . constructors . set (cons -> get_name(),ivy::native_bool (true));
                idx = idx . next();
            }
        }
    }
}
__bool ivy::is_variant_type  (const ivy::ptr< ivy::expr::__t > &t,const ivy::tocppst::__t &st)
{
    __bool res;
    if (t . isa< ivy::symbol::__t >())
    {
        if (st . subtype_rel . subtypes_of . mem (t -> get_name())) {
            res = ivy::native_bool (true);
        }
    }
    return res;
}
void ivy::fix_variant_type  (const ivy::ptr< ivy::expr::__t > &t,ivy::tocppst::__t &st,ivy::ptr< cpp::expr::__t >
    &res)
{
    if (ivy::is_variant_type (t,st))
    {
        ivy::ptr< cpp::expr::__t > cppty;
        t -> to_cpp (st,cppty);
        cpp::strident::__t s;
        s . val = ivy::from_str< str::__t > ("ptr");
        s . subscrs . append (cppty -> get_name());
        res =
            cpp::symbol::make (s . prefix (cpp::strident::make (ivy::from_str< str::__t > ("ivy"))),t
                    -> get_ann());
    } else {
        t -> to_cpp (st,res);
    }
}
ivy::ptr< ivy::decl::__t > ivy::decl::__t::func_to_action () const
{
    ivy::ptr< ivy::decl::__t > res;
    res = (*this) . __upcast();
    return res;
}
ivy::ptr< ivy::decl::__t > ivy::decl::__t::fix_action  (const ivy::tocppst::__t &st) const
{
    ivy::ptr< ivy::decl::__t > res;
    res = (*this) . __upcast();
    return res;
}
ivy::ptr< ivy::decl::__t > ivy::vardc::__t::func_to_action () const
{
    ivy::ptr< ivy::decl::__t > dres;
    if ((*this) . has_def)
    {
        ivy::actdc::__t res;
        res . ann = (*this) . ann;
        ivy::ptr< ivy::expr::__t > lhs;
        lhs = (*this) . typing;
        ivy::ptr< ivy::expr::__t > ty;
        if (lhs . isa< ivy::app::__t >())
        {
            res . name = lhs -> get_func() -> get_arg (vector__ivy__expr::domain::__t (0));
            res . inputs = lhs -> get_args();
            ty =
                lhs -> get_func() -> get_arg (vector__ivy__expr::domain::__t (1)) -> get_arg (vector__ivy__expr::domain::__t
                        (1));
        } else
        {
            if (lhs . isa< ivy::symbol::__t >())
            {
                res . name = lhs -> get_arg (vector__ivy__expr::domain::__t (0));
                ty = lhs -> get_arg (vector__ivy__expr::domain::__t (1));
            }
        }
        ivy::ptr< ivy::expr::__t > retv;
        retv = ivy::symbol::makestr (ivy::from_str< str::__t > ("__out"),(*this) . ann);
        ivy::ptr< ivy::expr::__t > retty;
        retty = ivy::colon::make (retv,ty,(*this) . ann);
        res . outputs . append (retty);
        res . has_body = ivy::native_bool (true);
        res . body = ivy::asgn::make (retty,(*this) . def,(*this) . ann);
        dres = res;
    } else {
        dres = (*this);
    }
    return dres;
}
void ivy::vardc::__t::to_cpp  (ivy::tocppst::__t &st,ivy::ptr< cpp::decl::__t > &resd) const
{
    cpp::vardecl::__t res;
    res . ann = (*this) . ann;
    ivy::ptr< ivy::expr::__t > ty;
    ty = (*this) . typing -> get_arg (vector__ivy__expr::domain::__t (1));
    if ((*this) . is_destructor)
    {
        ty = ty -> curry() -> get_arg (vector__ivy__expr::domain::__t (1));
    }
    ivy::fix_variant_type (ty,st,res . vtype . _type);
    ivy::ptr< cpp::expr::__t > name;
    (*this) . typing -> get_arg (vector__ivy__expr::domain::__t (0)) -> to_cpp (st,name);
    {
        res . vtype . name = name;
        ivy::member_name (res . vtype . name);
    }
    resd = res;
    
    // workaround
    
    if (! st . in_class)
    {
        ivy::add_namespaces (resd,(*this) . typing -> get_arg (vector__ivy__expr::domain::__t (0))
                    -> get_name());
    }
}
void ivy::vardc::__t::reg_member  (ivy::tocppst::__t &st) const
{
    if ((*this) . is_destructor)
    {
        vector__ivy__expr::__t dom;
        dom =
            ivy::times::unfold_left ((*this) . typing -> get_arg (vector__ivy__expr::domain::__t (1))
                    -> get_arg (vector__ivy__expr::domain::__t (0)));
        ivy::ptr< ivy::ident::__t > type_ident;
        type_ident = dom . value (vector__ivy__expr::domain::__t (0)) -> get_name();
        st . add_member (type_ident,(*this));
    }
}
__bool ivy::vardc::__t::emitted  (const ivy::tocppst::__t &st) const
{
    __bool res;
    res = ! (*this) . is_destructor;
    return res;
}
void ivy::header::__t::to_cpp  (ivy::tocppst::__t &st,ivy::ptr< cpp::decl::__t > &res) const
{
    cpp::header::__t t;
    (*this) . to_cpp_int (st,t);
    t . ann = (*this) . ann;
    res = t;
}
void ivy::header::__t::to_cpp_int  (ivy::tocppst::__t &st,cpp::header::__t &res) const
{
    res . filename = (*this) . filename;
}
void ivy::interpdc::__t::reg_member  (ivy::tocppst::__t &st) const
{
    st . cppclasses . set ((*this) . itype -> get_name(),(*this) . ctype);
}
__bool ivy::interpdc::__t::emitted  (const ivy::tocppst::__t &st) const
{
    __bool res;
    res = ivy::native_bool (false);
    return res;
}
void ivy::objectdc::__t::reg_member  (ivy::tocppst::__t &st) const
{
    st . objects . set ((*this) . name -> get_name(),ivy::native_bool (true));
}
__bool ivy::objectdc::__t::emitted  (const ivy::tocppst::__t &st) const
{
    __bool res;
    res = ivy::native_bool (false);
    return res;
}
cpp::prog::__t ivy::prog::__t::to_cpp () const
{
    cpp::prog::__t res;
    {
        ivy::prog::__t s;
        s = (*this);
        
        // workaround
        
        ivy::tocppst::__t st;
        
        // Get the subtyping relation
        
        st . subtype_rel = s . get_subtypes();
        
        // A pass to convert function defs to actions
        
        vector__ivy__decl::domain::__t idx;
        idx = s . decls . begin();
        while (idx < s . decls . end)
        {
            ivy::ptr< ivy::decl::__t > d;
            d = s . decls . value (idx) -> func_to_action();
            s . decls . set (idx,d);
            idx = idx . next();
        }
        
        // Get the global typing
        
        st . globals = s . get_global_types (ivy::native_bool (true));
        
        // A pass to register all of the type members
        
        idx = s . decls . begin();
        while (idx < s . decls . end)
        {
            s . decls . value (idx) -> reg_member (st);
            idx = idx . next();
        }
        
        // A pass to emit the forward declarations of classes
        
        st . forward = ivy::native_bool (true);
        idx = s . decls . begin();
        while (idx < s . decls . end)
        {
            ivy::ptr< ivy::decl::__t > ivyd;
            ivyd = s . decls . value (idx);
            if (ivyd . isa< ivy::typedc::__t >())
            {
                ivy::ptr< cpp::decl::__t > d;
                ivyd -> to_cpp (st,d);
                res . decls . append (d);
            }
            idx = idx . next();
        }
        st . forward = ivy::native_bool (false);
        
        // A pass to rewrite actions with problematic signatures
        
        idx = s . decls . begin();
        while (idx < s . decls . end)
        {
            ivy::ptr< ivy::decl::__t > d;
            d = s . decls . value (idx) -> fix_action (st);
            s . decls . set (idx,d);
            idx = idx . next();
        }
        
        // A pass to record all of the C++ function prototypes
        
        idx = s . decls . begin();
        while (idx < s . decls . end)
        {
            s . decls . value (idx) -> record_prototypes (st);
            idx = idx . next();
        }
        
        // A pass to emit the C++ prototypes and class declarations
        
        st . proto_only = ivy::native_bool (true);
        idx = s . decls . begin();
        while (idx < s . decls . end)
        {
            if (s . decls . value (idx) -> emitted (st))
            {
                ivy::ptr< cpp::decl::__t > d;
                s . decls . value (idx) -> to_cpp (st,d);
                res . decls . append (d);
            }
            idx = idx . next();
        }
        
        // A pass to emit the C++ function implementations
        
        st . proto_only = ivy::native_bool (false);
        idx = s . decls . begin();
        while (idx < s . decls . end)
        {
            ivy::ptr< ivy::decl::__t > ivyd;
            ivyd = s . decls . value (idx);
            if (ivyd . isa< ivy::actdc::__t >() & s . decls . value (idx) -> emitted (st))
            {
                ivy::ptr< cpp::decl::__t > d;
                ivyd -> to_cpp (st,d);
                res . decls . append (d);
            }
            idx = idx . next();
        }
        
        // Emit a main function by concatenating the init
        // declaration bodies.
        
        cpp::funcdecl::__t main;
        main . ftype . base . _type = cpp::inttype (main . ann);
        main . ftype . base . name =
            cpp::symbol::makestr (ivy::from_str< str::__t > ("main"),main . ann);
        cpp::simpletype::__t mainarg0;
        cpp::simpletype::__t mainarg1;
        mainarg0 . _type = cpp::inttype (main . ann);
        mainarg0 . name = cpp::symbol::makestr (ivy::from_str< str::__t > ("argc"),main . ann);
        mainarg1 . _type = cpp::symbol::makestr (ivy::from_str< str::__t > ("char **"),main . ann);
        mainarg1 . name = cpp::symbol::makestr (ivy::from_str< str::__t > ("argv"),main . ann);
        main . ftype . args . append (mainarg0);
        main . ftype . args . append (mainarg1);
        main . has_body = ivy::native_bool (true);
        main . body =
            cpp::retst::make (cpp::symbol::makestr (ivy::from_str< str::__t > ("0"),main . ann),main
                . ann);
        idx = s . decls . end;
        while (idx > s . decls . begin())
        {
            idx = idx . prev();
            ivy::ptr< ivy::decl::__t > decl;
            decl = s . decls . value (idx);
            if (decl . isa< ivy::initdc::__t >())
            {
                ivy::ptr< cpp::stmt::__t > cbody;
                decl -> get_body() -> to_cpp (st,cbody);
                main . body = cpp::sequence::make (cbody,main . body,decl -> get_ann());
            }
        }
        ivy::ptr< cpp::stmt::__t > argv;
        argv =
            cpp::asgn::make (cpp::symbol::makestr (ivy::from_str< str::__t > ("ivy::__argv"),main .
                    ann),cpp::symbol::makestr (ivy::from_str< str::__t > ("argv"),main . ann),main .
                ann);
        main . body = cpp::sequence::make (argv,main . body,main . ann);
        ivy::ptr< cpp::stmt::__t > argc;
        argc =
            cpp::asgn::make (cpp::symbol::makestr (ivy::from_str< str::__t > ("ivy::__argc"),main .
                    ann),cpp::symbol::makestr (ivy::from_str< str::__t > ("argc"),main . ann),main .
                ann);
        main . body = cpp::sequence::make (argc,main . body,main . ann);
        res . decls . append (main);
    }
    return res;
}
void ivy::prog::show_prog  (const str::__t &s) {}
void ivy::prog::file_to_cpp  (const str::__t &name) 
// Read the program
{
    ivy::prog::__t p;
    p = ivy::prog::read_file (name);
    
    //	    var p := prog.dec(name);
    // Flattening pass
    
    if (ivy::errors . end == vector__ivy__error::domain::__t (0)) {
        p . flat();
    }
    
    //	    call show_prog(p.enc);
    // Type inference pass
    
    if (ivy::errors . end == vector__ivy__error::domain::__t (0)) {
        p . typeinfer();
    }
    
    // Translate to C++
    
    cpp::prog::__t cpp_prog;
    if (ivy::errors . end == vector__ivy__error::domain::__t (0)) {
        cpp_prog = p . to_cpp();
    }
    
    // Pretty-print the C++
    
    if (ivy::errors . end == vector__ivy__error::domain::__t (0))
    {
        str::__t cpp_name;
        {
            cpp_name = name;
            ivy::path::change_extension (cpp_name,ivy::from_str< str::__t > ("cpp"));
        }
        ivy::write_file (cpp_name,cpp_prog . enc());
    }
}
pos::__t argv::end () {
    pos::__t res;
    res = ivy::get_argc();
    return res;
}
str::__t argv::value  (const pos::__t &idx) {
    str::__t res;
    ivy::get_argv (idx,res);
    return res;
}
pid::__t cmd::command  (const vector__str::__t &s) {
    pid::__t res;
    res = ivy::subproc (s);
    return res;
}
retcode::__t cmd::wait  (const pid::__t &s) {
    retcode::__t res;
    res = ivy::wait (s);
    return res;
}
void ivy::show_expr  (const ivy::ptr< ivy::expr::__t > &e) {
    stdio::writeln (e -> enc());
}
void ivy::show_ident  (const ivy::ptr< ivy::ident::__t > &id) {
    stdio::writeln (id -> to_str());
}
void cpp::show_expr  (const ivy::ptr< cpp::expr::__t > &e) {
    stdio::writeln (e -> enc());
}
void usage () {
    stdio::writeln (ivy::from_str< str::__t > ("usage: ivyc <file>.ivy"));
}
int main  (int argc,char ** argv)
{
    ivy::__argc = argc;
    ivy::__argv = argv;
    {
        
        //        str_to_verb(X) := verb.none;
        
        ivy::verb_to_arity (ivy::verb::__t (ivy::verb::numeral)) = pos::__t (0);
        ivy::verb_to_arity (ivy::verb::__t (ivy::verb::fltnum)) = pos::__t (0);
        ivy::verb_to_arity (ivy::verb::__t (ivy::verb::string)) = pos::__t (0);
        ivy::verb_to_arity (ivy::verb::__t (ivy::verb::logvar)) = pos::__t (0);
    }
    {
        ivy::str_to_verb (ivy::from_str< str::__t > ("<->")) = ivy::verb::__t (ivy::verb::iff);
        ivy::verb_to_str (ivy::verb::__t (ivy::verb::iff)) = ivy::from_str< str::__t > ("<->");
        ivy::verb_to_prio (ivy::verb::__t (ivy::verb::iff)) = priority::__t (2);
        ivy::verb_to_arity (ivy::verb::__t (ivy::verb::iff)) = pos::__t (2);
    }
    {
        ivy::str_to_verb (ivy::from_str< str::__t > ("|")) = ivy::verb::__t (ivy::verb::__or);
        ivy::verb_to_str (ivy::verb::__t (ivy::verb::__or)) = ivy::from_str< str::__t > ("|");
        ivy::verb_to_prio (ivy::verb::__t (ivy::verb::__or)) = priority::__t (3);
        ivy::verb_to_arity (ivy::verb::__t (ivy::verb::__or)) = pos::__t (2);
    }
    {
        ivy::str_to_verb (ivy::from_str< str::__t > ("&")) = ivy::verb::__t (ivy::verb::__and);
        ivy::verb_to_str (ivy::verb::__t (ivy::verb::__and)) = ivy::from_str< str::__t > ("&");
        ivy::verb_to_prio (ivy::verb::__t (ivy::verb::__and)) = priority::__t (4);
        ivy::verb_to_arity (ivy::verb::__t (ivy::verb::__and)) = pos::__t (2);
    }
    {
        ivy::str_to_verb (ivy::from_str< str::__t > ("<")) = ivy::verb::__t (ivy::verb::lt);
        ivy::verb_to_str (ivy::verb::__t (ivy::verb::lt)) = ivy::from_str< str::__t > ("<");
        ivy::verb_to_prio (ivy::verb::__t (ivy::verb::lt)) = priority::__t (6);
        ivy::verb_to_arity (ivy::verb::__t (ivy::verb::lt)) = pos::__t (2);
    }
    {
        ivy::str_to_verb (ivy::from_str< str::__t > ("<=")) = ivy::verb::__t (ivy::verb::leq);
        ivy::verb_to_str (ivy::verb::__t (ivy::verb::leq)) = ivy::from_str< str::__t > ("<=");
        ivy::verb_to_prio (ivy::verb::__t (ivy::verb::leq)) = priority::__t (6);
        ivy::verb_to_arity (ivy::verb::__t (ivy::verb::leq)) = pos::__t (2);
    }
    {
        ivy::str_to_verb (ivy::from_str< str::__t > (">")) = ivy::verb::__t (ivy::verb::gt);
        ivy::verb_to_str (ivy::verb::__t (ivy::verb::gt)) = ivy::from_str< str::__t > (">");
        ivy::verb_to_prio (ivy::verb::__t (ivy::verb::gt)) = priority::__t (6);
        ivy::verb_to_arity (ivy::verb::__t (ivy::verb::gt)) = pos::__t (2);
    }
    {
        ivy::str_to_verb (ivy::from_str< str::__t > (">=")) = ivy::verb::__t (ivy::verb::geq);
        ivy::verb_to_str (ivy::verb::__t (ivy::verb::geq)) = ivy::from_str< str::__t > (">=");
        ivy::verb_to_prio (ivy::verb::__t (ivy::verb::geq)) = priority::__t (6);
        ivy::verb_to_arity (ivy::verb::__t (ivy::verb::geq)) = pos::__t (2);
    }
    {
        ivy::str_to_verb (ivy::from_str< str::__t > ("+")) = ivy::verb::__t (ivy::verb::plus);
        ivy::verb_to_str (ivy::verb::__t (ivy::verb::plus)) = ivy::from_str< str::__t > ("+");
        ivy::verb_to_prio (ivy::verb::__t (ivy::verb::plus)) = priority::__t (12);
        ivy::verb_to_arity (ivy::verb::__t (ivy::verb::plus)) = pos::__t (2);
    }
    {
        ivy::str_to_verb (ivy::from_str< str::__t > ("-")) = ivy::verb::__t (ivy::verb::minus);
        ivy::verb_to_str (ivy::verb::__t (ivy::verb::minus)) = ivy::from_str< str::__t > ("-");
        ivy::verb_to_prio (ivy::verb::__t (ivy::verb::minus)) = priority::__t (12);
        ivy::verb_to_arity (ivy::verb::__t (ivy::verb::minus)) = pos::__t (2);
    }
    {
        ivy::str_to_verb (ivy::from_str< str::__t > ("*")) = ivy::verb::__t (ivy::verb::times);
        ivy::verb_to_str (ivy::verb::__t (ivy::verb::times)) = ivy::from_str< str::__t > ("*");
        ivy::verb_to_prio (ivy::verb::__t (ivy::verb::times)) = priority::__t (13);
        ivy::verb_to_arity (ivy::verb::__t (ivy::verb::times)) = pos::__t (2);
    }
    {
        ivy::str_to_verb (ivy::from_str< str::__t > ("/")) = ivy::verb::__t (ivy::verb::div);
        ivy::verb_to_str (ivy::verb::__t (ivy::verb::div)) = ivy::from_str< str::__t > ("/");
        ivy::verb_to_prio (ivy::verb::__t (ivy::verb::div)) = priority::__t (13);
        ivy::verb_to_arity (ivy::verb::__t (ivy::verb::div)) = pos::__t (2);
    }
    {
        ivy::str_to_verb (ivy::from_str< str::__t > ("()")) = ivy::verb::__t (ivy::verb::empty);
        ivy::verb_to_str (ivy::verb::__t (ivy::verb::empty)) = ivy::from_str< str::__t > ("()");
        ivy::verb_to_prio (ivy::verb::__t (ivy::verb::empty)) = priority::__t (0);
        ivy::verb_to_arity (ivy::verb::__t (ivy::verb::empty)) = pos::__t (0);
    }
    {
        ivy::str_to_verb (ivy::from_str< str::__t > ("bool")) = ivy::verb::__t (ivy::verb::boolv);
        ivy::verb_to_str (ivy::verb::__t (ivy::verb::boolv)) = ivy::from_str< str::__t > ("bool");
        ivy::verb_to_prio (ivy::verb::__t (ivy::verb::boolv)) = priority::__t (0);
        ivy::verb_to_arity (ivy::verb::__t (ivy::verb::boolv)) = pos::__t (0);
    }
    {
        ivy::str_to_verb (ivy::from_str< str::__t > ("true")) = ivy::verb::__t (ivy::verb::truev);
        ivy::verb_to_str (ivy::verb::__t (ivy::verb::truev)) = ivy::from_str< str::__t > ("true");
        ivy::verb_to_prio (ivy::verb::__t (ivy::verb::truev)) = priority::__t (0);
        ivy::verb_to_arity (ivy::verb::__t (ivy::verb::truev)) = pos::__t (0);
    }
    {
        ivy::str_to_verb (ivy::from_str< str::__t > ("false")) = ivy::verb::__t (ivy::verb::falsev);
        ivy::verb_to_str (ivy::verb::__t (ivy::verb::falsev)) = ivy::from_str< str::__t > ("false");
        ivy::verb_to_prio (ivy::verb::__t (ivy::verb::falsev)) = priority::__t (0);
        ivy::verb_to_arity (ivy::verb::__t (ivy::verb::falsev)) = pos::__t (0);
    }
    {
        ivy::str_to_verb (ivy::from_str< str::__t > (",")) = ivy::verb::__t (ivy::verb::comma);
        ivy::verb_to_str (ivy::verb::__t (ivy::verb::comma)) = ivy::from_str< str::__t > (",");
        ivy::verb_to_prio (ivy::verb::__t (ivy::verb::comma)) = priority::__t (1);
        ivy::verb_to_arity (ivy::verb::__t (ivy::verb::comma)) = pos::__t (2);
    }
    {
        ivy::str_to_verb (ivy::from_str< str::__t > (".")) = ivy::verb::__t (ivy::verb::dot);
        ivy::verb_to_str (ivy::verb::__t (ivy::verb::dot)) = ivy::from_str< str::__t > (".");
        ivy::verb_to_prio (ivy::verb::__t (ivy::verb::dot)) = priority::__t (100);
        ivy::verb_to_arity (ivy::verb::__t (ivy::verb::dot)) = pos::__t (2);
    }
    {
        ivy::str_to_verb (ivy::from_str< str::__t > ("(")) = ivy::verb::__t (ivy::verb::app);
        ivy::verb_to_str (ivy::verb::__t (ivy::verb::app)) = ivy::from_str< str::__t > ("(");
        ivy::verb_to_prio (ivy::verb::__t (ivy::verb::app)) = priority::__t (99);
        ivy::verb_to_arity (ivy::verb::__t (ivy::verb::app)) = pos::__t (1);
    }
    {
        ivy::str_to_verb (ivy::from_str< str::__t > (":")) = ivy::verb::__t (ivy::verb::colon);
        ivy::verb_to_str (ivy::verb::__t (ivy::verb::colon)) = ivy::from_str< str::__t > (":");
        ivy::verb_to_prio (ivy::verb::__t (ivy::verb::colon)) = priority::__t (50);
        ivy::verb_to_arity (ivy::verb::__t (ivy::verb::colon)) = pos::__t (2);
    }
    {
        ivy::str_to_verb (ivy::from_str< str::__t > ("->")) = ivy::verb::__t (ivy::verb::arrow);
        ivy::verb_to_str (ivy::verb::__t (ivy::verb::arrow)) = ivy::from_str< str::__t > ("->");
        ivy::verb_to_prio (ivy::verb::__t (ivy::verb::arrow)) = priority::__t (2);
        ivy::verb_to_arity (ivy::verb::__t (ivy::verb::arrow)) = pos::__t (2);
    }
    {
        ivy::str_to_verb (ivy::from_str< str::__t > ("cast")) = ivy::verb::__t (ivy::verb::castv);
        ivy::verb_to_str (ivy::verb::__t (ivy::verb::castv)) = ivy::from_str< str::__t > ("cast");
        ivy::verb_to_prio (ivy::verb::__t (ivy::verb::castv)) = priority::__t (49);
        ivy::verb_to_arity (ivy::verb::__t (ivy::verb::castv)) = pos::__t (1);
    }
    {
        ivy::str_to_verb (ivy::from_str< str::__t > ("=")) = ivy::verb::__t (ivy::verb::equals);
        ivy::verb_to_str (ivy::verb::__t (ivy::verb::equals)) = ivy::from_str< str::__t > ("=");
        ivy::verb_to_prio (ivy::verb::__t (ivy::verb::equals)) = priority::__t (5);
        ivy::verb_to_arity (ivy::verb::__t (ivy::verb::equals)) = pos::__t (2);
    }
    {
        ivy::str_to_verb (ivy::from_str< str::__t > ("~=")) = ivy::verb::__t (ivy::verb::notequals);
        ivy::verb_to_str (ivy::verb::__t (ivy::verb::notequals)) = ivy::from_str< str::__t > ("~=");
        ivy::verb_to_prio (ivy::verb::__t (ivy::verb::notequals)) = priority::__t (5);
        ivy::verb_to_arity (ivy::verb::__t (ivy::verb::notequals)) = pos::__t (2);
    }
    {
        ivy::str_to_verb (ivy::from_str< str::__t > ("~")) = ivy::verb::__t (ivy::verb::__not);
        ivy::verb_to_str (ivy::verb::__t (ivy::verb::__not)) = ivy::from_str< str::__t > ("~");
        ivy::verb_to_prio (ivy::verb::__t (ivy::verb::__not)) = priority::__t (15);
        ivy::verb_to_arity (ivy::verb::__t (ivy::verb::__not)) = pos::__t (1);
    }
    {
        ivy::str_to_verb (ivy::from_str< str::__t > ("if")) = ivy::verb::__t (ivy::verb::ite);
        ivy::verb_to_str (ivy::verb::__t (ivy::verb::ite)) = ivy::from_str< str::__t > ("if");
        ivy::verb_to_prio (ivy::verb::__t (ivy::verb::ite)) = priority::__t (2);
        ivy::verb_to_arity (ivy::verb::__t (ivy::verb::ite)) = pos::__t (3);
    }
    {
        ivy::str_to_verb (ivy::from_str< str::__t > ("var")) = ivy::verb::__t (ivy::verb::varv);
        ivy::verb_to_str (ivy::verb::__t (ivy::verb::varv)) = ivy::from_str< str::__t > ("var");
        ivy::verb_to_prio (ivy::verb::__t (ivy::verb::varv)) = priority::__t (2);
        ivy::verb_to_arity (ivy::verb::__t (ivy::verb::varv)) = pos::__t (1);
    }
    {
        ivy::str_to_verb (ivy::from_str< str::__t > ("isa")) = ivy::verb::__t (ivy::verb::isav);
        ivy::verb_to_str (ivy::verb::__t (ivy::verb::isav)) = ivy::from_str< str::__t > ("isa");
        ivy::verb_to_prio (ivy::verb::__t (ivy::verb::isav)) = priority::__t (5);
        ivy::verb_to_arity (ivy::verb::__t (ivy::verb::isav)) = pos::__t (2);
    }
    {
        str::__t inc;
        inc = env::get (ivy::from_str< str::__t > ("IVY_INCLUDE_PATH"));
        pos::__t start;
        start = inc . begin();
        pos::__t idx;
        idx = inc . begin();
        while (idx < inc . end)
        {
            if (inc . value (idx) == __char::__t (58))
            {
                
                // colon
                
                if (idx > start) {
                    ivy::include_path . append (inc . segment (start,idx));
                }
                start = idx . next();
            }
            idx = idx . next();
        }
        if (idx > start) {
            ivy::include_path . append (inc . segment (start,idx));
        }
    }
    {
        ivy::set_built_in_type (ivy::verb::__t (ivy::verb::none),ivy::from_str< str::__t > ("alpha"),ivy::native_bool
                    (true),ivy::native_bool (true),ivy::native_bool (true),ivy::native_bool (true));
        ivy::set_built_in_type (ivy::verb::__t (ivy::verb::plus),ivy::from_str< str::__t > ("alpha * alpha -> alpha"),ivy::native_bool
                    (false),ivy::native_bool (true),ivy::native_bool (true),ivy::native_bool (true));
        ivy::set_built_in_type (ivy::verb::__t (ivy::verb::minus),ivy::from_str< str::__t > ("alpha * alpha -> alpha"),ivy::native_bool
                    (false),ivy::native_bool (true),ivy::native_bool (true),ivy::native_bool (true));
        ivy::set_built_in_type (ivy::verb::__t (ivy::verb::times),ivy::from_str< str::__t > ("alpha * alpha -> alpha"),ivy::native_bool
                    (false),ivy::native_bool (true),ivy::native_bool (true),ivy::native_bool (true));
        ivy::set_built_in_type (ivy::verb::__t (ivy::verb::div),ivy::from_str< str::__t > ("alpha * alpha -> alpha"),ivy::native_bool
                    (false),ivy::native_bool (true),ivy::native_bool (true),ivy::native_bool (true));
        ivy::set_built_in_type (ivy::verb::__t (ivy::verb::arrow),ivy::from_str< str::__t > ("bool * bool -> bool"),ivy::native_bool
                    (true),ivy::native_bool (true),ivy::native_bool (true),ivy::native_bool (true));
        ivy::set_built_in_type (ivy::verb::__t (ivy::verb::castv),ivy::from_str< str::__t > ("alpha -> beta"),ivy::native_bool
                    (false),ivy::native_bool (false),ivy::native_bool (false),ivy::native_bool (false));
        ivy::set_built_in_type (ivy::verb::__t (ivy::verb::truev),ivy::from_str< str::__t > ("bool"),ivy::native_bool
                    (true),ivy::native_bool (true),ivy::native_bool (true),ivy::native_bool (true));
        ivy::set_built_in_type (ivy::verb::__t (ivy::verb::falsev),ivy::from_str< str::__t > ("bool"),ivy::native_bool
                    (true),ivy::native_bool (true),ivy::native_bool (true),ivy::native_bool (true));
        ivy::set_built_in_type (ivy::verb::__t (ivy::verb::__and),ivy::from_str< str::__t > ("bool * bool -> bool"),ivy::native_bool
                    (true),ivy::native_bool (true),ivy::native_bool (true),ivy::native_bool (true));
        ivy::set_built_in_type (ivy::verb::__t (ivy::verb::__or),ivy::from_str< str::__t > ("bool * bool -> bool"),ivy::native_bool
                    (true),ivy::native_bool (true),ivy::native_bool (true),ivy::native_bool (true));
        ivy::set_built_in_type (ivy::verb::__t (ivy::verb::__not),ivy::from_str< str::__t > ("bool -> bool"),ivy::native_bool
                    (true),ivy::native_bool (true),ivy::native_bool (true),ivy::native_bool (true));
        ivy::set_built_in_type (ivy::verb::__t (ivy::verb::iff),ivy::from_str< str::__t > ("bool * bool -> bool"),ivy::native_bool
                    (true),ivy::native_bool (true),ivy::native_bool (true),ivy::native_bool (true));
        ivy::set_built_in_type (ivy::verb::__t (ivy::verb::equals),ivy::from_str< str::__t > ("alpha * alpha -> bool"),ivy::native_bool
                    (false),ivy::native_bool (false),ivy::native_bool (false),ivy::native_bool (true));
        ivy::set_built_in_type (ivy::verb::__t (ivy::verb::notequals),ivy::from_str< str::__t > ("alpha * alpha -> bool"),ivy::native_bool
                    (false),ivy::native_bool (false),ivy::native_bool (false),ivy::native_bool (true));
        ivy::set_built_in_type (ivy::verb::__t (ivy::verb::lt),ivy::from_str< str::__t > ("alpha * alpha -> bool"),ivy::native_bool
                    (false),ivy::native_bool (false),ivy::native_bool (false),ivy::native_bool (true));
        ivy::set_built_in_type (ivy::verb::__t (ivy::verb::leq),ivy::from_str< str::__t > ("alpha * alpha -> bool"),ivy::native_bool
                    (false),ivy::native_bool (false),ivy::native_bool (false),ivy::native_bool (true));
        ivy::set_built_in_type (ivy::verb::__t (ivy::verb::gt),ivy::from_str< str::__t > ("alpha * alpha -> bool"),ivy::native_bool
                    (false),ivy::native_bool (false),ivy::native_bool (false),ivy::native_bool (true));
        ivy::set_built_in_type (ivy::verb::__t (ivy::verb::geq),ivy::from_str< str::__t > ("alpha * alpha -> bool"),ivy::native_bool
                    (false),ivy::native_bool (false),ivy::native_bool (false),ivy::native_bool (true));
        ivy::set_built_in_type (ivy::verb::__t (ivy::verb::ite),ivy::from_str< str::__t > ("alpha * bool * alpha -> alpha"),ivy::native_bool
                    (false),ivy::native_bool (true),ivy::native_bool (true),ivy::native_bool (true));
        ivy::set_built_in_type (ivy::verb::__t (ivy::verb::comma),ivy::from_str< str::__t > ("alpha * beta -> alpha * beta"),ivy::native_bool
                    (false),ivy::native_bool (true),ivy::native_bool (true),ivy::native_bool (false));
        ivy::set_built_in_type (ivy::verb::__t (ivy::verb::varv),ivy::from_str< str::__t > ("alpha -> alpha"),ivy::native_bool
                    (false),ivy::native_bool (true),ivy::native_bool (true),ivy::native_bool (true));
    }
    {
        cpp::verb_to_arity (cpp::verb::__t (cpp::verb::numeral)) = pos::__t (0);
        cpp::verb_to_arity (cpp::verb::__t (cpp::verb::fltnum)) = pos::__t (0);
        cpp::verb_to_arity (cpp::verb::__t (cpp::verb::string)) = pos::__t (0);
        cpp::verb_to_arity (cpp::verb::__t (cpp::verb::logvar)) = pos::__t (0);
    }
    {
        cpp::str_to_verb (ivy::from_str< str::__t > ("<->")) = cpp::verb::__t (cpp::verb::iff);
        cpp::verb_to_str (cpp::verb::__t (cpp::verb::iff)) = ivy::from_str< str::__t > ("<->");
        cpp::verb_to_prio (cpp::verb::__t (cpp::verb::iff)) = priority::__t (2);
        cpp::verb_to_arity (cpp::verb::__t (cpp::verb::iff)) = pos::__t (2);
    }
    {
        cpp::str_to_verb (ivy::from_str< str::__t > ("|")) = cpp::verb::__t (cpp::verb::__or);
        cpp::verb_to_str (cpp::verb::__t (cpp::verb::__or)) = ivy::from_str< str::__t > ("|");
        cpp::verb_to_prio (cpp::verb::__t (cpp::verb::__or)) = priority::__t (3);
        cpp::verb_to_arity (cpp::verb::__t (cpp::verb::__or)) = pos::__t (2);
    }
    {
        cpp::str_to_verb (ivy::from_str< str::__t > ("&")) = cpp::verb::__t (cpp::verb::__and);
        cpp::verb_to_str (cpp::verb::__t (cpp::verb::__and)) = ivy::from_str< str::__t > ("&");
        cpp::verb_to_prio (cpp::verb::__t (cpp::verb::__and)) = priority::__t (4);
        cpp::verb_to_arity (cpp::verb::__t (cpp::verb::__and)) = pos::__t (2);
    }
    {
        cpp::str_to_verb (ivy::from_str< str::__t > ("<")) = cpp::verb::__t (cpp::verb::lt);
        cpp::verb_to_str (cpp::verb::__t (cpp::verb::lt)) = ivy::from_str< str::__t > ("<");
        cpp::verb_to_prio (cpp::verb::__t (cpp::verb::lt)) = priority::__t (6);
        cpp::verb_to_arity (cpp::verb::__t (cpp::verb::lt)) = pos::__t (2);
    }
    {
        cpp::str_to_verb (ivy::from_str< str::__t > ("<=")) = cpp::verb::__t (cpp::verb::leq);
        cpp::verb_to_str (cpp::verb::__t (cpp::verb::leq)) = ivy::from_str< str::__t > ("<=");
        cpp::verb_to_prio (cpp::verb::__t (cpp::verb::leq)) = priority::__t (6);
        cpp::verb_to_arity (cpp::verb::__t (cpp::verb::leq)) = pos::__t (2);
    }
    {
        cpp::str_to_verb (ivy::from_str< str::__t > (">")) = cpp::verb::__t (cpp::verb::gt);
        cpp::verb_to_str (cpp::verb::__t (cpp::verb::gt)) = ivy::from_str< str::__t > (">");
        cpp::verb_to_prio (cpp::verb::__t (cpp::verb::gt)) = priority::__t (6);
        cpp::verb_to_arity (cpp::verb::__t (cpp::verb::gt)) = pos::__t (2);
    }
    {
        cpp::str_to_verb (ivy::from_str< str::__t > (">=")) = cpp::verb::__t (cpp::verb::geq);
        cpp::verb_to_str (cpp::verb::__t (cpp::verb::geq)) = ivy::from_str< str::__t > (">=");
        cpp::verb_to_prio (cpp::verb::__t (cpp::verb::geq)) = priority::__t (6);
        cpp::verb_to_arity (cpp::verb::__t (cpp::verb::geq)) = pos::__t (2);
    }
    {
        cpp::str_to_verb (ivy::from_str< str::__t > ("+")) = cpp::verb::__t (cpp::verb::plus);
        cpp::verb_to_str (cpp::verb::__t (cpp::verb::plus)) = ivy::from_str< str::__t > ("+");
        cpp::verb_to_prio (cpp::verb::__t (cpp::verb::plus)) = priority::__t (12);
        cpp::verb_to_arity (cpp::verb::__t (cpp::verb::plus)) = pos::__t (2);
    }
    {
        cpp::str_to_verb (ivy::from_str< str::__t > ("-")) = cpp::verb::__t (cpp::verb::minus);
        cpp::verb_to_str (cpp::verb::__t (cpp::verb::minus)) = ivy::from_str< str::__t > ("-");
        cpp::verb_to_prio (cpp::verb::__t (cpp::verb::minus)) = priority::__t (12);
        cpp::verb_to_arity (cpp::verb::__t (cpp::verb::minus)) = pos::__t (2);
    }
    {
        cpp::str_to_verb (ivy::from_str< str::__t > ("*")) = cpp::verb::__t (cpp::verb::times);
        cpp::verb_to_str (cpp::verb::__t (cpp::verb::times)) = ivy::from_str< str::__t > ("*");
        cpp::verb_to_prio (cpp::verb::__t (cpp::verb::times)) = priority::__t (13);
        cpp::verb_to_arity (cpp::verb::__t (cpp::verb::times)) = pos::__t (2);
    }
    {
        cpp::str_to_verb (ivy::from_str< str::__t > ("/")) = cpp::verb::__t (cpp::verb::div);
        cpp::verb_to_str (cpp::verb::__t (cpp::verb::div)) = ivy::from_str< str::__t > ("/");
        cpp::verb_to_prio (cpp::verb::__t (cpp::verb::div)) = priority::__t (13);
        cpp::verb_to_arity (cpp::verb::__t (cpp::verb::div)) = pos::__t (2);
    }
    {
        cpp::str_to_verb (ivy::from_str< str::__t > ("()")) = cpp::verb::__t (cpp::verb::empty);
        cpp::verb_to_str (cpp::verb::__t (cpp::verb::empty)) = ivy::from_str< str::__t > ("()");
        cpp::verb_to_prio (cpp::verb::__t (cpp::verb::empty)) = priority::__t (0);
        cpp::verb_to_arity (cpp::verb::__t (cpp::verb::empty)) = pos::__t (0);
    }
    {
        cpp::str_to_verb (ivy::from_str< str::__t > ("bool")) = cpp::verb::__t (cpp::verb::boolv);
        cpp::verb_to_str (cpp::verb::__t (cpp::verb::boolv)) = ivy::from_str< str::__t > ("bool");
        cpp::verb_to_prio (cpp::verb::__t (cpp::verb::boolv)) = priority::__t (0);
        cpp::verb_to_arity (cpp::verb::__t (cpp::verb::boolv)) = pos::__t (0);
    }
    {
        cpp::str_to_verb (ivy::from_str< str::__t > ("true")) = cpp::verb::__t (cpp::verb::truev);
        cpp::verb_to_str (cpp::verb::__t (cpp::verb::truev)) = ivy::from_str< str::__t > ("true");
        cpp::verb_to_prio (cpp::verb::__t (cpp::verb::truev)) = priority::__t (0);
        cpp::verb_to_arity (cpp::verb::__t (cpp::verb::truev)) = pos::__t (0);
    }
    {
        cpp::str_to_verb (ivy::from_str< str::__t > ("false")) = cpp::verb::__t (cpp::verb::falsev);
        cpp::verb_to_str (cpp::verb::__t (cpp::verb::falsev)) = ivy::from_str< str::__t > ("false");
        cpp::verb_to_prio (cpp::verb::__t (cpp::verb::falsev)) = priority::__t (0);
        cpp::verb_to_arity (cpp::verb::__t (cpp::verb::falsev)) = pos::__t (0);
    }
    {
        cpp::str_to_verb (ivy::from_str< str::__t > (",")) = cpp::verb::__t (cpp::verb::comma);
        cpp::verb_to_str (cpp::verb::__t (cpp::verb::comma)) = ivy::from_str< str::__t > (",");
        cpp::verb_to_prio (cpp::verb::__t (cpp::verb::comma)) = priority::__t (1);
        cpp::verb_to_arity (cpp::verb::__t (cpp::verb::comma)) = pos::__t (2);
    }
    {
        cpp::str_to_verb (ivy::from_str< str::__t > (".")) = cpp::verb::__t (cpp::verb::dot);
        cpp::verb_to_str (cpp::verb::__t (cpp::verb::dot)) = ivy::from_str< str::__t > (".");
        cpp::verb_to_prio (cpp::verb::__t (cpp::verb::dot)) = priority::__t (100);
        cpp::verb_to_arity (cpp::verb::__t (cpp::verb::dot)) = pos::__t (2);
    }
    {
        cpp::str_to_verb (ivy::from_str< str::__t > ("(")) = cpp::verb::__t (cpp::verb::app);
        cpp::verb_to_str (cpp::verb::__t (cpp::verb::app)) = ivy::from_str< str::__t > ("(");
        cpp::verb_to_prio (cpp::verb::__t (cpp::verb::app)) = priority::__t (99);
        cpp::verb_to_arity (cpp::verb::__t (cpp::verb::app)) = pos::__t (1);
    }
    {
        cpp::str_to_verb (ivy::from_str< str::__t > ("new")) = cpp::verb::__t (cpp::verb::__new);
        cpp::verb_to_str (cpp::verb::__t (cpp::verb::__new)) = ivy::from_str< str::__t > ("new");
        cpp::verb_to_prio (cpp::verb::__t (cpp::verb::__new)) = priority::__t (100);
        cpp::verb_to_arity (cpp::verb::__t (cpp::verb::__new)) = pos::__t (1);
    }
    {
        cpp::str_to_verb (ivy::from_str< str::__t > ("->")) = cpp::verb::__t (cpp::verb::arrow);
        cpp::verb_to_str (cpp::verb::__t (cpp::verb::arrow)) = ivy::from_str< str::__t > ("->");
        cpp::verb_to_prio (cpp::verb::__t (cpp::verb::arrow)) = priority::__t (100);
        cpp::verb_to_arity (cpp::verb::__t (cpp::verb::arrow)) = pos::__t (2);
    }
    {
        cpp::str_to_verb (ivy::from_str< str::__t > ("==")) = cpp::verb::__t (cpp::verb::equals);
        cpp::verb_to_str (cpp::verb::__t (cpp::verb::equals)) = ivy::from_str< str::__t > ("==");
        cpp::verb_to_prio (cpp::verb::__t (cpp::verb::equals)) = priority::__t (5);
        cpp::verb_to_arity (cpp::verb::__t (cpp::verb::equals)) = pos::__t (2);
    }
    {
        cpp::str_to_verb (ivy::from_str< str::__t > ("!=")) = cpp::verb::__t (cpp::verb::notequals);
        cpp::verb_to_str (cpp::verb::__t (cpp::verb::notequals)) = ivy::from_str< str::__t > ("!=");
        cpp::verb_to_prio (cpp::verb::__t (cpp::verb::notequals)) = priority::__t (5);
        cpp::verb_to_arity (cpp::verb::__t (cpp::verb::notequals)) = pos::__t (2);
    }
    {
        cpp::str_to_verb (ivy::from_str< str::__t > ("!")) = cpp::verb::__t (cpp::verb::__not);
        cpp::verb_to_str (cpp::verb::__t (cpp::verb::__not)) = ivy::from_str< str::__t > ("!");
        cpp::verb_to_prio (cpp::verb::__t (cpp::verb::__not)) = priority::__t (15);
        cpp::verb_to_arity (cpp::verb::__t (cpp::verb::__not)) = pos::__t (1);
    }
    {
        cpp::str_to_verb (ivy::from_str< str::__t > ("?")) = cpp::verb::__t (cpp::verb::ite);
        cpp::verb_to_str (cpp::verb::__t (cpp::verb::ite)) = ivy::from_str< str::__t > ("?");
        cpp::verb_to_prio (cpp::verb::__t (cpp::verb::ite)) = priority::__t (2);
        cpp::verb_to_arity (cpp::verb::__t (cpp::verb::ite)) = pos::__t (3);
    }
    {
        ivy::cpp_reserved_word (ivy::from_str< str::__t > ("bool")) = ivy::native_bool (true);
        ivy::cpp_reserved_word (ivy::from_str< str::__t > ("char")) = ivy::native_bool (true);
        ivy::cpp_reserved_word (ivy::from_str< str::__t > ("int")) = ivy::native_bool (true);
        ivy::cpp_reserved_word (ivy::from_str< str::__t > ("long")) = ivy::native_bool (true);
        ivy::cpp_reserved_word (ivy::from_str< str::__t > ("new")) = ivy::native_bool (true);
        ivy::cpp_reserved_word (ivy::from_str< str::__t > ("and")) = ivy::native_bool (true);
        ivy::cpp_reserved_word (ivy::from_str< str::__t > ("or")) = ivy::native_bool (true);
        ivy::cpp_reserved_word (ivy::from_str< str::__t > ("not")) = ivy::native_bool (true);
        ivy::cpp_reserved_word (ivy::from_str< str::__t > ("float")) = ivy::native_bool (true);
        ivy::cpp_reserved_word (ivy::from_str< str::__t > ("double")) = ivy::native_bool (true);
    }
    if (argv::end() > pos::__t (1))
    {
        str::__t name;
        name = argv::value (pos::__t (1));
        ivy::prog::file_to_cpp (name);
        if (ivy::errors . end == vector__ivy__error::domain::__t (0))
        {
            str::__t cpp_name;
            {
                cpp_name = name;
                ivy::path::change_extension (cpp_name,ivy::from_str< str::__t > ("cpp"));
            }
            vector__str::__t com;
            com . append (ivy::from_str< str::__t > ("g++"));
            com . append (ivy::from_str< str::__t > ("-O2"));
            vector__str::domain::__t idx;
            idx = ivy::include_path . begin();
            while (idx < ivy::include_path . end)
            {
                com . append (ivy::from_str< str::__t > ("-I"));
                com . append (ivy::include_path . value (idx));
                idx = idx . next();
            }
            com . append (ivy::from_str< str::__t > ("-o"));
            str::__t bin_name;
            {
                bin_name = name;
                ivy::path::drop_extension (bin_name);
            }
            com . append (bin_name);
            com . append (ivy::from_str< str::__t > ("-std=c++17"));
            com . append (cpp_name);
            str::__t full_com;
            full_com = com . value (vector__str::domain::__t (0));
            vector__str::domain::__t jdx;
            jdx = com . begin() . next();
            while (jdx < com . end)
            {
                full_com . extend (ivy::from_str< str::__t > (" "));
                full_com . extend (com . value (jdx));
                jdx = jdx . next();
            }
            stdio::writeln (full_com);
            pid::__t p;
            p = cmd::command (com);
            retcode::__t rc;
            rc = cmd::wait (p);
            if (rc == retcode::__t (0)) {
                stdio::writeln (ivy::from_str< str::__t > ("success"));
            } else {
                stdio::writeln (ivy::from_str< str::__t > ("error returned"));
            }
        }
    } else {
        usage();
    }
    return 0;
}